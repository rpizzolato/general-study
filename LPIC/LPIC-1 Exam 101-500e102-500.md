# LPIC-1 Exam 101
#### Version: 5.0
LPIC-1 é a primeira certificação no programa de certificação profissional Linux multinível da LPI. O LPIC-1 validará a capacidade do candidato de realizar tarefas de manutenção na linha de comando, instalar e configurar um computador executando Linux e configurar a rede básica.

#### Anotações para servir de resumo e consulta futuramente

## Tópico 101: Arquitetura de Sistema

101.1 Identificar e editar configurações de hardware
 101.1 Lição 1
101.2 Início (boot) do sistema
 101.2 Lição 1
101.3 Alternar runlevels/boot targets, desligar e reiniciar o sistema
 101.3 Lição 1

 ---

### 101.1 Identificar e editar configurações de hardware

---

#### BIOS

BIOS é o firmware da placa mãe, onde é feito o gerenciamento dos dispositivos conectados à placa mãe.

- `BIOS: Basic Input Output System`
- `POST: Power-On Self-Test`
- `Gerencia de dispositivos, IRQ, I/O, DMA, etc`
- `Inicia Processo de Boot`
- `EFI (Extensible Firmware Interface)`
- `UEFI (Unified Extensible Firmware Interface)`

---

#### IRQ

- `IRQ`: Interrupt Request (é um sinal enviado à CPU), podemos ver em `/proc/interrupts` (mostra uma coluna por CPU). O `IRQ` **NÃO** pode haver conflitos

Principais IRQs:
- IRQ0 - Sinal de clock da placa mãe
- **IRQ1 - Teclado**
- IRQ2 - Cascateador de IRQs
- **IRQ3 - Porta serial 2 (RS-232)**
- **IRQ4 - Porta serial 1 (RS-232)**
- IRQ5 - Livre
- IRQ6 - Drive de disquetes
- IRQ7 - Porta paralela (impressora)
- IRQ8 - Relógio do CMOS
- IRQ9 - Placa de vídeo
- IRQ10 - Livre
- IRQ11 - Controlador USB
- IRQ12 - Porta PS/2
- IRQ13 - Coprocessador aritmético
- **IRQ14 - IDE Primária**
- **IRQ15 - IDE Secundária**

>[!NOTE]
>
>O número do IRQ é uma prioridade, do `0` ao `2`, que é o cascateador, ele pula para o `8` até o `15`, depois continua do `3` ao `7`. Ficando, **1,2,8,9,10,11,12,13,14,15,3,4,5,6,7**

---

#### Endereços I/O (E/S)

Endereços de `I/O (E/S)`, lista de endereços de memória utilizadas para comunicação entre o CPU e os demais dispositivos de hardware. Fica em `/proc/ioports`

Exemplo

```
 $sudo cat /proc/ioports
0000-0001f : dma
10020-0021: pic
10040-0043: timer
10050-0053: timer
10060-006f: keyboard
0070-0077: rtc
0080-008f: dma page reg
00a0-00a1: pic
200f0-00ff: fpu
```

#### DMA

`DMA`: *Direct Memory Addressing* (um canal que permite que os dispositivos transmitam os dados diretamente à memória, sem utilizar a CPU - há uma melhora de performance)

>[!NOTE]
>
>**Não** é utilizado por todos os dispositivos

Fica em `/proc/dma`

---

### Resumidamente...

Resumidamente, precisamos saber que:

- **IRQ**: `/proc/interrupts`
- **Endereços de I/O (E/S)**: `/proc/ioports` (executar como root o cat)
- **DMA**: `/proc/dma`




Partições Virtuais: montado dinamicamente conforme a execução do SO

- `/proc`: informações dos processos ativos e recursos de hardware
- `/sys`: informações sobre dispositivos de hardware (sysfs) - similar ao `/proc`
- `/dev`: referências aos dispositivos do sistema, inclusive de armazenamento (udev)
- `udev`: Device Manager
- `dbus` ou `hald`: Comunicação entre processos. Informa os processos a situação dos dispositivos de hardware.

---

#### PCI, USB, /dev /sys /proc, sysfs (barramentos)

**Barramentos**: interface de comunicação física entre os dispositivos e a placa mãe:

- `PCI`: *Peripheral Component Interconnect* (`lspci`)
- `USB`: *Universal Serial Bus* (`lsusb`)

---

#### comandos lspci e lsusb


- `lspci`: lista todos os dispositivos PCI
```
$ lspci
00:00.0 Host bridge: Intel Corporation Comet Lake-S 6c Host Bridge/DRAM Controller (rev 03)
00:02.0 VGA compatible controller: Intel Corporation CometLake-S GT2 [UHD Graphics 630] (rev 03)
00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5/v6 / E3-1500 v5 / 6th/7th/8th Gen Core Processor Gaussian Mixture Model
00:14.0 USB controller: Intel Corporation Comet Lake PCH-V USB Controller
```

- `lspci -s 00:02.0 -v` : lista os detalhes do dispositivo de id `00:02.0`
    - formado do `-s`: `[[[[<domain>]:]<bus>]:][<device>][.[<func>]]`
```
$ lspci -s 00:02.0 -v
00:02.0 VGA compatible controller: Intel Corporation CometLake-S GT2 [UHD Graphics 630] (rev 03) (prog-if 00 [VGA controller])
	DeviceName: Onboard - Video
	Subsystem: Dell CometLake-S GT2 [UHD Graphics 630]
	Flags: bus master, fast devsel, latency 0, IRQ 148, IOMMU group 0
	Memory at d0000000 (64-bit, non-prefetchable) [size=16M]
	Memory at c0000000 (64-bit, prefetchable) [size=256M]
	I/O ports at 4000 [size=64]
	Expansion ROM at 000c0000 [virtual] [disabled] [size=128K]
	Capabilities: <access denied>
	Kernel driver in use: i915
	Kernel modules: i915

```

Com verbose, nos mostra inclusive o `kernel in use`. No entanto se quiser mais detalhes, use a opção `-k`
```
$ lspci -s 01:00.0 -k
01:00.0 VGA compatible controller: NVIDIA Corporation GM107 [GeForce GTX 750 Ti] (rev a2)
    kernel driver in use: nvidia
    kernel modules: nouveau, nvidia_drm, nvidia
```

>[!TIP]
>
>Os comandos diretamente relacionados ao hardware geralmente requerem privilégios de root para serem executados, exibindo apenas informações limitadas quando executados por um usuário normal; portanto, pode ser necessário fazer login como root ou executar o comando com `sudo`.

---

- `lsusb`: lista todos os dispositivos USB. mostra o **Barramento** (Bus 001), o **Dispositivo** (001), o **ID** e o **nome**
```
$ lsusb
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver
Bus 001 Device 003: ID 413c:2113 Dell Computer Corp. KB216 Wired Keyboard
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
```

- `lsusb -s 001:001 -v`: mostra detalhes do dispositivo `001:001`. (**cuidado** que **não** é o `id`, e sim a junção de `Barramento` e `Dispositivo`). O `-s` vem de `[[bus]:][devnum]`
```
$ lsusb -s 001:001 -v

Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Couldn't open device, some information will be missing
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            9 Hub
  bDeviceSubClass         0 [unknown]
  bDeviceProtocol         1 Single TT
  bMaxPacketSize0        64
  idVendor           0x1d6b Linux Foundation
  idProduct          0x0002 2.0 root hub
  bcdDevice            6.08
  iManufacturer           3 Linux 6.8.0-51-generic xhci-hcd
  iProduct                2 xHCI Host Controller
  iSerial                 1 0000:00:14.0
  bNumConfigurations      1
#ocultado resultado, muito extenso
```

Nos barramentos USB, podemos ter um ou mais Barramentos com diversos dispositivos dentro dele (no caso, `BUS`). E cada `BUS` (barramento) tem seus `Devices`

Exemplo
```
Bus 001 Device 001
Bus 001 Device 002
Bus 002 Device 001
etc
```

Similar à opção `-s`, pode usar a opção `-d`, seguindo o seguinte padrão: `-d [vendor]:[product]`, que o caso é o `ID` do dispositivo.

>[!NOTE]
>
>Para usar o `id` do USB para busca, usamos o `-d` (`device`): `lsusb -v -d 046d:c52b`
```
$ lsusb -v -d 046d:c52b 

Bus 001 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver
Couldn't open device, some information will be missing
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            0 [unknown]
  bDeviceSubClass         0 [unknown]
  bDeviceProtocol         0 
  bMaxPacketSize0         8
  idVendor           0x046d Logitech, Inc.
  idProduct          0xc52b Unifying Receiver
  bcdDevice           12.11
  iManufacturer           1 Logitech
  iProduct                2 USB Receiver
  iSerial                 0 
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
####ocultado pois saída muito longa
```
>[!TIP]
>
>Com a opção `-t` ou `--tree`, o comando `lsusb` mostra os mapeamentos do dispositivo USB atual na forma de **árvore hierárquica**
```
lsusb -t
/:  Bus 001.Port 001: Dev 001, Class=root_hub, Driver=xhci_hcd/12p, 480M
    |__ Port 007: Dev 002, If 0, Class=Human Interface Device, Driver=usbhid, 12M
    |__ Port 007: Dev 002, If 1, Class=Human Interface Device, Driver=usbhid, 12M
    |__ Port 007: Dev 002, If 2, Class=Human Interface Device, Driver=usbhid, 12M
    |__ Port 009: Dev 003, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
    |__ Port 009: Dev 003, If 1, Class=Human Interface Device, Driver=usbhid, 1.5M
/:  Bus 002.Port 001: Dev 001, Class=root_hub, Driver=xhci_hcd/8p, 5000M
```

---

#### As Partições Virtuais

Partição dinâmica (não há dados de arquivos e diretórios). É uma partição com informações do sistema, no momento de sua execução (informações de processos, dispositivos conectados, etc).

Partições Virtuais são montadas dinamicamente conforme a execução do SO

- `/proc`: informações dos processos ativos e de recursos de hardware (informações, dados, estatística dos processos que estão em execução no computador)
- `/sys`: informações sobre dispositivos de hardware (`sysfs`)
- `/dev`: referências ao dispositivos do sistema, inclusive de armazenamento (`udev`). Exemplo `/dev/hda`, referencia um HD
    - `udev`: Device Manager (no caso, seria esse processo `/usr/lib/systemd/systemd-udevd`, visto com o comando `ps axu | grep udev`)
    - `dbus` ou `hald` (`hald` está em processo de depreciação): Comunicação entre processos. Informa os processos a situação dos dispositivos de hardware. (do processo `/usr/bin/dbus-daemon`)

- `ColdPlug`: Ex. memória ram (tem que desligar o PC)
- `HotPlug`:  Ex. HD externo via USB

Os arquivos dentro do diretório `/sys` têm funções semelhantes às do `/proc`. No entanto, o diretório `/sys` tem o objetivo específico de armazenar informações do dispositivo e dados do kernel relacionados ao hardware.

Ao passo que `/proc` também contém informações sobre diversas estruturas de dados do kernel, incluindo processos em execução e configurações.

```
$ df -a
df: /run/user/1000/doc: Operation not permitted
Filesystem             1K-blocks     Used Available Use% Mounted on
sysfs                          0        0         0    - /sys
proc                           0        0         0    - /proc
udev                     8018144        0   8018144   0% /dev
```

---

### complementando o /proc

Em `/proc`, o kernel faz acesso direto às informações listadas. Lembrando que `/proc` é um sistema de arquivos virtual carregada em memória, que não está fisicamente no disco. Se fizermos uma alteração em algum arquivo dentro de `/proc`, essa alteração vai ser repassada diretamente ao kernel.

em `/proc/cmdline`, é onde, no grub, que é repassado os comandos de parâmetros do bootloader para o kernel
```
BOOT_IMAGE=/vmlinuz-6.8.0-51-generic root=UUID=ed75f0cb-cf1f-4598-a66a-8f3b39ba3588 ro quiet splash
```

Em `/proc/filesystems`, são os *filesystems* que podem ser usados nas partições que temos disponíveis
```
nodev	sysfs
nodev	tmpfs
nodev	bdev
nodev	proc
nodev	cgroup
nodev	cgroup2
nodev	cpuset
nodev	devtmpfs
nodev	configfs
nodev	debugfs
nodev	tracefs
nodev	securityfs
nodev	sockfs
#ocultado, saída muito extensa
```

Em `/proc/mounts`, são os partições que estão montadas. Que na verdade é um link para `/proc/self/mounts`
```
$ ls -l /proc/mounts 
lrwxrwxrwx 1 root root 11 Jan 10 08:05 /proc/mounts -> self/mounts
```


```
$ cat /proc/mounts 
sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0
proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
udev /dev devtmpfs rw,nosuid,relatime,size=8018144k,nr_inodes=2004536,mode=755,inode64 0 0
devpts /dev/pts devpts rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0
tmpfs /run tmpfs rw,nosuid,nodev,noexec,relatime,size=1611476k,mode=755,inode64 0 0
efivarfs /sys/firmware/efi/efivars efivarfs rw,nosuid,nodev,noexec,relatime 0 0
/dev/nvme0n1p4 / ext4 rw,relatime,errors=remount-ro 0 0
securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime 0 0
#ocultado, saída muito extensa
```

---

#### resumo dos demais

- `/proc/interrupts`: Uma lista de números de interrupções por dispositivo de entrada e saída em cada CPU.
- `/proc/ioports`: Lista as regiões de portas de Entrada/Saída registradas atualmente e em uso.
- `/proc/dma`: Lista os canais registrados de DMA (acesso direto à memória) em uso.

---

#### udev

O `udev` é o processo `systemd-udev` (`ps axu | grep udev`) (que é o udev acoplado ao systemd). Quando liga o computador, é ele que identifica os dispositivos que estão conectados e cria as ligações a eles, criando um mapeamento dos dispositivos. Além disso o `udev` fica monitorando todo periférico que é adicionado ou retirado do computador (como pen drives ou mouse, por exemplo)

Uma curiosidade é o comando `udevadm monitor` (comum cair na LPIC-2 apenas), que fica monitorando o que  acontece no sistema, de acordo com as regras que estão em `/lib/udev/rules.d/` (repare que há diversos arquivos com um número na frente, que nada mais é que a sequencia que o `udev` deve seguir na execução). Caso seja necessário criar as próprias regras, deve usar `/etc/udev/rules.d/`


Nas distribuições Linux atuais, o `udev` é responsável pela identificação e configuração dos dispositivos já presentes durante a inicialização da máquina (detecção `coldplug`) e dos dispositivos identificados enquanto o sistema está em execução (detecção hotplug). O `udev` utiliza o `SysFS`, o pseudosistema de arquivos montado em `/sys` para informações relacionadas ao hardware

Se executarmos `df -T /dev`, é retornado o *filesystem* do `udev`, que gerencia o diretório `/dev`
```
$ df -T /dev/
Filesystem     Type     1K-blocks  Used Available Use% Mounted on
udev           devtmpfs   8018144     0   8018144   0% /dev
```

Em `/dev`, se dermos um `ls -l`, é mostrado o que o `udev` gerencia, que no caso não são arquivos em si (arquivos em disco).

Se executarmos `df -T --type=tmpfs`, significa que é um tipo de *filesystem* (o `tmpfs`) que grava os arquivos em **memória**, e não em disco (algo temporário, dinâmico).
```
$ df -T --type=tmpfs
Filesystem     Type  1K-blocks   Used Available Use% Mounted on
tmpfs          tmpfs   1611476   2536   1608940   1% /run
tmpfs          tmpfs   8057364 242400   7814964   4% /dev/shm
tmpfs          tmpfs      5120      8      5112   1% /run/lock
tmpfs          tmpfs   8057364      0   8057364   0% /run/qemu
tmpfs          tmpfs   1611472   2660   1608812   1% /run/user/1000
```
Vale muito a pena dar uma lida no `man udev`.

---

#### IDE, PATA, SATA, SCSI


- `(P)ATA`: *Parallel Advanced Technology Attachment*: interface de conexão IDE (que tem **master** e **slave**)
    - O cabo Paralelo tem a opção de conectar um lado na placa mãe, e 2 HDs, seguindo a ordem:

- `/dev/hda` ou `sda` - **master**
- `/dev/hdb` ou `sdb` - **slave**
- `/dev/hdc` ou `sdc` - **master**
- `/dev/hdd` ou `sdd` - **slave**

- `CD/DVD` em IDE, também é referenciado como `hdX`

---

- `SATA`: *Serial Advanced Technology Attachment*
- 1 disco por cabo
- mais rápido que o PATA

Mapeados da seguinte forma:

- `/dev/sda`: primeiro disco
- `/dev/sdb`: segundo disco
- `/dev/sdc`: terceiro disco

---

- `SCSI`: *Small Computer System Interface*
- `Tipos`:
    - `8 bits`: permite 7 dispositivos + 1 controlador
    - `16 bits`: permite 15 dispositivos + 1 controlador

- `SCSI_ID`:
    - `Canal`: identificador de cada adaptador (conjunto de dispositivos, `8` ou `16 bits`)
    - `ID`: Identificador de cada dispositivo
    - `LUN`:Número Lógico da Unidade

- `Mapeados no Linux como`:
    - `/dev/sda`: primeiro disco
    - `/dev/sdb`: segundo disco
    - `/dev/sdc`: terceiro disco

- Informações do disco SCSI podem ser vistas em: `/prov/scsi/scsi`
```
$ cat /proc/scsi/scsi 
Attached devices:
Host: scsi3 Channel: 00 Id: 00 Lun: 00
  Vendor: HL-DT-ST Model: DVD+-RW GU90N    Rev: A1C6
  Type:   CD-ROM            
```

---

#### Outros Dispositivos:

- `/dev/fd0`: disquete / floppy disk
- `/dev/scd0`: SCSI Cd-ROM
- `/dev/sr0`: SCSI DVD
- `/dev/cdrom`: normalmente criado como link para o device do cdrom
- `/dev/dvd`: normalmente criado como link para o device do dvd

Portanto, normalmente o `ls -l /dev/cdrom` aponta para `sr0`, assim como `ls -l /dev/dvd`

```
$ ls /dev/cdrom -l
lrwxrwxrwx 1 root root 3 Jan 10 08:05 /dev/cdrom -> sr0
```

É possível ver os discos que foram adicionados (attached) durante o boot do computador com o comando `dmesg | grep "sda\|nvme"`

** md* é o arranjo RAID, md é de Multiple Device. Lembrando que RAID é assunto da LPIC-2 apenas

A exceção a esse padrão ocorre com cartões de memória (cartões SD) e dispositivos `NVMe` (SSD conectados ao barramento PCI Express). Para os cartões SD, os caminhos `/dev/mmcblk0p1`, `/dev/mmcblk0p2` etc. são usados para a primeira e a segunda partições do dispositivo identificado primeiro e `/dev/mmcblk1p1`, `/dev/mmcblk1p2`, etc. identificam a primeira e a segunda partições do dispositivo identificado em segundo lugar. Os dispositivos `NVMe` recebem o prefixo `nvme`, como em `/dev/nvme0n1p1` e `/dev/nvme0n1p2`.

---

####  lsmod, modinfo, modprobe, insmod

Todo hardware para que funcione, precisa de um software para que funcione. Esse software pode estar contido no kernel do linux, dependendo dos casos. É o equivalente aos `drivers` no Windows. No linux são chamados de `módulos`.

Local dos Módulos: `/lib/modules/versao_kernel/kernel` (digita `uname -r` para ver a versão utilizada no momento, ou simplesmente digite <code>ls /lib/modules/\`uname -r\`/kernel</code>)

Para escolher um em específico, navega até a pasta mostrado no comando anterior, escolhe por exemplo, `sound/pci` e manda listar 

Os módulos são os arquivos `.ko` (geralmente não carrega tudo, vai carregando conforme necessidade)

Em `/etc/modules` (um arquivo, dê um `cat` nele para ver o conteúdo), podemos definir quais módulos desejamos carregar, sem a necessidade do linux carregar sozinho.

---

#### lsmod

- `lsmod`: lista os módulos carregados pelo sistema (**nome**, **tamanho em memória**, e **usado por**, que é igual a **dependência**), em inglês:
- `Module`: nome do módulo
- `Size`: quantidade de RAM utilizado pelo módulo, em bytes
- `Used by`: módulos dependentes
```
Module                  Size  Used by
intel_powerclamp       16384    0
snd_pcm               192512  13 snd_ac97_codec,snd_inter8x0
```

No caso acima, `snd_pcm`, é utilizado por mais dois outros módulos: `snd_ac97_codec` e `snd_inter8x0`. 

Quando o módulo está com `Used`=`0`, quer dizer ele está carregado, mas não está em uso no momento

No caso de `1`, o módulo está em uso, por ele mesmo ou por outro processo


>[!NOTE]
>
>o `lsmod` lê/consulta o arquivo `/proc/modules`

- `modinfo nome_do_modulo`: lista informações do módulo, como **filename** (com caminho do módulo), **versão**, **licença**, **descrição**, **autor**, etc

Exemplo: `$ modinfo fjes`
```
filename:       /lib/modules/5.15.0-119-generic/kernel/drivers/net/fjes/fjes.ko
version:        1.2
license:        GPL
description:    FUJITSU Extended Socket Network Device Driver
author:         Taku Izumi <izumi.taku@jp.fujitsu.com>
srcversion:     E3B83668942FFC6AE950574
alias:          acpi*:PNP0C02:*
etc...
```

#### Remover módulo:

- `rmmod`: remove um módulo que esteja carregado

Exemplo de uso:

- `lsmod | grep mouse`: retorna o nome do módulo, que no caso é `psmouse`
- `modinfo psmouse`: retorna o endereço do filename: `/lib/modules/kernel_version/drivers/input/mouse/psmouse.ko`
- `rmmod pmouse`: remove o módulo `psmouse.ko`
- `lsmod | grep mouse`: não lista mais nada, e é para o mouse parar de funcionar

>[!NOTE]
>
>O `modprobe` pode ser usado para remover módulos: `modprobe -r bluecard_cs` ou `--remove` (descarrega as dependências também)

#### Inserir o módulo:

- `insmod /lib/modules/kernel_version/drivers/input/mouse/psmouse.ko`: carrega o módulo que foi descarregado anteriormente (precisa do caminho completo e **NÃO** carrega as dependências)
- `modprobe modulo`: (insere/carrega/adiciona módulo e mapeia/adiciona outros módulos que sejam necessários)

Exemplo: `modprobe bluecard_cs` (módulo para bluetooth, **JUNTAMENTE** com os módulos necessários, como o `bluetooth` e o `pcmcia`)
```
# lsmod|grep blue
bluecard_cs            16384  0
bluetooth            1028096  1 bluecard_cs
pcmcia                 86016  1 bluecard_cs
```

- `lsmod | grep blue` (vai listar o módulo que acabou de ser carregado pelo `modprobe` e suas dependências)

>[!NOTE]
>
>O `modprobe` pode ser usado para remover módulos: `modprobe -r bluecard_cs` (**descarrega as dependências também**)

>[!NOTE]
>
>Alterações permanentes no módulo devem ser feitas em: `/etc/modprobe.conf` ou em arquivos individuais com a extensão `.conf` no diretório `/etc/modprobe.d/`

>[!NOTE]
>
>A opção `-p` fará com que o comando `modinfo` exiba todos os parâmetros disponíveis e ignore as outras informações.
```
```

---

#### um pouco mais sobre modprobe

Como já vimos, quando for necessário alterar algum módulo, faremos no diretório `/etc/modprobe.d/` incluindo a modificação `/etc/modprobe.conf` ou criando um próprio `.conf` para o módulo correspondente (o que é mais recomendável para administradores, criar seu próprio arquivo `.conf`).

Dentro de `/etc/modprobe.d` há diversos arquivos de configuração, passam informações aos módulos. Há também arquivos de **blacklist**, para que não carreguem o módulo especificado (pois pode haver mais de um módulo para um dispositivo, em casos de conflitos ou para isolar um módulo para testes)
```
cat blacklist_linux_6.8.0-51-generic.conf 
# Kernel supplied blacklist for linux 6.8.0-51-generic amd64
# modprobe.d/common.conf
# LP:1434842 -- disable OSS drivers by default to allow pulseaudio to emulate
blacklist snd-mixer-oss
blacklist snd-pcm-oss
# Autogenerated watchdog blacklist
blacklist acquirewdt
blacklist advantech_ec_wdt
blacklist advantechwdt
```

Com o comando `modinfo -p nouveau`, por exemplo, listamos as informações do módulo `nouveau`, um módulo do kernel fornecido pelo [nouveau project](https://en.wikipedia.org/wiki/Nouveau_(software)) como alternativa aos drivers proprietários das placas de GPU da NVIDIA.

Caso queiramos alterar a opção `modeset`, por exemplo, que permite controlar se a resolução e a profundidade da tela serão definidas no espaço do kernel em vez do espaço do usuário. Quando adicionamos `options nouveau modeset =0` ao arquivo `/etc/modprobe.d/nouveau.conf`, o recurso modeset do kernel é desativado.

Para impedir o carregamento automático do módulo `nouveau`, a linha `blacklist nouveau` deve ser adicionada ao arquivo `/etc/modprobe.d/blacklist.conf`. Essa ação é necessária quando o módulo proprietário nvidia é instalado e o módulo padrão nouveau deve ser posto de lado

Em `/lib/modprobe.d` temos arquivos de configurações que mandam opções para os módulos

Reforçando, tem também alguns arquivos de **blacklists**, como `fbdev-blacklist.conf`, que lista alguns módulos que são ignorados. Geralmente são módulos que estão dando problemas, ou quando temos mais de um módulo para um `device`, ou em casos que estão dando conflitos, ou ainda se quiser bloquear o módulo para testes. Lembrando que esse diretório é para o sistema.

Caso queira criar suas próprias regras, é recomendável alterar em `/etc/modprobe.d`

>[!NOTE]
>
>É possível modificar o arquivo `/etc/modprobe.d/blacklist.conf` que já existe no sistema por padrão. Porém, a melhor opção é criar um arquivo de configuração separado, `/etc/modprobe.d/<module_name>.conf`, contendo ajustes específicos àquele módulo do kernel em particular.

 Recomendado leitura de `man modprobe.d`

#### Exercício interessante no lpi.org
1. Os sistemas operacionais criados em torno do kernel do Linux também estão disponíveis para uma ampla variedade de arquiteturas de computadores além do x86, como os computadores de placa única baseados na arquitetura ARM. Um usuário atento notará a ausência do comando `lspci` nessas máquinas, como o Raspberry Pi. Que diferença em relação às máquinas x86 justifica essa ausência?

**Resposta**: Ao contrário da maioria das máquinas x86, um computador baseado em ARM, como o Raspberry Pi, não possui um barramento PCI; portanto, o comando `lspci` é inútil.

2. Em 2018, a vulnerabilidade de hardware conhecida como **Meltdown** foi descoberta. Ela afeta quase todos os processadores de diferentes arquiteturas. As versões mais recentes do kernel Linux podem informar se o sistema atual está vulnerável. Como obter essas informações?

**Resposta**: O arquivo `/proc/cpuinfo` tem uma linha que mostra os bugs conhecidos para a CPU correspondente, como por exemplo `bugs: cpu_meltdown`.

Exemplo: `Intel(R) Core(TM) i5-4300M CPU @ 2.60GHz`
```
$ grep meltdown /proc/cpuinfo
bugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds mmio_unknown
```

---

### 101.2 Inicialização do sistema

Envolve desde o momento que o computador é ligado, até o ponto que chega ao prompt de comandos.

A sequência (fluxo de boot) é: **BIOS** -> **MBR** -> **Bootloader (GRUB/LILO)** -> **Kernel** -> **Init**

Tendo as seguintes atribuições:
- `BIOS`: localiza e executa a MBR
- `MBR`: executa o bootloader
- `bootloader` (`GRUB` é o mais comum): seleciona e executa o `kernel` e o `initrd`
- `Kernel`: executa o `/sbin/ini`
- `Init`: inicia os programas/serviços do `runlevel`/`target` definido

>[!NOTE]
>
>O processo `POST` (power-on self-test) é executado para identificar falhas simples de hardware assim que a máquina é ligada.

---

#### MBR

- `Master Boot Recorder (MBR)`: localizado no primeiro setor do disco bootável, no caso, nos primeiros `512 bytes`.
    - `/dev/hda` ou `/dev/sda`
- Contém informações sobre o `GRUB`/`LILO`
- `MBR` carrega e executa o `GRUB`/`LILO`

| 512 bytes  |
|---|
| Bootloader 446 bytes  |
| Partition Table 64 bytes  |
| Validation Check 2 bytes  |

---

#### Bootloader (também chamado de bootstrap)

- `Bootloader` é o gerenciador de boot
- tem a função de carregar o sistema operacional na memória (lista de sistemas operacionais para escolha)
- sendo os mais comuns:
    - `GRUB` (versões Legacy e 2): Grand Unified Bootloader
    - `LILO` (era padrão antigamente)
- `initrd`/`initramfs`: também é carregado pelo bootloader para dar suporte ao kernel. `Filesystem root` (`/`) temporário é carregado em memória RAM

No menu do GRUB, é possível escolher qual dos kernels instalados deve ser carregado e passar novos parâmetros para ele. A maioria dos parâmetros do kernel segue o padrão `opção=valor`. Alguns dos parâmetros mais úteis do kernel são:
- `acpi`: Ativa/desativa o suporte a ACPI. `acpi=off` desabilita o suporte a ACPI.
- `init`: Define um iniciador de sistema alternativo. Por exemplo, `init=/bin/bash` define o shell Bash como iniciador. Assim, uma sessão do shell será iniciada logo após o processo de inicialização do kernel.
- `systemd.unit`: Define o destino do systemd a ser ativado. Por exemplo, `systemd.unit=graphical.target`. O systemd também aceita os níveis de execução numéricos definidos para `SysV`. Para ativar o nível de execução `, por exemplo, é necessário apenas incluir o número `1` ou a letra `S` (abreviação de “single”) como parâmetro do kernel.
- `mem`: Define a quantidade de RAM disponivel para o sistema. Este parâmetro é útil para limitar a RAM disponível para cada convidado em uma máquina virtual. Assim, `mem=512M` limita a 512 megabytes a quantidade de RAM disponível para um sistema convidado em particular.
- `maxcpus`: Limita o número de processadores (ou núcleos de processador) visíveis ao sistema em máquinas multiprocessador simétricas. Também é útil para máquinas virtuais. Um valor de `0` desativa o suporte a máquinas multiprocessador e tem o mesmo efeito do parâmetro do kernel `nosmp`. O parâmetro `maxcpus=2` limita a dois o número de processadores disponíveis para o sistema operacional.
- `quiet`: Oculta a maioria das mensagens de inicialização.
- `vga`: Seleciona um modo de vídeo. O parâmetro `vga=ask` mostra uma lista dos modos disponíveis a escolher.
- `root`: Define a partição raiz, diferente da que está configurada no bootloader. Por exemplo, `root=/dev/sda3`.
- `rootflags`: Opções de montagem para o arquivo de sistemas raiz.
- `ro`: Torna somente para leitura a montagem inicial do arquivo de sistemas raiz.
- `rw`: Permite escrever no arquivo de sistemas raiz durante a montagem inicial.

Geralmente não é necessário alterar os parâmetros do kernel, mas isso pode ser útil para detectar e resolver problemas relacionados ao sistema operacional. Os parâmetros do kernel devem ser adicionados ao arquivo `/etc/default/grub` na linha `GRUB_CMDLINE_LINUX` para que persistam após a inicialização. É necessário gerar um novo arquivo de configuração para o carregador de inicialização a cada vez que `/etc/default/grub` é alterado, o que é feito com o comando `grub-mkconfig -o /boot/grub/grub.cfg`. Quando o sistema operacional estiver rodando, os parâmetros do kernel usados para carregar a sessão ficam disponíveis para leitura no arquivo `/proc/cmdline`.

---

#### INIT - Initialization process

- tem a função de iniciar os primeiros processos e serviços do linux
- é o processo de `ID 1` (pai de todos os outros processos)
- possui `RunLevels` ou `Targets` que definem diferentes modos de operação e o grupo de serviços que será iniciado
- principais `INITs` utilizados:
    - `SystemV` (`SysV`) - `init` original (conceito dos `RunLevels`)
    - `systemd` (conceito dos `Targets` - que é uma melhoria do `RunLevel`)
    - `upstart` (também uma é forma de melhoria do `init` original)

>[!NOTE]
>
>Estritamente falando, o sistema operacional é apenas o kernel e seus componentes, que controlam o hardware e gerenciam todos os processos. É comum, no entanto, usar o termo “sistema operacional” de maneira mais vaga, para designar um grupo inteiro de programas distintos que compõem o ambiente de software onde o usuário pode executar as tarefas computacionais básicas.

A inicialização do sistema operacional começa quando o carregador de inicialização carrega o kernel na RAM. Nesse momento, o kernel assume o controle da CPU e começa a detectar e configurar os aspectos fundamentais do sistema operacional, como a configuração básica de hardware e o endereçamento de memória.

O kernel abre então o `initramfs` (initial RAM filesystem). O `initramfs` é um arquivo que contém um sistema de arquivos raiz temporário usado durante o processo de inicialização. O principal objetivo de um arquivo `initramfs` é fornecer os módulos necessários para que o kernel possa acessar o sistema de arquivos raiz “de verdade” do sistema operacional.

Logo que o sistema de arquivos raiz fica disponível, o kernel monta todos os sistemas de arquivos configurados em `/etc/fstab` e, em seguida, executa o primeiro programa, um utilitário chamado `init`. O programa `init` é responsável por executar todos os scripts de inicialização e daemons do sistema. Existem implementações distintas desses iniciadores de sistema além do tradicional `init`, como o `systemd` e o `Upstart`. Depois que o programa `init` é carregado, o `initramfs` é removido da RAM.

- `Padrão SysV`: Um gerenciador de serviços baseado no padrão SysVinit controla quais daemons e recursos estarão disponíveis empregando o conceito de **níveis de execução**. Os níveis de execução são numerados de `0` a `6` e são projetados pelos mantenedores da distribuição para atender a propósitos específicos. As únicas definições de nível de execução compartilhadas entre todas as distribuições são os níveis `0`, `1` e `6`.
- `systemd`: O systemd é um gerenciador de sistemas e serviços moderno, com uma camada de compatibilidade para os comandos e níveis de execução do `SysV`. O `systemd` possui uma estrutura concorrente, emprega sockets e D-Bus para a ativação de serviços, execução de daemon sob demanda, monitoramento de processos com `cgroups`, `snapshot support`, `recuperação da sessão do sistema`, `controle de ponto de montagem` e um `controle de serviços baseado em dependências`. Nos últimos anos, a maioria das grandes distribuições Linux adotou gradualmente o `systemd` como seu gerenciador de sistema padrão.
- `Upstart`: Como o `systemd`, o `Upstart` é um substituto para o `init`. O foco do `Upstart` é acelerar o processo de inicialização, paralelizando o processo de carregamento dos serviços do sistema. O `Upstart` foi usado pelas distribuições baseadas no Ubuntu em versões anteriores, mas hoje deu lugar ao `systemd`.

---

#### dmesg (print or control the kernel ring buffer)

Durante o processo de boot, não tem como pausar para ir vendo as informações do boot.

Para verificar o log de boot, use o comando `dmesg | less`. Lembrando que não haverá somente informações de boot, mas sim informações de tudo que for detectado, de forma geral, para o funcionamento/uso do sistema

>[!NOTE]
>
>O espaço de memória em que o kernel armazena suas mensagens, incluindo as mensagens de inicialização, é chamado de **buffer de anel do kernel** (*kernel ring buffer*)

>[!NOTE]
>
>O buffer de anel do kernel perde todas as mensagens quando o sistema é desligado ou se o comando `dmesg --clear` for executado

No início do log, é informado a versão do `kernel`, que é passado pelo `GRUB`:
```
[    0.000000] Linux version 6.8.0-51-generic (buildd@lcy02-amd64-091) (x86_64-linux-gnu-gcc-13 (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, GNU ld (GNU Binutils for Ubuntu) 2.42) #52-Ubuntu SMP PREEMPT_DYNAMIC Thu Dec  5 13:09:44 UTC 2024 (Ubuntu 6.8.0-51.52-generic 6.8.12)
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-6.8.0-51-generic root=UUID=ed75f0cb-cf1f-4598-a66a-8f3b39ba3588 ro quiet splash
```

>[!TIP]
>
>O log de inicialização tem centenas de linhas, portanto a saída do comando `dmesg` é frequentemente canalizada para um comando de paginação — como o comando `less` — para facilitar a leitura. Usando o comando `dmesg -H` ou `dmesg --human` faz automaticamente a paginação da saída, eliminando a necessidade de usar explicitamente um comando de paginação

---

#### Boot UEFI

- `UEFI`: abreviação de Unified Extensible Firmware Interface
- Especificação definida por um grupo de empresas
- Firmware que **substitui** a BIOS

A sequência (fluxo de boot) `UEFI` é: **UEFI** -> **Bootloader (GRUB)** -> **Kernel** -> **Init**

Tendo as seguintes atribuições:
- `UEFI`: Lê a partição `ESP` (*EFI System Partition*) e carrega o bootloader específico
- `bootloader` (`GRUB` é o mais comum): seleciona e executa o `kernel` e o `initrd`
- `Kernel`: executa o `/sbin/ini`
- `Init`: inicia os programas/serviços do `runlevel`/`target` definido

>[!WARNING]
>
>Principal diferença com `BIOS` é que `UEFI` **NÃO** tem `MBR`

As características do `UEFI` são:
- Não lê dados da MBR
- Obtêm os bootloaders pelo `ESP` (*EFI System Partition*)
    - montada no diretório `/boot/efi`
    - utiliza um filesystem do tipo geralmente `FAT32`
- utiliza (preferencialmente) partições `GPT` ao invés de `MBR`
- suporta partições além do limite de `2TB`
- implementa o Boot Seguro (boot por meio de um kernel assinado)
- possui modo de compatibilidade com a `BIOS`
- configurado pelo UEFI Boot Manager
    - no Linux por meio do comando `efibootmgr`

>[!NOTE]
>
>O padrão UEFI também suporta um recurso chamado *Inicialização Segura*, que permite apenas a execução de aplicativos EFI assinados, ou seja, aplicativos EFI autorizados pelo fabricante do hardware. Esse recurso aumenta a proteção contra software malicioso, mas pode dificultar a instalação de sistemas operacionais não cobertos pela garantia do fabricante.

---

#### journalctl (Print log entries from the systemd journal)

É uma parte do `systemd`, que é `/lib/systemd/systemd-journald`. Funciona parecido com `dmesg`, onde faz coleta de logs e informações do que está acontecendo no sistema (coleta informações do boot também)

- `journalctl -b` ou `--boot`: mostra informações do current (atual) boot
- `journalctl -k` ou `--dmesg`: mostra mensagens do kernel do current (atual) boot
- `journalctl -f` ou `--follow`: monitora os logs
- `journalctl --list-boots` ou `--follow`: mostra uma lista de números de inicialização relativos à inicialização atual, seu hash de identificação e os registros de data e hora da primeira e última mensagens correspondentes:
```
$ journalctl --list-boots
 -4 9e5b3eb4952845208b841ad4dbefa1a6 Thu 2019-10-03 13:39:23 -03—Thu 2019-10-03 13:40:30 -03
 -3 9e3d79955535430aa43baa17758f40fa Thu 2019-10-03 13:41:15 -03—Thu 2019-10-03 14:56:19 -03
 -2 17672d8851694e6c9bb102df7355452c Thu 2019-10-03 14:56:57 -03—Thu 2019-10-03 19:27:16 -03
 -1 55c0d9439bfb4e85a20a62776d0dbb4d Thu 2019-10-03 19:27:53 -03—Fri 2019-10-04 00:28:47 -03
  0 08fbbebd9f964a74b8a02bb27b200622 Fri 2019-10-04 00:31:01 -03—Fri 2019-10-04 10:17:01 -03
```

Os logs de inicialização anteriores também são preservados nos sistemas baseados no `systemd`, sendo assim possível inspecionar as mensagens de sessões anteriores do sistema operacional. Se as opções `-b 0` ou `--boot=0` forem usadas, aparecem as mensagens da inicialização atual. As opções `-b -1` ou `--boot=-1` exibem as mensagens da inicialização anterior. As opções `-b -2` ou `--boot=-2` exibem as mensagens da inicialização antes da anterior e assim por diante. O trecho a seguir mostra o kernel chamando o gerenciador de serviços do `systemd` para o último processo de inicialização
```
$ journalctl -b 0
oct 04 00:31:01 ubuntu-host kernel: EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
oct 04 00:31:01 ubuntu-host kernel: ip_tables: (C) 2000-2006 Netfilter Core Team
oct 04 00:31:01 ubuntu-host systemd[1]: systemd 237 running in system mode.
oct 04 00:31:01 ubuntu-host systemd[1]: Detected architecture x86-64.
oct 04 00:31:01 ubuntu-host systemd[1]: Set hostname to <torre>.
oct 04 00:31:01 ubuntu-host systemd[1]: Reached target User and Group Name Lookups.
```

As mensagens sobre a inicialização e outras emitidas pelo sistema operacional são armazenadas em arquivos dentro do diretório `/var/log/`. Se ocorrer um erro crítico e o sistema operacional for incapaz de continuar o processo de inicialização depois de carregar o `kernel` e o `initramfs`, uma mídia de inicialização alternativa pode ser usada para iniciar o sistema e acessar o arquivo de sistemas correspondente. Depois disso, os arquivos em `/var/log/` podem ser consultados em busca das razões causaram a interrupção do processo de inicialização. As opções `-D` ou `--directory` do comando `journalctl` servem para ler mensagens de log em diretórios diferentes de `/var/log/journal/`, que é a localização padrão para as mensagens de log do `systemd`. Como as mensagens de log do sistema não são armazenadas em texto puro, o comando `journalctl` é necessário para que fiquem legíveis.

Exemplo:

Um disco rígido contendo todo o sistema de arquivos de uma máquina offline foi removido e conectado a uma máquina operacional como drive secundário. Supondo que seu ponto de montagem seja `/mnt/hd`, como o `journalctl` seria usado para inspecionar o conteúdo dos arquivos de diário localizados em `/mnt/hd/var/log/journal/`?

**Resposta**: Com os comandos `journalctl -D /mnt/hd/var/log/journal` ou `journalctl --directory=/mnt/hd/var/log/journal`

---

### 101.3 Alterar níveis de execução/destinos de inicialização e desligar ou reiniciar o sistema

Principais `INITs` utilizados:
- `SystemV` (`SysV`): init original
- `systemd`: gerenciador de sistemas e serviços compatível com o `SysV` (mais utilizado)
- `Upstart`: gerenciador de serviços substituro ao `init`, mas com opções de compatibilidade

---

#### SystemV (SysV) - INIT


- trabalha com `RunLevel` (nível de execução do sistema)
- cada `runlevel` carrega um conjunto de programas, scripts e serviços
- cfg principal fica em: `/etc/inittab`
- Diretórios de scripts: 
    - `/etc/init.d/`
    - `/etc/rc.d/`

São **7** `runleves`:
- `0` desligamento
- `1`,`s`,`S` - Single user

6 - Reinicialização

*em todas as distros esses runlevels são sempre os mesmos!

*O gerenciador de serviços é o primeiro programa lançado pelo kernel durante o processo de inicialização, portanto seu PID (número de identificação do processo) é sempre 1


| **ID**  | **Descrição**  |
|---|---|
| `0`* | Desligamento  |
| `1`,`s`,`S`* | Single user / Usuário único  |
| `2` | Multiusuário (sem rede) |
| `3` | Multiusuário (com rede) |
| `4` | Multiusuário (definido pelo usuário) |
| `5` | Multiusuário (com rede e gráfico) |
| `6`* | Reinicialização |
*sempre serão o mesmo modo, independente da distribuição

Portanto é importante gravar que os modos `0`, `1` e `6` serão respectivamente modos de `desligamento`, `single user` e `reinicialização`

Já os demais modos, `2` ao `5`, variam de distribuição para distribuição.

Nos sistemas mais novos, é normal **não** vir mais com o `init`. Por padrão, o `init` fica em `/etc/initab`:

Exemplo do arquivo `inittab` (criado manualmente, com o básico):
```
# Default runlevel
id:3:initdefault:

# Configuration script executed during boot
si::sysinit:/etc/init.d/rcS

# Action taken on runlevel S (single user)
~:S:wait:/sbin/sulogin

# Configuration for each execution level
l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6

# Action taken upon ctrl+alt+del keystroke
ca::ctrlaltdel:/sbin/shutdown -r now

# Enable consoles for runlevels 2 and 3
1:23:respawn:/sbin/getty tty1 VC linux
2:23:respawn:/sbin/getty tty2 VC linux
3:23:respawn:/sbin/getty tty3 VC linux
4:23:respawn:/sbin/getty tty4 VC linux

# For runlevel 3, also enable serial
# terminals ttyS0 and ttyS1 (modem) consoles
S0:3:respawn:/sbin/getty -L 9600 ttyS0 vt320
S1:3:respawn:/sbin/mgetty -x0 -D ttyS1
```

No exemplo acima, temos que o `initdefault` é o `runlevel` `default`, e no caso é o runlevel `2`.

>[!NOTE]
>
>O comando `telinit q` deve ser executado a cada vez que o arquivo `/etc/inittab` é modificado. O argumento `q` (ou `Q`) pede que o init recarregue sua configuração. Essa etapa é importante para evitar uma parada do sistema devido a uma configuração incorreta em `/etc/inittab`

Resumidamente o fomato é: `id:runlevels:action:process`, e separado por dois pontos temos:
- `id`: é um nome genérico de até quatro caracteres usado para identificar a entrada. O item `runlevels` é uma lista de números dos níveis de execução nos quais uma ação especificada deve ser executada. O termo `action` define como `init` executará o processo indicado pelo termo `process`. As ações disponíveis são:
    - `boot`: O processo será executado durante a inicialização do sistema. O campo `runlevels` é ignorado.
    - `bootwait`: O processo será executado durante a inicialização do sistema e o `init` aguardará sua conclusão para continuar. O campo `runlevels` é ignorado.
    - `sysinit`: O processo será executado após a inicialização do sistema, qualquer que seja o nível de execução. O campo `runlevels` é ignorado.
    - `wait`: O processo será executado nos níveis de execução dados e `init` aguardará sua conclusão para continuar.
    - `respawn`: O processo será reiniciado caso seja encerrado.
    - `ctrlaltdel`: O processo será executado quando o processo `init` receber o sinal `SIGINT`, disparado quando o atalho de teclado `Ctrl`+`Alt`+`Del` for pressionado.

Já em `/etc/init.d` é onde ficam os arquivos/scripts dos serviços. Por exemplo, dentro dele tem um arquivo/script do `cron`, que podemos executar: `./cron status`, mostrando o status do `cron`, assim como dar start no cron, ou parar, sendo respectivamente: `./cron stop` e `./cron start`

Os diretórios dos runleves podem ser vistos com o comando `ls -ld /etc/rc*`
```
ls -ld /etc/rc*
drwxr-xr-x 2 root root 4096 Jan 22 14:51 /etc/rc0.d
drwxr-xr-x 2 root root 4096 Jan 22 14:51 /etc/rc1.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc2.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc3.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc4.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc5.d
drwxr-xr-x 2 root root 4096 Jan 22 14:51 /etc/rc6.d
drwxr-xr-x 2 root root 4096 Jan 15 08:15 /etc/rcS.d
```

Essa estrutura é mantida a título de compatibilidade (com o `systemd`, por exemplo)

Se pegarmos um diretório, como por exemplo o `/etc/rc5.d`, podemos notar que é composto por uma lista de links, que são serviços que o linux deve iniciar (representado por `S` - *start* - no início do nome arquivo/link) ou finalizar (representado por `K` - *kill* - no início do nome do arquivo/link)

`/etc/rc5.d`
```
ls -l /etc/rc5.d/
total 0
lrwxrwxrwx 1 root root 29 Jan 14 15:59 K01apache-htcacheclean -> ../init.d/apache-htcacheclean
lrwxrwxrwx 1 root root 27 Nov  8 16:17 K01speech-dispatcher -> ../init.d/speech-dispatcher
lrwxrwxrwx 1 root root 19 Jan 22 14:51 K01tftpd-hpa -> ../init.d/tftpd-hpa
lrwxrwxrwx 1 root root 17 Nov  8 16:17 S01anacron -> ../init.d/anacron
lrwxrwxrwx 1 root root 17 Jan 14 15:59 S01apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 13 Nov 14 11:53 S01atd -> ../init.d/atd
lrwxrwxrwx 1 root root 14 Jan 14 11:46 S01atop -> ../init.d/atop
lrwxrwxrwx 1 root root 18 Jan 14 11:46 S01atopacct -> ../init.d/atopacct
#lista ocultada
```

`/etc/rc0.d` (desligamento, comum dar `kill`)
```
ls -l /etc/rc0.d/
total 0
lrwxrwxrwx 1 root root 20 Nov  8 16:17 K01alsa-utils -> ../init.d/alsa-utils
lrwxrwxrwx 1 root root 17 Jan 14 15:59 K01apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 29 Jan 14 15:59 K01apache-htcacheclean -> ../init.d/apache-htcacheclean
lrwxrwxrwx 1 root root 13 Nov 14 11:53 K01atd -> ../init.d/atd
lrwxrwxrwx 1 root root 14 Jan 14 11:46 K01atop -> ../init.d/atop
lrwxrwxrwx 1 root root 18 Jan 14 11:46 K01atopacct -> ../init.d/atopacct
lrwxrwxrwx 1 root root 19 Nov  8 16:17 K01bluetooth -> ../init.d/bluetooth
#lista ocultada
```

---

#### comandos usados para runlevel

- `runlevel` (comando usado no `SysV` e no `init`): mostra o runlevel **anterior** e o **atual**. O `N` mostra que o nível de execução não mudou desde a última inicialização.
```
$ runlevel
N 5
```

Já se necessitar mudar o runlevel, é necessário usar o comando:

- `init` ou `telinit`: para mudanças de runlevel (ambos 
fazem parte do `SysV`)
- `init 0`: desliga o computador (runlevel `0`)
- `init 1` ou `init s` ou `init S`: entra no runlevel de single `mode/user`
- `telinit 1` ou `telinit s` ou `telinit S`: entra no runlevel de single `mode/user`
- `telinit 2`: entra no runlevel `2`
- `init 6`: entra no runlevel `6` (reinicialização - reinicia o computador)

---

#### mais sobre telinit

Usando `telinit --help` abriamos mais informações sobre o `telinit`:
```
$ telinit --help
telinit [OPTIONS...] COMMAND

Send control commands to the init daemon.

Commands:
  0              Power-off the machine
  6              Reboot the machine
  2, 3, 4, 5     Start runlevelX.target unit
  1, s, S        Enter rescue mode
  q, Q           Reload init daemon configuration
  u, U           Reexecute init daemon

Options:
     --help      Show this help
     --no-wall   Don't send wall message before halt/power-off/reboot

See the telinit(8) man page for details.
```
Uma opção interessante é a opção `q` ou `Q`, que recarrega o daemon de configuração (`/etc/inittab`). Equivalente a `systemctl daemon-reload`

Há também a opção `u` ou `U` para reexecutar o o daemon. Equivalente a `systemctl daemon-reexec`

---

<a id="systemd"></a>
#### systemd

- `systemd` é uma outra forma de gerenciar os runLevels, mais eficiente que o `SysV` com diversas melhorias (é compatível com `sysv`)
- melhorias como paralelização, uso do `dbus`, entre outros
- conceito de `Units` (não ideia de `runLevel`), e grupos de `units`, que é igual a um `target`
- `unidade` = `Nome.Tipo` (Ex. `httpd.service`, que é igual a uma unidade)

Tendo os tipos:
- `service`: O tipo de unidade mais comum, para recursos ativos do sistema que podem ser iniciados, interrompidos e recarregados.
- `socket`: O tipo de unidade socket pode ser um socket de sistema de arquivos ou um socket de rede. Todas as unidades socket possuem uma unidade de serviço correspondente, carregada quando o socket recebe uma solicitação.
- `device`: Uma unidade de dispositivo está associada a um dispositivo de hardware identificado pelo kernel. Um dispositivo só será considerado como uma unidade `systemd` se existir uma regra `udev` para isso. Uma unidade de dispositivo pode ser usada para resolver dependências de configuração quando determinado hardware é detectado, uma vez que as propriedades da regra `udev` podem ser usadas como parâmetros para a unidade de dispositivo.
- `mount`: Uma unidade de montagem é uma definição de ponto de montagem no sistema de arquivos, semelhante a uma entrada em `/etc/fstab`.
- `automount`: Uma unidade de montagem automática também é uma definição de ponto de montagem no sistema de arquivos, mas nesse caso montada automaticamente. Cada unidade de montagem automática possui uma unidade de montagem correspondente, que é iniciada quando o ponto de montagem automática é acessado.
- `target` que é equivalente a `runlevel` (o `systemd` tem um target default - uma unidade de destino é um agrupamento de outras unidades, gerenciadas como uma única unidade)
- `snapshot`: Uma unidade snapshot é um estado salvo do gerenciador do systemd (não disponível em todas as distribuições Linux).

O diretório principal de configuração do `systemd` é `/lib/systemd/system` (onde ficam os arquivos de configuração dos serviços)

- `ls -ld /lib/systemd/system/*.target`: lista os grupos de execução.

Há links para manter a compatibilidade:
```
$ ls -ld /lib/systemd/system/*[0-9].target
lrwxrwxrwx 1 root root 15 Aug  8 11:51 /lib/systemd/system/runlevel0.target -> poweroff.target
lrwxrwxrwx 1 root root 13 Aug  8 11:51 /lib/systemd/system/runlevel1.target -> rescue.target
lrwxrwxrwx 1 root root 17 Aug  8 11:51 /lib/systemd/system/runlevel2.target -> multi-user.target
lrwxrwxrwx 1 root root 17 Aug  8 11:51 /lib/systemd/system/runlevel3.target -> multi-user.target
lrwxrwxrwx 1 root root 17 Aug  8 11:51 /lib/systemd/system/runlevel4.target -> multi-user.target
lrwxrwxrwx 1 root root 16 Aug  8 11:51 /lib/systemd/system/runlevel5.target -> graphical.target
lrwxrwxrwx 1 root root 13 Aug  8 11:51 /lib/systemd/system/runlevel6.target -> reboot.target
```

Assim como o `default.target`:
```
$ ls -ld /lib/systemd/system/default.target
lrwxrwxrwx 1 root root 16 Aug  8 11:51 /lib/systemd/system/default.target -> graphical.target
```

Há também o arquivo de configuração que fica em `/etc/systemd`, que possuir alguns arquivos e diretórios referentes à configuração do `systemd` (o `/lib/systemd/system/` ainda é mais importante)


Bom reforçar que o `init`, que fica em `/sbin/init`, aponta para `/lib/systemd/systemd` (a depender da distribuição, óbvio), por isso tanto `systemd` como `init` funcionam.
```
$ ps axu |grep /sbin/init
root           1  0.0  0.0  23164 11772 ?        Ss   Jan10   0:26 /sbin/init splash
rodrigo   720845  0.0  0.0   9280  2176 pts/0    S+   19:15   0:00 grep --color=auto /sbin/init

$ ls -l /sbin/init 
lrwxrwxrwx 1 root root 22 Aug  8 11:51 /sbin/init -> ../lib/systemd/systemd
```

Quando usa os comandos `init` e `telinit`, na realidade está usando via `systemd`, devido aos links internos. O comando nativo do `systemd` é o `systemctl` (`systemctl --help`)

>[!NOTE]
>
>Se for visto em perguntas comandos `systemctl`, esse tem a ver com o `systemd` (lembrar disso).

- `systemctl reboot`: reinicia o computador
- `systemctl poweroff`: desliga o computador

Algumas distribuições Linux vinculam `poweroff` e `reboot` a `systemctl` como comandos individuais. Por exemplo:
```
$ sudo which poweroff
/usr/sbin/poweroff

$ sudo ls -l /usr/sbin/poweroff
lrwxrwxrwx 1 root root 14 Aug 20 07:50 /usr/sbin/poweroff -> /bin/systemctl
```

Quando desligar/reiniciar o servidor, é possível enviar mensagem utilizando o comando [wall](#wall).


- `systemctl set-defaul multi-user.target`: muda o target default (na prática atualiza o link que aponta para o `default.target`)
- `systemctl isolate rescue.target`: mudar de target no `systemd`, no caso muda para o equivalente ao `runlevel1` (`rescue.target`), ou poderia ser `systemctl isolate runlevel1.target`(considera o link)
- `systemctl default`: inicia o `default.target`

>[!WARNING]
>
>Como nos sistemas que adotam o `SysV`, o destino padrão **nunca** deve apontar para `shutdown.target`, pois ele corresponde ao nível de execução `0` (encerramento).

- `systemctl start unit.service`: Inicia unit.
- `systemctl stop unit.service`: Interrompe unit.
- `systemctl restart unit.service`: Reinicia unit.
- `systemctl status unit.service`: Mostra o estado de unit, incluindo se está ou não em execução.
- `systemctl is-active unit.service`: Exibe active se unit estiver rodando, ou inactive se não estiver.
- `systemctl enable unit.service`: Habilita unit, ou seja, unit será carregado durante a inicialização do sistema.
- `systemctl disable unit.service`: unit não será iniciado com o sistema.
- `systemctl is-enabled unit.service`: Verifica se `unit` é iniciado com o sistema. A resposta é armazenada na variável `$?`. O valor `0` indica que unit inicia com o sistema e o valor `1` indica que não: `echo $?`

>[!NOTE]
>
>Se não houver outras unidades com o mesmo nome no sistema, o sufixo após o ponto poderá ser descartado. Se, por exemplo, houver apenas uma unidade `httpd` do tipo `service`, somente `httpd` bastará como parâmetro de unidade para `systemctl`.

O comando `systemctl list-unit-files` lista todas as unidades disponíveis e mostra se elas estão habilitadas para iniciar quando o sistema é inicializado. A opção `--type` seleciona apenas as unidades para um tipo determinado, como em `systemctl list-unit-files --type=service` e `systemctl list-unit-files --type=target`

O `systemd` também é responsável por acionar e responder a eventos relacionados ao **consumo de energia**. 

O comando `systemctl suspend` coloca o sistema no modo de baixo consumo de energia, mantendo os dados atuais na memória. 

O comando `systemctl hibernate` copia todos os dados da memória no disco, para que o estado atual do sistema possa ser recuperado após o desligamento. 

As ações associadas a esses eventos são definidas no arquivo `/etc/systemd/logind.conf` ou em arquivos separados dentro do diretório `/etc/systemd/logind.conf.d/`. No entanto, esse recurso do `systemd` pode ser usado apenas quando não houver outro gerenciador de energia em execução no sistema, como o daemon `acpid`. O daemon `acpid` é o principal gerenciador de energia do Linux e permite ajustes mais refinados das ações após eventos relacionados ao consumo de energia, como fechar a tampa do laptop, bateria fraca ou níveis de carga da bateria.

#### Exercício interessante de systemd

1. Como se verifica o destino padrão do sistema em um sistema baseado em `systemd`?

**Resposta**:O link simbólico `/etc/systemd/system/default.target` aponta para o arquivo da unidade definido como destino padrão. Também é possível usar o comando `systemctl get-default`.

2. Identifique se a sua instalação Linux está utilizando `SysV`, `systemd` ou `upstart`

**Resposta**: por meio dos comandos:
```
$ ps -p 1
    PID TTY          TIME CMD
      1 ?        00:00:30 systemd
```
ou
```
$ sudo stat /proc/1/exe       
  File: /proc/1/exe -> /usr/lib/systemd/systemd
  Size: 0         	Blocks: 0          IO Block: 1024   symbolic link
Device: 0,24	Inode: 7309287     Links: 1
Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2025-01-28 21:01:43.802204580 -0300
Modify: 2025-01-17 19:33:43.810326627 -0300
Change: 2025-01-17 19:33:43.810326627 -0300
 Birth: -
```

3.  Identifique o `runlevel` ou `target` padrão em seu sistema de inicialização `SysV` ou `systemd`

**Resposta**: com os comandos:
```
$ ls -lh /lib/systemd/system/default.target 
lrwxrwxrwx 1 root root 16 Aug  8 11:51 /lib/systemd/system/default.target -> graphical.target
```
ou
```
$ systemctl get-default 
graphical.target
```

---

#### upstart

- `upstart` veio para substituir o `init` (`sysV`)
- mantém compatibilidade
- configuração fica em `/etc/init/`


Principais comandos:
- `initctl list`: lista os serviços do sistema
- `start serviço`: iniciar serviço
- `stop serviço`: para serviço
- `status serviço`: mostra status do serviço

Cada uma das ações do `Upstart` tem seu próprio comando independente. Por exemplo, o comando start pode ser usado para iniciar um sexto terminal virtual:
```
# start tty6
```
O estado atual de um recurso pode ser verificado com o comando `status`:
```
# status tty6
tty6 start/running, process 3282
```
E a interrupção de um serviço é feita com o comando `stop`:
```
# stop tty6
```
O Upstart **não** usa o arquivo `/etc/inittab` para definir os níveis de execução, mas os comandos legados `runlevel` e `telinit` ainda podem ser usados para verificar e alternar entre níveis de execução.

>[!TIP]
>
>Ao ver o `initctl` em alguma perguntar, **ASSOCIAR** ao `upstart`.

Lembrar:

- `systemctl` -> `systemd`
- `initctl` -> `upstart`

>[!NOTE]
>
>O Upstart foi desenvolvido para a distribuição Ubuntu Linux para facilitar a inicialização paralela dos processos. O Ubuntu parou de usar o `Upstart` em 2015, quando migrou do `Upstart` para o `systemd`

---

#### shutdown, reboot, poweroff, halt

Em vez de usar `init0` ou `telinit0` para desligar o computador, o ideal é usar o `shutdown`, pois esse, por exemplo, emite um aviso para os usuário conectados que o computador será desligado/reiniciado. O `shutdown` ainda **impede** novos logins. 

>[!NOTE]
>
>`shutdown` também serve para reiniciar! `shutdown -r` ou `reboot`

O `shutdown` emite **dois** sinais para os processos, primeiro o `SIGTERM`, que seria um "matar" de forma soft (`ID 15`), e depois recebe um sinal de `kill` (`SIGKILL` ou `ID 9`) mesmo, para matar definitivamente, encerrando ou mudando seu nível de execução (veja mais sobre `kill` e `SIG` [aqui](#kill)). Por padrão, quando as opções `-h` ou `-r` não são usadas, o sistema alterna para o nível de execução `1`, ou seja, o modo de `usuário único` (`single user`).

---

#### Principais comandos shutdown:

- `shutdown` (somente shutdown): desliga o computador em **1** minuto
- `shutdown -c`: cancela o comando de desligar
    - **sempre** informando aos outros usuários conectados!
- `shutdown -r` ou `--reboot`: reinicia o sistema 
- `shutdown -H` ou `--halt`: desliga o sistema Linux (mantem fonte ligada).
- `shutdown -P` ou `--poweroff`:desliga o sistema e a fonte de energia (depende do hardware que está usando).
- `shutdown -h`: mesmo que `--poweroff`, mas não sobrescreve a ação tomada se for `halt`
- `shutdown -p: (`--poweroff`): desliga o computador.
`--no-wall` (não envia mensagem antes de reiniciar)
- `shutdown -r +10`: agenda o restart daqui 10 minutos.
- `shutdown 18:00`: programa o desligamento às 18 horas

O formato do shutdown para desligamento programado é `shutdown [option] time [message]`

Somente o parâmetro `time` é obrigatório. Esse parâmetro define quando a ação solicitada será executada, aceitando os seguintes formatos:
- `hh:mm`: Este formato especifica o tempo de execução em horas e minutos.
- `+m`: Este formato especifica quantos minutos esperar antes da execução.
- `now` ou `+0`: Este formato determina a execução imediata.

O parâmetro `message` é o texto de aviso enviado a todas as sessões de terminal dos usuários logados.

A implementação do `SysV` permite limitar os usuários que poderão reiniciar a máquina pressionando `Ctrl`+`Alt`+`Del`. Para isso, incluímos a opção `-a` no comando `shutdown` presente na linha referente a `ctrlaltdel` no arquivo `/etc/inittab`. Ao fazer isso, somente usuários cujos nomes de usuário constem do arquivo `/etc/shutdown.allow` poderão reiniciar o sistema com o atalho de teclado `Ctrl`+`Alt`+`Del`.

Como já visto em [systemd](#systemd), o comando `systemctl` também pode ser usado para desligar ou reiniciar a máquina em sistemas que empregam o `systemd`.
- `systemctl reboot`: reiniciar o sistema
- `systemctl poweroff`: desligar o sistema (ambos os comandos requerem privilégios de root para serem executados, pois usuários comuns não podem realizar esses procedimentos)

>[!NOTE]
>
>Algumas distribuições Linux vinculam `poweroff` e `reboot` a `systemctl` como comandos individuais. Por exemplo:
```
$ sudo which poweroff
/usr/sbin/poweroff
$ sudo ls -l /usr/sbin/poweroff
lrwxrwxrwx 1 root root 14 Aug 20 07:50 /usr/sbin/poweroff -> /bin/systemctl
```

>[!TIP]
>
>Nem todas as atividades de manutenção exigem que o sistema seja desligado ou reiniciado. No entanto, quando é necessário alterar o estado do sistema para o modo de usuário único, é importante avisar os usuários conectados para que não sejam prejudicados pelo encerramento abrupto de suas atividades.

>[!TIP]
>
>Como no caso do comando `shutdown` ao desligar ou reiniciar o sistema, o comando `wall` pode enviar uma mensagem para as sessões de terminal de todos os usuários logados. Para isso, o administrador do sistema só precisa fornecer um arquivo ou escrever diretamente a mensagem como um parâmetro para o comando `wall`.

---

#### Outros comandos similares ao shutdown:

- `reboot`: reiniciar
- `halt`: desliga o linux (mantendo a fonte)
- `poweroff`: desliga o linux e a máquina

<a id="wall"></a>
#### comando wall:

Manda mensagem para todos os users do sistema: 
```
`wall "Vamos tomar uma café"`
```
Dispara a mensagem para todos os usuários do sistema.

---

#### acpid

`ACPI` - *Advanced Configuration and Power Interface*: é uma especificação do mercado de hardware, para tratar de itens referentes à energia do computador ou hardwares, como baterias, voltagem/tensão, rotação do cooler, temperatura, tudo voltado à energia do hardware. (`acpid` é o daemon, mas o serviço chama-se `acpid`)

Quem comando isso no Linux é o processo `acpid`. Veja ele em `ps axu | grep acpi` (`/usr/sbin/acpid`)

- `acpi`: mostra o básico
```
$ acpi
Battery 0: Discharging, 0%, rate information unavailable
```
- `acpi -V`: mostra todas as informações
```
$ acpi -V
Battery 0: Discharging, 0%, rate information unavailable
Thermal 0: ok, 27.8 degrees C
Thermal 0: trip point 0 switches to mode critical at temperature 119.0 degrees C
Thermal 0: trip point 1 switches to mode active at temperature 71.0 degrees C
Thermal 0: trip point 2 switches to mode active at temperature 55.0 degrees C
Thermal 0: trip point 3 switches to mode active at temperature 50.0 degrees C
Thermal 0: trip point 4 switches to mode active at temperature 45.0 degrees C
Cooling 0: Fan 0 of 1
Cooling 1: Processor 0 of 3
Cooling 2: Processor 0 of 3
Cooling 3: dell-smm-fan1 3 of 2
Cooling 4: Processor 0 of 3
Cooling 5: TCC Offset 0 of 63
Cooling 6: Processor 0 of 3
Cooling 7: Processor 0 of 3
Cooling 8: Fan 0 of 1
Cooling 9: x86_pkg_temp no state information available
Cooling 10: Processor 0 of 3
Cooling 11: Fan 0 of 1
Cooling 12: Processor 0 of 3
Cooling 13: Fan 0 of 1
Cooling 14: Processor 0 of 3
Cooling 15: Processor 0 of 3
Cooling 16: intel_powerclamp 0 of 100
Cooling 17: Processor 0 of 3
Cooling 18: Processor 0 of 3
Cooling 19: Fan 0 of 1
Cooling 20: Processor 0 of 3
```

- `whatis acpi`: Advanced Configuration and Power Interface event daemon: monitora o gerenciamento de energia do computador. Se a temperatura subir absurdamente, ele pode dar um `shutdown` no computador, por exemplo.

---

## Tópico 102: 102 Instalação do Linux e gerenciamento de pacotes
### 102.1 Definir o esquema de partições do disco rígido

---

#### Conceitos: Partição, Ponto de Montagem, FS MBR

`sda1`, `sda2`, etc são as **PARTIÇÕES** de um disco (disco `sda`, por exemplo). 

`/var`, `/home` são **PONTOS DE MONTAGEM** de uma determinada partição. Logo, o correto é dizer que a partição `sda1` está **associada** ao ponto de montagem `/`, por exemplo. Ou a partição `sda2` está associada ao ponto de montagem `/var`, e assim por diante.

- `sda1`: partição
- `/boot`: ponto de montagem de alguma partição (poderia ser de `sda1`, por exemplo). É comum dizer partição `/boot`, mas o correto é dizer ponto de montagem

- Vantagens:
- **GERENCIAMENTO DO ESPAÇO EM DISCO**:
    - Uma das vantagens do uso de partições é evitar que, por exemplo, um usuário ocupe todo o tamanho do disco com um arquivo, fazendo assim com que as aplicações, ou outros usuários, não consigam mais trabalhar no sistema. Ou como um arquivo de log ocupar todo espaço. Separando o disco em partições, se um usuário esgotar a capacidade de sua partição, ou um log que cresceu demais, acabar também esgotando todo o espaço, isso não influenciará nas demais aplicações (devido à separação do disco em partições).
- **DIFERENTES TIPOS DE FILESYSTEM PARA CADA PARTIÇÃO**:
    - Há filesystems que são mais otimizados ou tem maior performance para trabalhar com arquivos maiores, ou uma quantidade grande de arquivos menores e etc. Dependendo do uso da partição, podemos associar um tipo específico de filesystem.
- **PROTEÇÃO CONTRA ERROS DO DISCO**:
    - Caso um disco venha apresentar falha física (em um setor/cilindro, por exemplo), e estiver com uma partição apenas, isso vai acabar comprometendo o funcionamento de todo o disco. Se tivermos um problema em uma partição, apenas ela poderá ser impactada (dependendo do erro de disco).
- **DIFERENTES NÍVEIS DE SEGURANÇA**:
    - Podemos, por exemplo, deixar a partição `sda3` que está associada ao ponto de montagem `/usr` como somente leitura (`ro`)
- **BACKUP FACILITADO**:
    - Imagine o `/home` associado a uma partição. Isso facilita muito aos programas de backup, pois teríamos que apenas apontar para aquele ponto de montagem, que está em uma partição.


---

#### Sistemas de Particionamento (MBR e GPT)

São modelos e formas de fazer o particionamento do disco

- `MBR`: *Master Boot Record*: padrão, mas é limitado a **2TB** por partição.

- `GPT`: *GUID Partition Table*:  utilizado quando são necessárias partições **maiores de 2TB** (maioria dos sistemas com `EFI` utilizam `GPT`)

>[!NOTE]
>
>Para a LPI, o que mais cai é `MBR`

---

#### PARTIÇÕES MBR

Originalmente era limitada a `4` partições **PRIMÁRIAS**, ou seja, `1` disco poderia ter no **máximo** `4` partições. 

Para superar esse limite podemos criar uma partição **ESTENDIDA** (extended partition) no lugar de uma **PRIMÁRIA**, e ir adicionando partições **LÓGICAS** dentro da partição **ESTENDIDA**, quantas forem necessárias.

Portanto podemos ter:

- `4` **partições PRIMÁRIAS** ou
- `3` **partições PRIMÁRIAS** e `1` **partição LÓGICA**.

>[!WARNING]
>
>**NÃO** faz sentido criar mais do que **UMA** partição **ESTENDIDA**!

---

#### GPT

Os discos particionados em GPT podem ser usados em computadores com a BIOS tradicional do PC ou com o firmware UEFI. Em máquinas com BIOS, a segunda parte do GRUB é armazenada em uma partição especial de inicialização da BIOS

Em sistemas com firmware UEFI, o GRUB é carregado pelo firmware a partir dos arquivos `grubia32.efi` (para sistemas de 32 bits) ou `grubx64.efi` (para sistemas de 64 bits) em uma partição chamada `ESP` (*EFI System Partition*)

#### NUMERAÇÃO DAS PARTIÇÕES

- `Primárias`: vão de `1` a `4`. Exemplo: `sda1`, `sda2`, `sda4` (podemos ter uma lacuna, do `2` vai para o `4`)

- `Lógicas`: vão a partir de `5`. Exemplo: `sda5`, `sda6`, `sda7` (**não** podemos ter lacunas, **tem que ser sequencial**)

---

#### Partições no Linux

- `/`: é a primeira partição montada pelo kernel
- ao menos `2` partições devem ser criadas: `/` e `swap` (como o sistema nunca pode ficar sem espaço na memória RAM - volátil - para evitar o travamento do sistema, uma alternativa é o uso da área de `swap`, um espaço no HD caso a RAM fiquem sem espaço, operando como se fosse a RAM)

>[!NOTE]
>
>A recomendação para o tamanho da `swap` é que ela seja 2x maior que o tamanho da memória RAM

---

#### Código dos tipos de partição:

- `0x83` = Linux FileSystem
- `0x82` = Linux swap

---

#### Principais partições no Linux (recomendado instalar em partições distintas)

- `/home`: dados dos usuário, para que os dados não impactem no funcionamento do sistema (outra grande vantagem de separar `/home` é que quando precisar reinstalar outro sistema para testes, não vai perder os dados que estão nessa partição)
- `/var`: diretórios temporários de fila, que tendem a crescer e ocupar muito espaço em disco
- `/tmp`: semelhante ao `/var` (arquivos de `lock` e temporários)
- `/boot`: arquivos do `kernel`, `initrd`, carregados pelo GRUB (antigamente havia uma limitação com o LILO que esses arquivos deveriam estar no limite do cilindro `1024`, por isso era comum criar o `/boot`, o GRUB hoje em dia já consegue acessar os dados mesmo que estejam após o limite de `1024`)
- `/usr`: muitos arquivos de aplicação, que são instalados. Evita que erros em outras partições impliquem no funcionamento dos aplicativos instalados.

>[!WARNING]
>
>Para garantir uma compatibilidade máxima, a partição `/boot` geralmente está localizada no início do disco e termina antes do cilindro `1024` (`528 MB`), garantindo que a máquina sempre possa carregar o kernel. O tamanho recomendado para essa partição em uma máquina atual é de `300 MB`

>[!WARNING]
>
>Outras razões para uma partição `/boot` separada são a criptografia e a compactação, já que alguns métodos ainda não são suportados pelo GRUB 2, ou ainda se a partição raiz do sistema (`/`) precisar ser formatada usando um sistema de arquivos não suportado.

---

#### Diretórios que NÃO podem estar montados fora do `/`

- `/etc`: arquivos de configurações e dados que precisam para montar outras partições (exemplo, `/etc/fstab` - se estiver em outra partição, não vai ter acesso às outras partições)
- `/bin`: comandos, scripts, programas utilizados no linux
- `/sbin`: comandos, scripts, programas utilizados no linux
- `/dev`: diretório dinâmico
- `/proc`: diretório dinâmico
- `/sys`: diretório dinâmico

---

#### Conceito LVM, Demonstração Prática


`LVM` - *Logical Volume Management*

- método para alocar espaço dos discos em volumes lógicos, que facilita o redimensionamento.

Elementos:

- `VG`: Volume Group
- `PB`: Phisical Volume
- `LV`: Logical Volume
- `PE`: Physical Extent
- `LE`: Logical Extent

---

#### listando os discos/partições/pontos de montagem

- `df -h`: lista as partições e pontos de montagens criados
```
$ df -h
Filesystem              Size  Used Avail Use% Mounted on
tmpfs                   1,6G  2,3M  1,6G   1% /run
efivarfs                384K  114K  266K  30% /sys/firmware/efi/efivars
/dev/nvme0n1p4          181G   13G  159G   8% /
tmpfs                   7,7G  252M  7,5G   4% /dev/shm
tmpfs                   5,0M  8,0K  5,0M   1% /run/lock
tmpfs                   7,7G     0  7,7G   0% /run/qemu
/dev/nvme0n1p2          441M  380M   27M  94% /boot
/dev/nvme0n1p3          272G   74G  185G  29% /home
/dev/nvme0n1p1          487M  6,2M  480M   2% /boot/efi
tmpfs                   1,6G  2,6M  1,6G   1% /run/user/1000
/home/rodrigo/.Private  272G   74G  185G  29% /home/rodrigo
```
>[!NOTE]
>
> repare que não mostra a partição de swap, use `cat /proc/swaps` para vê-la
```
$ cat /proc/swaps 
Filename				Type		Size		Used		Priority
/dev/nvme0n1p5                          partition	15999996	4473856		-2         
```

- `fdisk -l`: lista as partições (`fdisk` precisa ser executado como `root`)

>[!NOTE]
>
>`fdisk` é muito utilizado para criar/alterar/excluir partições no sistema. Mais detalhes [aqui](#fdisk)

---

#### UEFI e ESP

Em sistemas com hardware mais modernos, que utilizam `UEFI`, podemos ver com o comando `df -T` ou `--print-type` que temos um ponto de montagem chamado `/boot/efi`

Acessando esse diretório, notamos que se trata do gerenciamento do `EFI`, e se tiver um `dualboot` instalado, ele irá aparecer aqui os sistemas instalados em `dualboot`.
```
# ls -l /boot/efi/EFI
total 3
drwx------ 2 root root 1024 Jan 1 2024 Boot
drwx------ 4 root root 1024 Jan 1 2024 Microsoft
drwx------ 2 root root 1024 Jan 1 2024 ubuntu
```

Com o comando `efibootmgr`, é listado as configurações atuais do `EFI`, assim como o boot padrão (`BootCurrent`), e também a ordem de boot (`BootOrder`). O comando `efibootmge -v` traz ainda mais detalhes.
```
# efibootmgr
BootCurrent: 0000
Timeout: 0 seconds
BootOrder: 0000,0001
Boot0000* ubuntu
Boot0001* Windows Boot Manager
```

```
# efibootmgr  -v
BootCurrent: 0000
Timeout: 0 seconds
BootOrder: 0000,0001
Boot0000* ubuntu HD(1,GPT,e0e24ace-2852-45f3-a0b7-e7a3669978f9,0x800,0x32000)/File(\EFI\ubuntu\shimx64.efi)
Boot0001* Windows Boot Manager HD(1,GPT,e0e24ace-2852-45f3-a0b7-e7a3669978f9,0x800,0x32000)/File(\EFI\Microsoft\Boot\bootmgfw.efi)WINDOWS.........x...B.C.D.O.B.J.E.C.T.=.{.9.d.e.a.8.6.2.c.-.5.c.d.d.-.4.e.7.0.-.a.c.c.1.-.f.3.2.b.3.4.4.d.4.7.9.5.}...0................
```

Ainda com o `fdisk -l` ou `--list` (como `root`), é mostrado o `Disklabel type`, que pode ser `dos` (`mbr`) ou `gpt`

---

## Tópico 103: Comandos GNU e UNIX
### 103.1 Trabalhar na linha de comando
---
#### shell, bash, echo, type, PATH

Shell é a interface entre o usuário e o Linux. Shell também é um ambiente de programação (scripts)

Há diversos tipos de shell, como bash (o que é coberto no exame). Tem também o `csh`, `ksh` e etc (tem muitas diferencias na hora de programar scripts, para uso comum não muda muito, é bem sutil).

- `type`: mostra se é um comando interno ou não (comando significa que pode ser interno, pelo shell, ou externo, ao instalar um programa)
- `type echo`: vai retornar que é um programa **shell builtin** (comando interno do shell)
- `type clear` (**usando o comando pela segunda vez**): se já tiver usado o comando `clear`, vai informar que é um programa que está no cache interno (**hashed**), no caso em `/usr/bin/clear` (basicamente um programa externo, assim como `/bin/tar`, por exemplo. Mas é bom diferenciar o **hashed**, que no caso está em cache - em cache para aumentar a eficiência do sistema, o comando foi adicionado a uma tabela de hash para ficar mais acessível na próxima vez que for executado. Depois do reboot volta ao normal - fora da tabela de hash)

>[!NOTE]
>
>Uma maneira mais rápida de limpar a tabela de hash é executar o comando `hash -d`

O caminho para esses programas externos ficam na variável `$PATH`. Os caminhos são separados por `:`. Ao digitar `tar`, é verifica se há algum programa chamado `tar` em algum dos caminhos, no caso está em `/bin/`

>[!NOTE]
>
>Para adicionar um novo diretório ao seu caminho `PATH`, use: `export PATH="/home/yourname/myfiles:$PATH"`. Crie um script simples no diretório `myfiles/`, torne-o executável e tente executá-lo a partir de um diretório diferente. Estes comandos pressupõem que você esteja no diretório inicial, que contém um diretório chamado `myfiles`, vide exemplo abaixo:

```
$ touch myfiles/myscript.sh
$ echo '#!/bin/bash' >> myfiles/myscript.sh
$ echo 'echo Hello' >> myfiles/myscript.sh
$ chmod +x myfiles/myscript.sh
$ myscript.sh
Hello
```

- `echo "Linux Ubuntu"`: imprime "Linux Ubuntu" na saída padrão
- `echo $SHELL`: imprime o conteúdo da variável `$SHELL`, no caso se estiver usando o `bash`, vai imprimir `/bin/bash`

É possível executar scripts das seguintes formas (supõe que o arquivo `script.sh` esteja em `/home/rodrigo/exercicios/script.sh`):
- estando no diretório citado acima: `./script.sh`
- estando em outro diretório, só digitar o caminho **completo**: `/home/rodrigo/exercicios/script.sh`
- estando no diretório `/home/rodrigo`: `exercicios/script.sh` (usando caminho **relativo**)
---
#### Variáveis de Ambiente

- `NOME_VARIAVEL=valor`: declaração de uma variável (localmente, visível apenas na sessão atual do shell)
- `echo $NOME_VARIAVEL`: imprime o valor da variável, localmente.

Se criar um script que imprime uma variável que foi declarada como o exemplo acima, irá imprimir vazio, pois ao executar um script, é chamado outra sessão do shell (consequentemente outro **processo filho**), e posteriormente volta para a sessão que estava (mesmo efeito de quando digita apenas `bash`, no caso entra em um novo shell, com um novo **processo filho**)

Para contornar é preciso exportar a variável, usando `export NOME_VARIAVEL`, ou declarar diretamente com o export: `export NOME_VARIAVEL=valor`

Caso abra uma nova janela/aba do shell, será criado um novo processo independente, e nesse caso mesmo exportando a variável, ela **não** estará disponível (pois **não** é mais um processo filho)

- `set`: mostra todas as variáveis, locais e exportadas (declaradas no bash atual, **enxerga** o que foi e o que **não** foi exportado)
- `env`: mostra as variáveis globais (**só** **enxerga** o que foi exportado)

Ex. `ABC=cde`, apenas `set` que vai enxergar. Para que o `env` enxergue, é preciso exportar, `export ABC`.

>[!NOTE]
>
>`set` é um comando do shell (**set is a shell builtin**, enxerga o que foi e o que não foi exportado)<br>
>Já `env` é um comando externo (`/usr/bin/env`, só enxerga o que foi exportado)

- `env TESTE=Windows ./script.sh`: (supõe que o `script.sh`, imprime o valor da variável `TESTE`, que originalmente tem o valor de `Linux`). Nesse caso **APENAS** nessa execução, vai considerar o valor de `TESTE=Windows`. Se na sequencia digitar `echo $TESTE`, vai imprimir `Linux`

- `unset NOME_VARIAVEL`: **remove** a definição da variável (sem o `$`)

>[!NOTE]
>
>Note que **não há espaços** em torno do sinal de igual durante a atribuição de variáveis.

---
#### Algumas variáveis de ambiente importantes

- `HISTFILE`: onde fica o arquivo de histórico de comandos (`~/.bash_history`)
- `HISTFILESIZE`: tamanho máximo do arquivo `~/.bash_history`
- `HISTFIZE`: quantidade máxima de linhas do arquivo `~/.bash_history`
- `HOME`: mostra o home do usuário local logado
- `LOGNAME`: nome do usuário que fez login na sessão atual
- `PATH`: diretórios em que o Linux irá procurar por arquivos executáveis (sem a necessidade de especificar um caminho completo - neste caso, seria possível executar um programa binário que reside, digamos, em `/usr/local/bin` de dentro do seu diretório pessoal, e ele seria executado como se o arquivo fosse local)
- `PWD`: guarda o último local que alterou o diretório (o diretório atual)
- `SHELL`: o shell que está usando (`/bin/bash`)
- `TERM`: o terminal que está logado (`tty`=sem interface gráfica e `xterm`=com interface gráfica)
- `USER`: nome do usuário (igual ao `LOGNAME`)
- `DISPLAY`: indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106.
- `PS1`: Aparência do prompt do shell.
- `OLDPWD`: Diretório anterior
<br><br>

- `$$`: mostra o PID do shell atual
- `$!`: mostra o último processo executado em background
- `$?`: mostra o código de retorno do último processo executado
    - **0** (zero) significa sucesso, **1** ou **2** geralmente erro
<br><br>

- `echo ~`: o `~` tem o home do usuário atual (caso usuário seja lpi1, retorna `/home/lpi1`)
- `echo ~lpi1`: retorna o home do usuário **lpi1** (retorna `/home/lpi1` - esse é ideal para ver de outros usuários, exemplo: `~root` retorna `/root`)
---

#### Comandos Sequenciais, history, man

- `ls ; date ; ls -la`: o `;` executa os comandos em sequência, independentemente se houver erro no comando
- `ls /tmp/teste && echo Linux`: somente executa o segundo comando se o primeiro tiver sido com **sucesso**
- `||` é o contrário de `&&`, ou seja, somente executa o segundo comando caso o primeiro dê erro. Caso o primeiro seja executado com sucesso (`return 0`), o segundo **NÃO** é executado.
<br><br>

- `history`: exibe todos os comandos já executados (**separado** por usuário, normalmente fica em `~/.bash_history`, e só o usuário dono que consegue vê-lo)
- `!!`: executa o último comando que foi executado. (repete o último comando)
- `!+num`, ou seja, `!21`, ou `!23`, ou `!24`, etc, executa o comando que aparece na lista do history (de acordo com o número)
- `!+string`: executa o comando que encontrou com a string descrita. Ex `!uname`
- `history -c`: limpa o arquivo de history
- `/String`: para pesquisar em arquivos man ou com comando `less`
- `history 20`: imprime as últimas vinte linhas do BD dinâmico de **history**, e do arquivo `.bash_history` (mesmo efeito com `tail -n 20 .bash_history`)

>[!NOTE]
>
>As últimas adições ao seu histórico de comandos **não** são gravadas no arquivo `.bash_history` até o encerramento da sessão.

- `man comando` ou `arquivo_de_configuracao` (alguns arquivos de configuração possuem manual também): manual do comando ou arquivo de configuração (alguns casos)

>[!NOTE]
>
>Alguns comandos são do bash (**comandos internos**), e não terão manual próprio, sendo necessário consultar o manual do bash (`man bash`). Ex. comando `alias`, `type`, `cd`.

>[!NOTE]
>
>`info` é um `man` reduzido. Ex. `info ls`

- `CTRL + R`: pesquisa comandos já digitados no histórico de comandos. Caso tenha mais comandos de acordo com a busca, basta ir apertando `CTRL + R`.
<br><br>

- `man -k "termo_pesquisa"` ou `--apropos`: para encontrar o comando desejado a partir de uma pesquisa. Ex. `man -k "update system"`: retorna o comando `fwupdate` (pesquisa  as  descrições  curtas  de  página  de manual  para  palavras-chave  e   exibe   quaisquer correspondências, por meio de uma base de dados)
    - `man -k "system information"`: retorna os comandos que têm alguma referência de informação do sistema: retorna os comandos `dumpe2fs`,`inxi` e `uname`
<br><br>

- `whatis`: parecido com o `man -k`. Explica o que é o comando, o que ele basicamente faz (exibe descrições de uma linha de páginas de manual). Ex. `whatis tar`: exibe: `The GNU version of the tar archiving utility`
- `apropos "update system"`: faz a busca do comando baseado na descrição (similar ao `man -k`)

>[!NOTE]
>
>O comando `apropos` é interessante para quando não lembramos o que comando que queremos, como por exemplo `uname`, para ver o kernel do sistema. Sabemos que o comando tem algo a ver com kernel, assim digitamos `apropos kernel`, que com certeza o comando `uname` será listado. Depois de achar o comando, é possível consultar seu manual com `man uname`. Caso queira uma descrição rápida, pode usar o comando `type`.

Exemplo: encontrar uma maneira de mostrar dispositivo de bloco físico conectado em bytes, ao invés de megabytes ou gigabytes:
```
$ apropis block
$ man lsblk
$ lsblk -b
```
---
#### uname e alias

- `uname`: imprime informações do sistema (**With no OPTION**, same as `-s`)
- `uname -s` ou `--kernel-name`: retorna o nome do kernel
- `uname -r` ou `--kernel-release`: retorna a versão do kernel
- `uname -a` ou `--all`: retorna todas as informações
- `uname -m` ou `--machine`: print the machine hardware name
- `uname -p` ou `--processor`: print the processor type (non-portable)
- `uname -i`, ou `--hardware-platform`: print the hardware platform non-portable)
- `uname -o` ou `--operating-system`: print the operating system
<br><br>
- `alias`: mostra os atalhos de comandos. Por exemplo, para criar um comando que liste o diretório `/tmp`, use `alias temp='ls /tmp'`, depois digite `temp`, que é o nome do alias.
- `unalias temp`: remove o alias criado anteriormente, chamado `temp`

>[!NOTE]
>
>O comando `alias` surte efeito apenas na sessão atual. Para deixar definitivo coloque as entradas desejadas em `.bashrc` do seu usuário local.
---
#### which

- `which`: retorna somente a localização absoluta de um comando. No caso, algum comando que esteja nos caminhos listados na variável `$PATH`. Ex. `which echo`: retorna que o echo está em `/bin/echo`
- `which uname which`: retorna: `/bin/uname` e `/usr/bin/which`

>[!NOTE]
>
>Se quiser exibir informações sobre comandos internos do shell (“builtin”), use o comando `help`

>[!NOTE]
>
>`which` foi lançado na versão 5 da LPI
---
#### Quoting

Em um comando `echo $TESTE`, a primeira coisa que o shell faz é interpretar as variáveis, para depois executar o comando.

Aspas duplas e simples são para proteger e impedir/controlar a interpretação das variáveis. 

- `echo *`: imprime todo conteúdo da pasta. Para **ignorar** a impressão usa-se `"*"` ou `'*'` (**protegem a interpretação do carácter especial**), poderia usar também `echo \*`, que protege **APENAS** o caractere seguinte. Outro Ex. `echo \*\$`
    - `""` As aspas duplas protegem **tudo**, **exceto**: `\` (barra invertida ou barra de *escape*), `$` (usado para variáveis) e `` ` `` (crase, usada para subcomandos), e, em certos casos, `!`
        - Ex. `echo "$TESTE"`: imprime o conteúdo da variável `TESTE`, nesse caso interpreta o `$`
    - `''` aspas simples já **não** protege.<br>
        - Ex. `echo '$TESTE'`: imprime `$TESTE` (não interpreta o `$`)
        - Ex. `echo \$TESTE`: tem o mesmo efeito, imprime `$TESTE`, pois `\` protege qualquer caractere a seguir

Se tentar imprimir dessa forma: <code>echo Curso &nbsp; &nbsp; &nbsp; Linux &nbsp; &nbsp; &nbsp; LPI-1</code> (sem aspas), o shell vai imprimir sem os espaços: `Curso Linux LPI-1`. Caso use as aspas, aí imprime com os espaços. Ou ainda se proteger os espaços com barra invertida: `Curso\ \ \  Linux\ \ \ LPI-1`

>[!NOTE]
>
>Essa proteção é chamada de **Quoting**

---
### 103.2 Processar fluxos de texto usando filtros
---
#### Aplicando Filtros a Textos e Arquivos - cat, head, tail, sort, less, wc, etc

- `cat alunos.txt`: pega o que tem em `alunos.txt` e joga na saída padrão. (se digita só `cat`, ele pegará o que foi digitado e exibirá na saída padrão. Se direcionar a saída com `>`, exemplo `cat > arquivo.txt`, tudo que digitar vai ser inserido em `arquivo.txt`)
- `cat -n alunos.txt` ou `--number`: exibe as linhas numeradas
- `cat -b alunos.txt` ou `--numer-nonblank`: mostra as linhas numeradas, mas se tiver linha em branco não numera. ( `-b`, `--number-nonblank` number nonempty output lines, overrides `-n`)
- `cat -s alunos.txt` ou `--squeeze-blank`: se tiver mais de uma linha em branco, suprime e deixa apenas uma linha em branco (suppress repeated empty output lines)
- `cat -A alunos.txt` ou `--show-all`: imprime os caracteres especiais que delimitam linhas ou codificação do arquivo. (equivalent to `-vET`)
    - `-v`, `--show-nonprinting`: use `^` and `M-` notation, except for LFD and TAB
    - `-E`, `--show-ends`: display `$` at end of each line
    - `-T`, `--show-tabs`: display `TAB` characters as `^I`

>[!TIP]
>
>Para comparar arquivos podemos usar o comando `diff`. Exemplo: `diff arquivo1.txt arquivo2.txt`, se não retornada nada, quer dizer que os arquivos possuem o mesmo conteúdo.

- `tac`: inverso do `cat`, imprime inversamente a saída do arquivo.
<br><br>

- `head`: mostra as 10 primeiras linhas de um arquivo
- `head -n2` ou `-2`: mostra as duas primeiras linhas
- `head -c50` ou `--bytes 50`: mostra os 50 primeiros bytes do arquivo
<br><br>

- `tail`: mostra as últimas 10 linhas de um arquivo
- `tail -5` ou `-n5`: mostra as últimas 5 linhas
- `tail -f arquivo.txt` ou `--follow`: lê as últimas linhas e fica aguardando alguma saída (algo que seja escrito no arquivo). Comando útil para leitura de log em tempo real. Pode intercalar com `-n` também.

#### Exercício interessante com `tail`

1. Enquanto monitora a saída de um comando `tail` no arquivo `/var/log/syslog`, insira um pendrive. Escreva o comando completo que usaria para obter o Produto (Product), o Fabricante (Manufacturer) e a quantidade total de memória (Blocks) do seu pendrive.

**Resposta:**

- `$ tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'`

O parâmetro `-i` com o comando `grep`, pois não sabemos se as strings que procuramos estão em maiúsculas ou minúsculas. Também usamos `|` como um `OR` (ou) lógico, então procuramos por linhas contendo **product** `OR` **blocks** `OR` **manufacturer**.

---
- `less`: faz a paginação de um arquivo (geralmente muito longo - `less` é uma evolução do `more`). 
    - mostra a primeira página e para. Se por seta para **baixo**/**cima**, navega no arquivo, assim como a tecla **Enter**. 
    - **barra de espaço** vai para próxima página. 
    - É possível fazer buscar com `/String` (**n**=próxima palavra, **N**=volta a busca)
    - `Ctrl + g`: mostra o status e onde está no arquivo
    - `q`: sai da paginação do `less`
<br><br>

- `wc`: imprime a quantidade de **linhas**, **palavras** e **bytes**. Normalmente 1 caractere é igual a 1 byte, mas caracteres especiais (`ç` `~``_` e etc) podem ter mais de um byte.
- `wc -l arquivo.txt` ou `--lines`: mostra apenas a quantidade de **linhas** 
- `wc -w arquivo.txt` ou `--words`: mostra apenas a quantidade de **palavras**
- `wc -c arquivo.txt` ou `--bytes`: mostra apenas a quantidade de **bytes**
- `wc -m arquivo.txt` ou `--chars`: mostra apenas a quantidade de **caracteres**
- `wc *`: roda o `wc` para todos os arquivos que se encontram no diretório atual e soma no final
<br><br>

- `nl`: similar ao `cat -b` (numera as linhas do arquivo, desconsiderando as linhas em branco - number lines of files)
<br><br>

- `sort arquivo.txt`: ordena o arquivo em ordem alfabética `a` ao `z` (se houver linhas em branco, essas irão para o **início**)
- `sort -r arquivo.txt` ou `--reverse`: ordena ao contrário, do `z` ao `a` (se houver linhas em branco, essas irão para o **final**)
- `sort -k2 arquivo.txt` ou `--key=KEYDEF`: ordena pelo segundo campo (um exemplo clássico seria ordenar pelo sobrenome)
    - é possível usar com o `cat`: `cat alunos.txt | sort -r`
- `sort -R arquivo.txt`: ordena aleatoriamente. Se usar com `head -1`, faz como se fosse um sorteio.

#### Exercício interessante de `sort`
1. O arquivo `/etc/passwd` contém a lista de usuários do Linux, os campos são separados pelo caractere `:`, o primeiro campo indica o nome do  usuário e o terceiro o ID do usuário.

Escreva um comando que mostre os últimos 15 registros do arquivo, exibindo apenas o nome do usuário e seu ID, e que esteja ordenado pelo  ID numérico. Por exemplo:
```
usuario1:10
usuario2:12
usuario:3:1000
```
**Resposta**: `tail -n 15 /etc/passwd | cut -d":" -f1,3| sort -t ":" -k2 -g`
- No comando `sort`:
    - O `-g`, `--general-numeric-sort`: compare according to general numerical value
    - O `-t`, `--field-separator=SEP`: use SEP instead of non-blank to blank transition<br>

2. Quantos usuários e grupos existem em seu sistema (lembre-se: use apenas o arquivo /etc/passwd)?

**Resposta**:
- usuários: `cut -d: -f3 /etc/passwd | sort -u | wc -l`
- grupos: `cut -d: -f4 /etc/passwd | sort -u | wc -l`

>[!NOTE]
>
>`-u`, `--uniq` (`sort`): with  `-c`, check for strict ordering; without `-c`, output only the first of an equal run
---

#### uniq, od, paste, split

- `uniq alunos.txt`: mostra as ocorrências únicas (não repetidas)

>[!IMPORTANT]
>
>`uniq` entende apenas uma linha após a outra. Caso haja repetição em linhas diferentes, acaba mostrando duas ou mais vezes. Interessante é usar um `sort` antes: `sort alunos.txt | uniq`

- `sort alunos.txt | uniq -d` ou `--repeated`: mostra apenas as linhas duplicadas (uma vez apenas)
- `sort alunos.txt | uniq -c` ou `--count`: conta quantas repetições há no arquivo (coloca o número de repetições na frente). Conta inclusive espaços em branco

---

- `od`: (dump files in octal and other formats)
- `od alunos.txt`: exibe em formato octal (mas mostra em outros tipos)
- `od -tx alunos.txt` ou `--format` para o `-t`: exibe em hexadecimal ( `-x`)
- `od -c alunos.txt`: mostra caracteres que não são normalmente visíveis que existem em arquivos, como os indicadores de [nova linha](#tr---opções-avançadas). A opção `-c`, de modo que, em vez de exibir a notação numérica para cada byte, as colunas serão mostradas como seus equivalentes em caracteres
<br><br>

---

- `join`: combina dois arquivos por meio de um índice.

Imagine dois arquivos, `codigo-aluno.txt` e `notas-aluno.txt`, tendo o respectivo conteúdo:

`codigo-aluno.txt`
```
1 Ana
2 Joao
3 Andre
4 Maria
5 Carlos
```
e `notas-aluno.txt`
```
1 10
2 8
3 9
4 2
5 0
```

- `join codigo-aluno.txt notas-aluno.txt`: vai interpretar que o primeiro campo é um campo de índice, exibindo a saída:
```
1 Ana 10
2 Joao 8
3 Andre 9
4 Maria 2
5 Carlos 0
```

>[!NOTE]
>
>Caso queira indicar outro campo compo índice, basta usar `join -j2 arq1.txt arq2.txt`
<br><br>

Comando similar é o `paste`, que pega linha a linha dos dois arquivos e exibe. Exemplo com os arquivos de teste feito no exemplo anterior: `paste codigo-aluno.txt notas-aluno.txt`, vai exibir:
```
1 Ana 1 10
2 Joao 2 8
3 Andre 3 9
4 Maria 4 2
5 Carlos 5 0
```

---

- `split`: divide um arquivo em vários outros. Supõe que temos um arquivo de 80 linhas.
- `split -l20 arquivolongo.txt` ou `--lines`: divide cada arquivo em 20 linhas. Criando os arquivos:
    - `xaa`
    - `xab`
    - `xac`
    - `xad`
- `split -l20 arquivolongo.txt novo_arquivo_`: divide da mesma forma que o exemplo anterior, mas cria os arquivos:
    - `novo_arquivo_aa`
    - `novo_arquivo_ab`
    - `novo_arquivo_ac`
    - `novo_arquivo_ad`

>[!TIP]
>
>Para confirmar a quantidade de linhas em cada arquivo, use `wc -l novo_arquivo_*`

>[!NOTE]
>
>O comando `split`, com a opção `-l`, pode ser omitido e colocado diretamente a quantidade de linhas: `split -20 arquivolongo.txt`

>[!NOTE]
>
>O comando `split`, se não usado nenhuma opção, por padrão divide o arquivo em vários outros arquivos de **1000** linhas cada
    
- `split -b100 arquivolongo.txt novo_arquivo_` ou `--bytes`: divide o arquivo a cada 100 bytes.
---

####  tr, cut e sed
---
- `tr`: pega um conteúdo de texto e substitui ou excluir algum caractere (precisa ser redirecionado/canalizado (*piping*), vindo de um `cat` por exemplo)
- `cat alunos.txt | tr a-z A-Z`: transforma toda letra minúscula em maiúscula.
- `cat alunos.txt | tr A E`: transforma toda letra `A` em `E`.
- `cat alunos.txt | tr ei EI`: transforma **SOMENTE** as letras `ei` minúsculo em `EI` maiúsculo (**NÃO** precisa estar junto o `ei`)
- `cat alunos.txt | tr [:upper:] [:lower:]`: transforma tudo que estiver em *upper* para *lower* (`tr --help` mostra outras opções)
- `cat alunos.txt | tr ' ' '_'`: sempre que tiver um espaço (`' '`), troca por um underline (`'_'`)
- `cat alunos.txt | tr -d 'A'` ou `--delete`: exclui toda letra `A` maiúscula que encontrar
- `cat alunos.txt | tr -d [:upper:]`: exclui toda letra maiúscula que encontrar
- `cat alunos.txt | tr -d [:blank:]`: exclui toda espaço em branco que encontrar
<br><br>

---

#### tr - opções avançadas
- `tr -s` ou `--squeeze-repeats`: retira partes repetidas em um conjunto de caracteres
- `echo "Curso de Liiiiinux | tr -s i`: exibe: `Curso de Linux`. (precisa informar após o `-s` qual caractere deseja remover as repetições)
- echo <code>"Curso de &nbsp;&nbsp;&nbsp; Linux" | tr -s " "</code>: deixa apenas um espaço em branco

Quanto às quebras de linhas tanto no Windows como no Linux, há algumas diferenças
- No Windows usa-se:
    - **LF** = Line Feed = Nova linha, que usa `\n`
    - **CR** = Carriage Return, que usa `\r`
- No Unix/Linux usa-se:
    - **LF**, com `\n`

No arquivo de texto, caso use `cat -A`, poderá ver as quebras, que podem ser:
- **Windows**: `^M` (usa tanto `\n` como `\r`)
- **Unix/Linux**: `$` (usa `\n` apenas)

No geral é para não ter muitos problemas com essas quebras de linha, no entanto pode acontecer se precisar converter esses formatos (se for de **CR-LF** para **LF**, basta remover o `\r`):

Considere dois arquivos, um gerado no windows e outro no Linux:  
`cat -A ArquivoGeradoLinux.txt`
```
Este arquivo foi gerado no Linux$
para exemplificar a aula sobre o comando tr$
no curso de LPIC-1$
```

`cat -A ArquivoGeradoWindows.txt`
```
Este arquivo foi gerado em^M$
um notepad simples do Windows^M$
para exemplificar a aula sobre o comando tr
```

É importante notar a diferença dos arquivos usando o comando `file ArquivoGerado*`, que retorna:
```
ArquivoGeradoLinux.txt:    ASCII text
ArquivoGeradoWindows.txt:    ASCII text, with CRLF line terminators
```

Para ver o `/r` e `/n` que são gerados no arquivo `ArquivoGeradoWindows.txt`, use o comando `od -c ArquivoGeradoWindows.txt` (mais sobre `od` [aqui](#uniq-od-paste-split)), tendo a seguinte saída (o `-c` de `od` significa: *select printable characters or backslash escapes*):
```
0000000   E   s   t   e       a   r   q   u   i   v   o       f   o   i
0000020       g   e   r   a   d   o       e   m  \r  \n   u   m       n
0000040   o   t   e   p   a   d       s   i   m   p   l   e   s       d
0000060   o       W   i   n   d   o   w   s  \r  \n   p   a   r   a
0000100   e   x   e   m   p   l   i   f   i   c   a   r       a       a
0000120   u   l   a       s   o   b   r   e       o       c   o   m   a
0000140   n   d   o       t   r
0000146
```

- `tr -d "\r" < ArquivoGeradoWindows.txt > NovoArquivo.txt`: retira o `\r` do arquivo que foi gerado no Windows e cria um novo arquivo com formato para Unix/Linux (**LF**). Dando um `cat -A` no arquivo pode-se notar a diferença:
```
Este arquivo foi gerado em$
um notepad simples do Windows$
para exemplificar a aula sobre o comando tr
```

---
- `cut`: para cortar partes de um texto

Considere o seguinte conteúdo do arquivo `alunos.txt`:
```
Paulo Freitas
Ana Claudia
Silvia Oliveira
Rafael dos Santos
```
- `cut -c1-5 alunos.txt` ou `--characters`: recorta os 5 primeiros caracteres, ficando a seguinte saída:
```
Paulo
Ana C
Silvi
Rafae
```
- `cut -c5-10 alunos.txt`: recorta do caractere 5 ao caractere 10, ficando a saída:
```
o Frei
Claudi
ia Oli
el dos
```
- `cut -c1,2,5 alunos.txt`: recorta os caracteres 1, 2 e 5, ficando a saída:
```
Pao
AnC
Sii
Rae
```

>[!IMPORTANT]
>
>Quando for range (`-c1-5`, por exemplo), pode usar `-c-5` que vai ter o mesmo efeito. Assim como se usar `-c5-`, que significa do caractere 5 pra frente

- `cut -b1-5 alunos.txt` ou `--bytes`: recorta os 5 primeiros **bytes**, ficando a seguinte saída:
```
Paulo
Ana C
Silvi
Rafae
```
>[!IMPORTANT]
>
>Como nesse caso cada byte é igual a um caractere, a saída será a mesma que utilizando `-c`

- `cut -d" " -f1 alunos.txt` ou `--delimiter`: delimita e extrai o campo 1 (`-f` ou `--fields`), cujo delimitador é o espaço em branco (`" "`), ficando a seguinte saída (como os nomes e sobrenomes são separados por espaço em branco, deve retornar apenas o primeiro nome):
```
Paulo
Ana
Silvia
Rafael
```

>[!IMPORTANT]
>
>Se houvesse um delimitador com `tab`, por exemplo, retornaria o nome completo, pois `tab` é diferente de espaço em branco.

>[!IMPORTANT]
>
>O `-f` pode ser usado com range também: `-f1-3`: do campo 1 ao campo 3. Ou a partir do caractere 2: `-f2-`. Ou também selecionando o campo 1 e 3: `-f1,3`

<br><br>

---
- `sed`: usado para procurar um conteúdo e substituir, e também para excluir alguma parte do texto
- `sed 's/Silva/Sousa/' alunos.txt`: substitui `Silva` por `Sousa`, apenas na primeira ocorrência que encontrar em cada linha.

Por exemplo, supondo que no arquivo `alunos.txt` temos o seguinte conteúdo:
```
Ana Claudia
Ana Claudia Vasconcelos Ana
```

Executando o comando `sed 's/Ana/Maria/' alunos.txt`, teremos a seguinte saída:
```
Maria Claudia
Maria Claudia Vasconcelos Ana
```

Na linha que tem duas ocorrências de `Ana`, apenas a primeira é substituída.

Para que tudo seja substituído, precisa usar a flag `g`, no final da delimitação de substituição (que transforma o comando em `global`):
- `sed 's/Ana/Maria/g' alunos.txt`, assim teremos a saída:
```
Maria Claudia
Maria Claudia Vasconcelos Maria
```

- `sed '3,5 d' alunos.txt`: apaga da linha 3 até a linha 5 (aqui dá impressão que é linha 3 **e** linha 5, mas o comando `sed` dessa forma funciona como se fosse um *range*)
- `sed '/Claudia/d' alunos.txt`: exclui a linha de todas as ocorrências que `Claudia` aparecer
- `sed -i.backup 's/Ana/Claudia alunos.txt'`: troca os nomes no arquivo `alunos.txt` e cria o arquivo `alunos.txt.backup`com o conteúdo inicial (A opção `-i` executa uma operação `sed` local no arquivo original. Se você não usar `.backup` após o parâmetro `-i`, vai reescrever o arquivo original. Qualquer texto inserido após o parâmetro `-i` será o nome com o qual o arquivo original será salvo antes das modificações que você pediu ao `sed` para realizar.)

#### Mais exemplos uso `sed`

A exclusão da primeira linha com o sed é realizada por `1d`:
```
$ factor `seq 12` | sed 1d
2: 2
3: 3
4: 2 2
5: 5
6: 2 3
7: 7
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Especificamos um intervalo de linhas com uma **vírgula** de separação:
```
$ factor `seq 12` | sed 1,7d
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Mais de uma instrução pode ser usada na mesma execução, separadas por **ponto e vírgula**. Nesse caso, no entanto, é importante colocá-las entre **parênteses** para que o ponto e vírgula não seja interpretado pelo shell:
```
$ factor `seq 12` | sed "1,7d;11d"
8: 2 2 2
9: 3 3
10: 2 5
12: 2 2 3
```

Neste exemplo, duas instruções de exclusão foram executadas, primeiro nas linhas que vão de 1 a 7 e depois na linha 11. Um endereço também pode ser uma expressão regular, portanto, apenas as linhas correspondentes serão afetadas pela instrução:
```
$ factor `seq 12` | sed "1d;/:.*2.*/d"
3: 3
5: 5
7: 7
9: 3 3
11: 11
```

A expressão regular `:.*2.*` corresponde a qualquer ocorrência do número 2 em qualquer lugar depois de dois pontos, provocando a exclusão das linhas correspondentes aos números que tenham 2 como fator. Com o `sed`, qualquer coisa colocada entre barras (`/`) é considerada uma expressão regular e, por padrão, todas as ER básicas são suportadas. Por exemplo, `sed -e "/^#/d" /etc/services` mostra o conteúdo do arquivo `/etc/services` sem as linhas que começam com `#` (linhas de comentário).

A instrução de exclusão `d` é apenas uma das muitas instruções de edição fornecidas pelo `sed`. Em vez de excluir uma linha, o `sed` pode substituí-la por um texto determinado:
```
$ factor `seq 12` | sed "1d;/:.*2.*/c REMOVED"
REMOVED
3: 3
REMOVED
5: 5
REMOVED
7: 7
REMOVED
9: 3 3
REMOVED
11: 11
REMOVED
```

A instrução `c REMOVED` simplesmente substitui uma linha pelo texto `REMOVED`. No caso do exemplo, cada linha com uma substring correspondente à expressão regular `:.*2.*` é afetada pela instrução `c REMOVED`. 

A instrução `a TEXT` copia o texto indicado por `TEXT` para uma nova linha após a linha com uma correspondência. 

A instrução `r FILE` faz o mesmo, mas copia o conteúdo do arquivo indicado por `FILE`. A instrução `w` faz o oposto de `r`, ou seja, a linha será anexada ao arquivo indicado.

De longe, a instrução mais usada do `sed` é `s/FIND/REPLACE/`, que é usada para substituir uma correspondência da expressão regular `FIND` pelo texto indicado por `REPLACE`. Por exemplo, a instrução `s/hda/sda/` substitui uma substring que corresponde à ER literal `hda` por `sda`. Apenas a primeira correspondência encontrada na linha será substituída, a menos que o sinalizador `g` seja colocado após a instrução, como em `s/hda/sda/g`.

---

#### Exercício interessante sobre `sed`

1. Gere um comando, ou sequência deles, que mostre o número de linhas do arquivo `/etc/passwd` excluindo-se as linhas que contenham a palavra  "daemon". O resultado do comando deve ser o número de linhas.

**Resposta**: `sed '/daemon/d' /etc/passwd| wc –l` ou `grep -v daemon /etc/passwd | wc –l`

>[!NOTE]
>
>O `grep -v` ou `--invert-match` é o que exclui a linha quando acha ocorrências (e exibe o restante)

2. Alguém acaba de doar um laptop para sua escola e você deseja instalar Linux nele. Ele veio sem manual e você é obrigado a inicializá-lo a partir de um pen drive USB sem nenhuma interface gráfica. Aparece um terminal shell e você sabe que, para cada processador presente, haverá uma linha dedicada no arquivo `/proc/cpuinfo`:
```
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(linhas puladas)

processor	: 1
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(more lines skipped)
```
Usando os comandos `grep` e `wc`, exiba o número de processadores presentes:

**Resposta**: `grep processor /proc/cpuinfo | wc -l`

Faça o mesmo com `sed` em vez de `grep`:

**Resposta**: `sed -n /processor/p /proc/cpuinfo | wc -l`

>[!NOTE]
>
>`sed` com o parâmetro `-n` para que `sed` não imprima nada, exceto o que corresponde à expressão processor, conforme instruído pelo comando `p`

3. Liste apenas a primeira, a última e a décima linha do arquivo `/etc/passwd`

**Resposta:** `sed -n -e '1'p -e '10'p -e '$'p /etc/passwd`

>[!NOTE]
>
>o parâmetro `-n` diz ao `sed` para não imprimir nada além do que é especificado pelo comando `p`. O cifrão (`$`) usado aqui é uma expressão regular que representa a última linha do arquivo.

>[!NOTE]
>
>`-e` script, `--expression=script`: add the script to the commands to be executed

---

#### xzcat, bzcat e zcat

Crie os arquivos compactados com os comandos (esses comandos na realidade são diferentes algoritmos de compactação):
- `xz -k arquivolongo.txt` ou `--keep`
- `bzip2 -k arquivolongo.txt` ou `--keep`
- `gzip -k arquivolongo.txt` ou `--keep`

Para consultar os tipos de compactação, use: `file arquivolongo.txt*`, que resulta na saída:
```
arquivolongo.txt:     ASCII text
arquivolongo.txt.bz2: bzip2 compressed data, block size = 900k
arquivolongo.txt.gz:  gzip compressed data, was "arquivolongo.txt", last modified: Sat Dec 28 23:55:42 2024, from Unix, original size modulo 2^32 59
arquivolongo.txt.xz:  XZ compressed data, checksum CRC64
```

Um `cat` no arquivo compactado `NÃO` exibirá seu conteúdo, mostrará apenas o binário do arquivo (pois foi compactado). E é interessante ler o arquivo que está compactado sem ter que descompactar o arquivo (internamente acaba descompactando, mas agiliza usar os comandos de leitura), logo para cada tipo de compressão, há um comando para leitura:
- para **.xz**: `xzcat arquivolongo.txt.xz`
- para **.gzip**: `zcat  arquivolongo.txt.gz`
- para **.bzip2**: `bzcat  arquivolongo.txt.bz2`
---

#### checksums (hashes)

- `md1sum` (mais antigo):
- `md5sum` (mais antigo):
- `sha256sum` (mais moderno - usa 256 bits para criação da hash):
- `sha512sum` (mais moderno e seguro - usa 512 bits):

Exemplos

- `sha256sum ubuntu.iso`: gera uma hash para o arquivo `ubuntu.iso` (**hash**=sequencia de caracteres **única** para o arquivo `ubuntu.iso` - qualquer mudança no arquivo, a **hash** será alterada)

É interessante para download de `.iso`, o qual normalmente disponibiliza um arquivo com os **checksums** de cada versão de arquivos `.iso`

A comparação pode ser a olho, ou pelo comando `sha256sum -c SHA256SUMS` ou `--check`, sendo `SHA256SUMS` o arquivo que contém os checksums das `.iso`, e o comando returna `OK` se estiver correto (mensagem de erro é algo parecido com isso `sha256sum: WARNING: 1 computed checksum did NOT match`)

---

### 103.3 Gerenciamento básico de arquivos

#### cd, ls, file

- `cd /home/lpi1`: entra na pasta `/home/lpi1`
- `cd ..`: volta um nível no diretório
- `cd -`: volta no diretório anterior
- `cd ~`: vai para o `/home` do usuário que está logado
- `cd ../..`: volta dois níveis nas pastas
---

- `ls -l`: lista detalhada, tendo os campos:
    1. tipo do arquivo + permissão
        - `-`: arquivo regular
        - `d`: diretório
        - `c`: arquivo especial
    2. quantidade de hard links
    3. usuário dono do arquivo/diretório
    4. grupo dono do arquivo/diretório
    5. tamanho em bytes
    6. data/hora da última alteração do arquivo/diretório
    7. nome do arquivo

>[!NOTE]
>
> Quando não é especificado o diretório ou arquivo a ser listado, o diretório atual fica implícito.

- `ls -la`: lista detalhada e mostra arquivos ocultos. Repare que no início da lista mostra `.` e `..`. 
    - O ponto `.` se refere ao **diretório atual**. 
    - E os dois pontos `..` se refere ao **diretório anterior**.
- `ls -h` ou `--human-readable`: mostra valores mais fácil para humanos lerem (transforma bytes em KBytes/MBytes, etc)
- `ls -lR` ou `--recursive`: entra em cada diretório recursivamente mostrando que tem dentro de cada um

>[!NOTE]
>
>A adição de barra no diretório não tem efeito. `ls -R curso` é **igual** a `ls -R curso/`

---

<a id="fileglobbing"></a>

#### globbing de arquivos e caracteres curinga

O *globbing* de arquivos é um recurso fornecido pelo shell do Unix/Linux para representar múltiplos nomes de arquivo usando caracteres especiais chamados caracteres curinga.

#### Tipos de caracteres curinga

Existem três caracteres que podem ser usados como curingas no Linux:

- `*` (asterisco)
representa zero, uma ou mais ocorrências de qualquer caractere.

- `?` (interrogação)
representa uma única ocorrência de qualquer caractere.

- `[ ]` (caracteres entre colchetes)
representa qualquer ocorrência do(s) caractere(s) inseridos nos colchetes. É possível usar diferentes tipos de caracteres, sejam números, letras ou outros caracteres especiais. Por exemplo, a expressão `[0-9]` representa todos os dígitos.

- `ls -l Aula1*`: traz tudo que houver com o nome `Aula1`+`qualquer coisa`, inclusive o arquivo `Aula1` se houver
- `ls -l Aula1?`: `?` substitui um caractere, exigindo que tenha uma letra/número no seu lugar (não retorna o arquivo `Aula1`, pois é exigido que tenha um caractere no seu lugar)
- `ls -l Aula?0`: mesmo esquema do anterior, nesse caso vai listar os arquivos `Aula10`, `Aula20`, `Aula30`, etc.
- `ls -l Aula[123]`: lista apenas os arquivos `Aula1`, `Aula2` e `Aula3`
- `ls -l Aula[!123]`: não mostra `Aula1`, `Aula2` e `Aula3`, mostra apenas `Aula4`, `Aula5` e `Aula6`
- `ls -l Aula[1-5]`: mostra da mesma forma que a anterior, mas com range (pode negar também com `!`)
- `ls -l Aula[1-5]?`: mostra os arquivos e que tenha alguma coisa após o range.
- `ls -l Aula{10,20,30}`: especifica qual string que deseja. Nesse caso retorna `Aula10`, `Aula20` e `Aula30`
- `ls -l A{ula,ULA}`: mostra tanto `Aula` como `AULA`

>[!TIP]
>
>Para facilitar a leitura de uma estrutura de diretório, use o comando `tree diretorio`.

---

- `file arquivo`: analisa e retorna o que é o arquivo
- `file alunos.txt`: retorna que é um `UTF-8 Unicode text`
- `file script.sh`: retorna que é um `Bourne-Again shell script, UTF-8 Unicode text executable`
- `file aula`: (supõe que o arquivo `aula` está vazio), retorna `empty`
---

#### touch, cp, mv

- `cp alunos.txt /tmp`: copia o arquivo `alunos.txt` para o diretório `/tmp`
- `cp -i alunos.txt /tmp` ou `--interactive`: caso já haja o arquivo no destino, pergunta se quer sobrescrever.
- `cp Diretorio1/ /tmp`: se tentar copiar um diretório vai dar erro (sem a opção `-r`). Precisa usar a opção `-r` ou `--recursive`
- `cp -p Aula8 /tmp/`: preserva ownership e timestamps. Sem o `-p` vai fazer como se criasse um novo arquivo, mudando timestamp e ownership caso outro usuário copiasse o arquivo (same as `--preserve`=mode,`ownership`,`timestamps`)
- `cp Aula1 Curso1`: cria uma cópia de `Aula1` com nome de `Curso1` (copia e muda o nome)
---
- `mv`: move arquivos, é bem parecido com `cp`, não tem as opções `-R` ou `-r` e o `-p`. O `cp` mantém o arquivo de origem, já o `mv` remove.
- `mv Aula1 Curso2`: renomeia `Aula1` para `Curso2` (internamente é como se recortasse `Aula1` e colasse `Curso2` - lembrar que `mv` não mantém a origem) - Tomar **CUIDADO** para sobrescrever o arquivo, correto seria usar com `-i`
- `mv -f Aula1 Curso2` (ou `--force`): caso já exista o arquivo `Curso2`, nem avisa que vai sobrescrever (sobrescreve à força, sem pedir permissão).
- `mv file1 file2 -t exercises/` ou `--target-directory=DIRECTORY`: move ambos arquivos, `file1` e `file2` para o diretório `exercises`
---
- `touch`: serve para criar arquivos (vazio) ou mudar o timestamp dele.
- `touch linux.txt`: cria o arquivo `linux.txt` (vazio). Pode criar vários ao mesmo tempo: `touch file1 file2 file3`
- `touch arquivo.txt`: supondo que `arquivo.txt` já exista, esse comando atualiza a data/hora da última modificação do arquivo.
- `touch -a arquivo.txt`: altera a data do **último acesso** apenas
- `touch -m arquivo.txt`: altera a data da **última modificação** apenas
- `touch -t 201712241000 Aula30`: altera o timestamp do arquivo `Aula30` para às **10h** do dia **24/12/2017**
---

#### rm, mkdir, rmdir, find


- `rm Aula1`: remove o arquivo Aula1, sem perguntar
- `rm -i Aula1`: remove o arquivo Aula1, perguntando se deseja realmente remover
- `rm -r Diretorio/`: para remover diretórios, precisa usar a opção `-r` (remove tudo que estiver no diretório - sem o `-r` não remove, informando que é um diretório)
- `rm Aula1 Aula2 Aula3`: remove três arquivos de uma vez

>[!WARNING]
>
>Tenha muito cuidado com o `-r` ou a combinação de opções de `-rf` quando usá-lo com o comando `rm`. Um comando de remoção recursivo em um diretório de sistema importante pode tornar o sistema inutilizável. Empregue o comando de remoção recursiva somente quando tiver certeza absoluta de que o conteúdo de um diretório pode ser removido do computador com segurança.
---

- `rmdir`: remove diretório (apenas diretórios **VAZIOS** - se tiver arquivo, dá o erro: `Directory not empty`)
    - Caso tenha uma estrutura de pastas seguidas e vazias, pode usar `rmdir -p` ou `--parents` para remover de uma vez. Ex. `rmdir -p Curso/LPI/V1` (desde que todas **VAZIAS**)
---

- `mkdir Linux`: cria o diretório `Linux`
- `mkdir Linux/Ubuntu`: complementando o comando anterior, cria a pasta `Ubuntu`, dentro da pasta `Linux`
    - Se tentar criar uma estrutura que a primeira pasta ainda não existe, como `mkdir Curso/LPI/V1`, vai dar erro.
- `mkdir -p Curso/LPI/V1` ou `--parents`: contorna o erro citado anteriormente e cria a estrutura desejada.
---

- `find`: usado para procurar arquivos e diretórios no sistema (sintaxe: `find onde_procurar o_que_procurar`)
- `find /home -name Aula10`: procura em `/home` pelo arquivo `Aula10`
- `find /home -name Aula*`: procura em `/home` tudo que começa com `Aula` e termine com qualquer coisa
- `find /home -user lpi2`: procura tudo (arquivos e diretórios) que o dono seja o usuário `lpi2`
- `find /home -user lpi2 -name Aula2`: busca em `/home` o arquivo que se chame `Aula2` e que o dono seja `lpi2`
- `find ./ -ctime -1`: procura no diretório que está atualmente tudo que foi alterado há 1 dia

#### critérios para acelerar a pesquisa

- `type f`: busca por arquivos
- `type d`: busca por diretórios
- `type l`: busca por links simbólicos

Exemplo: `find . -type d -name "example"`: procura por todos os diretórios, no diretório atual e abaixo dele, que tenham o nome `example`

Dentre os critérios que podem ser usados com `find` temos:
- `-name`: pesquisa com base no nome fornecido
- `-iname`: pesquisa com base no nome, desconsiderando maiúsculas e minúsculas (sendo, por exemplo, `myFile` = a `MYFILE`)
- `-not`: retorna os resultados que não correspondem ao caso de teste
- `-maxdepth N`: pesquisa no diretório atual, além dos subdiretórios de `N` níveis de produndidade.

#### busca com base em quando o arquivo foi modificado

Exemplo: `sudo find / -name "*.conf" -mtime 7`: procura por todos os arquivos em todo o sistema de arquivos (pois começa em `/`), que terminam com os caracteres `.conf` e que foram modificados na base da estrutura de diretórios do sistema (por isso deve usar `sudo`). O argumento `mtime` representa o número de dias desde a última modificação do arquivo

**Observação importante**: argumentos numéricos `n` podem ser especificados para testes (como `-amin`, `-mtime`, `-gid`, `-inum`, `-links`, `-size`, `-uid` e `-used`) da seguinte forma:
- `+n`: para maiores que (greater than) `n`
- `-n`: para menores que (less than) `n`
- `n`: pra exatamente `n`

#### localizando arquivos por tamanho

Exemplo: `sudo find /var -size +2G`: procura por arquivos maiores que **2G** em `/var`

A opção `-size` exibe arquivos de tamanhos correspondentes ao argumento passado, vejamos alguns exemplos:
- `-size 100b`: arquivos com exatamente **100 bytes**
- `-size +100k`: arquivos menores que **100 kilobytes**
- `-size -20M`: arquivos menores que **20 megabytes**
- `-size +2G`: arquivos maiores que **2 gigabytes**

>[!NOTE]
>
>Para encontrar arquivos vazios, podemos usar: `find . -size 0b`  ou  `find . -empty`

#### Manipular os resultados do `find`

Uma vez que a pesquisa é feita, é possível realizar uma ação no conjunto de resultados usando `-exec`:

Exemplo
```
find . -name "*.conf" -exec chmod 644 '{}' \;
```
Esse comando filtra todos os objetos no diretório atual (`.`) e abaixo dele para nomes de arquivo terminando com `.conf` e em seguida executa o comando `chmod 644` para modificar as permissões de arquivo nos resultados.

Outro exemplo:
```
find . -type f -exec grep "lpi" '{}' \; -print
```

Esse comando busca, na hierarquia de diretórios atual (`.`), por objetos que são arquivos (`-type f`) e em seguida executa o comando `grep "lpi"` para cada arquivo que satisfaça as condições. Os arquivos que atendem a essas condições são impressos na tela (`-print`). As chaves (`{}`) servem para reservar o espaço para os resultados encontrados por `find`. As `{}` são postas entre aspas simples (`'`) para evitar passar arquivos com nomes contendo caracteres especiais para o `grep`. O comando `-exec` é concluído com um ponto e vírgula (`;`), que deve ser escapado (`\;`) para não ser interpretado pelo shell.

Mais um exemplo, agora usando `-delete`
```
find . -name "*.bak" -delete
```

A opção `-delete`, se colocada no final de uma expressão, excluiria todos os arquivos correspondentes à descrição. Esta opção deve ser usada quando você tiver certeza de que os resultados correspondem apenas aos arquivos que deseja excluir.

No exemplo abaixo, `find` localiza todos os arquivos na hierarquia começando no diretório atual e, em seguida, exclui todos os arquivos que terminam com os caracteres `.bak`

#### Exercício interessante sobre `find`

1. O administrador do sistema precisa realizar verificações regulares para remover arquivos volumosos. Esses arquivos volumosos estão localizados em `/var` e terminam com uma extensão `.backup`.

Escreva o comando, usando `find`, para localizar esses arquivos:
```
$ find /var -name *.backup
```

Uma análise do tamanho desses arquivos revela que eles variam de `100M` a `1G`. Complete o comando anterior com esta nova informação para poder localizar os arquivos de backup variando de `100M` a `1G`:
```
$ find /var -name *.backup -size +100M -size -1000M
```

Finalmente, complete este comando com a ação `delete` para remover esses arquivos:
```
$ find /var -name *.backup -size +100M -size -1000M -delete
```

2. Encontre todos os arquivos do diretório `/var`, cujo nome termine com `.gz` e que foram modificados nas últimas `48 horas`:
```
# find /var -name “*gz” -mtime -2
```

`mtime` refere-se ao *modification time*. Para evitar as mensagens de erro referentes a
permissões de leitura, é melhor executar como root.

---

#### tar, gzip, bzip2, xz (agrupar e comprimir arquivos)

**Agrupando** arquivos:

- `tar cpvf backup.tar novo*`: agrupa (**não compacta**) todo arquivo que comece com a palavra `novo` e termine com qualquer coisa no arquivo `backup.tar`. Mantendo as permissões (`-p`) (**sempre** precisa usar o `-f` ou `--file`, para criar o arquivo `.tar` desejado)
    - `-c` ou `--create`
    - `-p` ou `--preserve-permissions`, `--same-permissions`
    - `-v` ou `--verbose`
- `tar tf backup.tar`: lista o que há dentro do agrupamento criado anteriormente.
    - `-t` ou `--list`

**Desagrupando**:

- `tar -xvf backup.tar` ou `--extract`, `--get`: desagrupa o arquivo `backup.tar`
- `tar -xvf backup.tar -C /tmp`: desagrupa no diretório `/tmp` (pode usar `-C` ou `--directory`)

>[!NOTE]
>
>Pode escolher o arquivo a ser desagrupado do agrupamento: `tar -xf backup.tar file1`: nesse caso desagrupa apenas o arquivo `file1`. Se não informar, desagrupa tudo.

**Compactando** (são **3** opções principais: `gzip`, `bzip2` e `xz`):

#### gzip

- `gzip backup.tar`: cria o arquivo `backup.tar.gz`, mas exclui o arquivo de origem, `backup.tar` (para manter, use o `-k` ou `--keep`)
- `gunzip backup.tar.gz`: descompacta, ou seja, volta o arquivo ser `backup.tar` e exclui o arquivo original, `backup.tar.gz` (para manter o arquivo, use `-k` ou `--keep`)
- `gzip -d backup.tar.gz` ou `--decompress`, `uncompress`: faz o mesmo que o comando anterior.

#### bzip2

- `bzip2 -k backup.tar`: cria o arquivo `backup.tar.bz2` mantendo (`-k`) o arquivo `backup.tar`
- `bunzip2 backup.tar.bz2`: descompacta
- `bzip2 -d backup.tar.bz2` ou `--decompress`: também descompacta
    - para manter o arquivo, use o `-k` ou `--keep`

#### xz

- `xz -k backup.tar`: compacta e cria o arquivo `backup.tar.xz`, mantendo (`-k`) o arquivo `backup.tar`
- `unxz backup.tar.bz2`: descompacta
- `xz -d backup.tar.bz2` ou `--decompress`: também descompacta
    - para manter o arquivo, use o `-k` ou `--keep`
---

#### Resumo
| compactar  | descompactar  | descompactar  |
|---|---|---|
| gzip  | gunzip  | gzip -d  |
| bzip2  | bunzip2  | bzip2 -d  |
| xz  | unxz  | xz -d  |

#### uso mais comum no dia a dia

É interessante quando for compactar, empacotar e compactar usando o mesmo comando:

- `tar -cvpf backup.tar novo*`: comando já visto que empacota tudo que começa com `novo` e termina com qualquer coisa, no arquivo `backup.tar`. A depender do algoritmo de compressão, mude o seguinte:
    - `tar -zcvpf backup.tgz novo*` ou `--gzip`, `--gunzip`, `--ungzip`: empacota e compactar com `gzip`
    - `tar -jcvpf backup.tbz novo*` ou `--bzip2`: empacota e compactar com `bzip2`
    - `tar -Jcvpf backup.txz novo*` ou `--xz`: empacota e compactar com `xz`

Para extrair, precisa apenas substituir o `-c` por `-x`, que vem de "extract".

| gzip  | bzip2  | xz  |
|---|---|---|
| z | j | J |

>[!NOTE]
>
>O `gzip` é mais rápido, mas geralmente compacta um pouco menos, de modo que o arquivo obtido é um pouco maior. O `bzip2` é mais lento, mas comprime um pouco mais, então o arquivo fica um pouco menor. Em geral, porém, `gzip` e `bzip2` são praticamente a mesma coisa; ambos funcionam de forma semelhante.

>[!NOTE]
>
>É interessante renomear usando o padrão acima, `.tgz` para `gzip`. `.tbz` para `bzip2` e `.txz` para `xz`

>[!TIP]
>
>Para saber como os arquivos foram comprimidos, use o comando `file`

**Descompactando**:

Vamos considerar os arquivos que foram diretamente compactados, do último exemplo:

- `tar zxvf backup.tgz`: descompacta o arquivo `backup.tgz` oriundo do algoritmo `gzip`.
    - importante notar o `x` (pode ser `--extract` ou `--get` também). O `z` é referente ao algoritmo, igual na compactação.
- `tar jxvf backup.tbz`: descompacta usando `bzip2`
    - `j`=bzip2
- `tar Jxvf backup.txz`: descompacta usando `xz`
    - `J`=xz
---

#### cpio, dd (agrupar e compactar arquivos também)

- `cpio`: é um agrupador/empacotador, que recebe uma lista de arquivos (geralmente pelo comando `find` ou `ls`) e cria um agrupamento (significa “copy in, copy out”)
- **agrupar**: `find ./ -name "novo*" | cpio -o > backup.cpio` (pode usar `-o` ou `--create`): cria um arquivo de backup chamado `backup.cpio` com os arquivos listados com o comando `find`
- **desagrupar**: `cpio -i < backup.cpio` (`-i` ou `--extract`). Pode ser necessário usar a opção `-d`, `--make-directories`, caso dê erro de criação de diretórios.

Mesmo jeito com `ls`:
- `ls | cpio -o > archive.cpio`: a opção `-o` instrui o cpio a criar uma saída. Neste caso, o arquivo de saída criado é `archive.cpio`. O comando `ls` lista o conteúdo do diretório atual que será empacotado.
- `cpio -id < archive.cpio`: a opção `-i` é usada para realizar a extração. A opção `-d` cria a pasta de destino. O caractere `<` representa a entrada padrão. O arquivo de entrada a ser extraído é `archive.cpio`
<br>

- **compactar**: `find ./ -name "novo*" | cpio -o | gzip > backup.cpio.gz`: agrupa e compacta.
- **descompactar**: `gunzip -c | cpio -i` (`-c`, `--stdout` ou `--to-stdout`): descompacta e desagrupa
---

- `dd`: usado para copiar uma partição inteira. Sendo copiar uma partição inteira para outra partição, para um arquivo ou realizar o contrário (imagem para partição) - sintaxe: `dd if=oldfile of=newfile`
    - `if=`: é o arquivo de entrada
    - `of=` refere-se ao arquivo de saída.
- `dd if=/dev/sr0 of=imagem.img`: copia e cria uma imagem do que tiver no CD-ROM para o arquivo `imagem.img` (pode copiar para outra partição)

>[!NOTE]
>
>O comando `dd` normalmente não exibe nada na tela até que o comando seja concluído. Ao fornecer a opção `status=progress`, o console exibe o andamento do trabalho realizado pelo comando. Por exemplo: `dd status=progress if=oldfile of=newfile.`
---

### 103.4 Usando fluxos, pipes e redirecionamentos

#### Redirecionamentos entrada/saida/erro, | (pipe)

`STDIN (0)` => Program => `STDOUT (1)` Sucesso ou `STDERR (2)` Erro

- `STDIN (0)` entrada (geralmente teclado)
- `STDOUT (1)` saída sucesso (geralmente monitor)
- `STDERR (2)` saída erro (geralmente monitor)

Os canais de comunicação também são acessíveis por meio dos dispositivos especiais `/dev/stdin`, `/dev/stdout` e `/dev/stderr`

---

#### operador >

Esse operador redireciona a saída padrão. Normalmente a saída padrão será a **tela**. No entanto se quiser mudar essa saída, usa `>`, para redirecionar para um arquivo, por exemplo.

---

#### redirecionando saída (sucesso)

- `ls`: a saída vai para tela
- `ls > saida_ls.out`: a saída é redirecionada para um arquivo (não aparece nada na tela)

>[!NOTE]
>
>Se usar apenas `>` em um arquivo com conteúdo, vai apagar o conteúdo e escrever a saída do comando executado. Para não apagar, usar `>>`, que vai concatenando (append) com o conteúdo que já tiver.

>[!IMPORTANT]
>
>Na realidade quando usamos `>` ou `>>`, estamos fazendo implicitamente `1>` ou `1>>`, que no caso significa `STDOUT (1)`. Se quiser pode usar `1>` ou `1>>` normalmente, mas lembrar que **pode ser omitido** sem problemas.

---

#### redirecionando saída (erro)

Caso tente `ls -l /tmp/arquivo_inexistente` e realmente o arquivo `arquivo_inexistente` não existir, vai retornar uma mensagem de erro.

Se tentar redirecionar para um arquivo, como em `ls -l /tmp/arquivo_inexistente > saida_erro_ls.out`, o arquivo ficará em branco, e o erro vai continuar usando a saída do monitor.

Para redirecionar saída de erro `STDERR (2)`, temos que usar: `ls -l /tmp/arquivo_inexistente 2> saida_erro_ls.out`. Podemos usar `2>>` também. Aqui já não é possível omitir o número, tem que colocar `2>` ou `2>>`.

---

#### redirecionamento saída (sucesso e erro)

Agora supomos que no diretório atual tenha o arquivo `Aula3` apenas, e ao executar `ls -l {Aula,AULA}3`, que em tese tenta listar `Aula3` e `AULA3`. No entanto sabemos que `AULA3` não existe, retornando uma saída de **sucesso** e uma de **erro**:
```
$ ls -l {Aula,AULA}3
ls: cannot access 'AULA3': No such file or directory
-rw-rw-r-- 1 rodrigo rodrigo 0 Jan  9 20:07 Aula3
```

Para que seja possível redirecionar o sucesso e o erro, usamos: `ls -l {Aula,AULA}3 > saida_sucesso.out 2> saida_erro.out` (cada saída irá para seu respectivo arquivo)

É possível ainda redirecionar tanto sucesso como erro em um único arquivo, usando: `ls -l {Aula,AULA}3 > saida.out 2>&1`

**Observação importante**: Supõe que temos um arquivo com os nomes dos alunos, chamado `alunos.txt`. Então desejamos ordenar os nomes, usando o comando `sort`, dessa forma: `sort alunos.txt > alunos.txt`, a ordenação vai funcionar?

É importante destacar que ao usar `> alunos.txt`, o shell entende esse comando como a criação do arquivo `alunos.txt`, logo ele vem zerado de informação (0 bytes). Depois que o shell vai se preocupar com a ordenação, mas como já criou o arquivo `alunos.txt` "vazio" (que inclusive sobrescrever o arquivo `alunos.txt` original), não há mais o que ordenar. Logo, realizar o comando `sort alunos.txt > alunos.txt`, acaba que perdendo os dados, e é preciso tomar muita cautela com execução de comando assim.

Os arquivos são substituídos pelos redirecionamentos de saída, a menos que a opção `noclobber` esteja habilitada no Bash, o que pode ser feito para a sessão atual com o comando `set -o noclobber` ou `set -C`:

```
$ set -o noclobber
$ cat /proc/cpu_info 2>/tmp/error.txt
-bash: /tmp/error.txt: cannot overwrite existing file
```

Para remover a opção noclobber da sessão atual, execute set `+o` noclobber ou set `+C`. Para tornar a opção noclobber persistente, ela deve ser incluída no perfil Bash do usuário ou no perfil de todo o sistema.

O correto é realizar esse comando para um arquivo temporário, e posteriormente copiar para o arquivo original (ou simplesmente renomear)

---

#### redirecionar a entrada

Em situação mais corriqueira, usaríamos:
- `cat alunos.txt | tr 'a-z' 'A-Z'`: deixa tudo com letra maiúscula (redireciona a saída do comando `cat` para `tr` - conhecido como canalização)
- `tr 'a-z' 'A-Z' < alunos.txt`: joga `alunos.txt` como entrada para o comando `tr`

Como o valor numérico do descritor de arquivo redirecionado foi suprimido, o comando de exemplo é equivalente a `tr 'a-z' 'A-Z' 0< alunos.txt`

O uso de um descritor de arquivo diferente de `0` em um redirecionamento de entrada só faz sentido em determinados contextos, porque um programa pode possivelmente solicitar dados dos descritores `3`, `4`, etc. De fato, os programas podem usar qualquer número inteiro maior que `2` como novos descritores de arquivo para entrada/saída de dados.

---

#### tee, xargs, subcomandos

- `tee`: usado para situações que queira jogar a saída padrão para um arquivo e na tela, ao mesmo tempo.

Em situação para jogar a saída padrão para apenas um arquivo, usaríamos: `ls -l /tmp > arquivo`. Mas caso queira que também a saída padrão seja na tela (além do arquivo), use: `ls -l /tmp | tee arquivo`.

- `grep 'model name' </proc/cpuinfo | uniq | tee -a cpu_model.txt`: o `-a` ou `--append` do comando `tee` funciona como o operador `>>`, para evitar que o que foi redirecionado sobrescreva o arquivo

---

- `xargs`: usado para construir e executar comandos a partir de entrada padrão ou de arquivos. É especialmente útil quando precisa passar uma grande quantidade de argumentos para um comando (quando não for possível passar esses argumentos de forma direta)

Exemplo: `echo "file1 file2 file3" | xargs rm`, o que equivale a `rm file1 file2 file3`

Outro exemplo com uso do comando `find`:
```
$ find /home -name "Aula3*" | xargs ls -l
-rw-rw-r-- 1 lpi1 lpi1 0 Jan  9 19:14 /home/lpi1/Aula3
-rw-rw-r-- 1 lpi1 lpi1 0 Jan  9 19:14 /home/lpi1/Aula30
```

Removendo os arquivos que o `find` encontra:
```
find /home -name "Aula1*" | xargs rm -r
```

>[!NOTE]
>
>Pode ser desnecessário usar o `xargs` com a opção `-n 1` ou `-L 1` para processar a saída gerada pelo `find`. O comando `find` tem a opção `-exec` para executar um comando determinado para cada item do resultado da busca.

---

Há também a possibilidade de redirecionar comando com **crase** e **cifrão**, sendo uma possibilidade de inserir comando dentro de comando.
```
# com crase
$ echo "A versão do kernel é: " `uname -r`

#com cifrão
$ echo "A versão do kernel é: " $(uname -r)
```

#### redirecionador `<<` (Here Document) e `<<<` (Here String)

O `<<` é usado quando você deseja inserir um conteúdo interativamente, até que informe seu fim. Por exemplo:
```
$ tr a-z A-Z << final
> Curso Preparatorio para Certificacao
> lpic-1
> final
CURSO PREPARATORIO PARA CERTIFICACAO
LPIC-1
```

>[!NOTE]
>
>Veja que a string "final" (pode ser qualquer string) vai informar ao shell que a entrada termina naquele ponto, e então ele irá enviar essa entrada ao comando `tr`.

O outro redirecionador é o `<<<`, que é chamado de **here string**. Ele simplesmente redireciona o que o segue como se fosse o conteúdo de um arquivo texto. Por exemplo:
```
$ tr a-z A-Z < teste.txt 
bash: teste.txt: Arquivo ou diretório não encontrado
 
$ tr a-z A-Z <<< teste.txt 
TESTE.TXT
```

#### Exercício interessante
1. Em vez de abrir uma nova sessão remota do shell, o comando `ssh` pode simplesmente executar um comando indicado como argumento: `ssh user@storage "remote command"`. Dado que `ssh` também permite redirecionar a saída padrão de um programa local para a entrada padrão do programa remoto, como o comando `cat` canalizaria um arquivo local chamado `etc.tar.gz` para `/srv/backup/etc.tar.gz` em `user@storage` através de ssh?
```
$ cat etc.tar.gz | ssh user@storage "cat > /srv/backup/etc.tar.gz"
```
ou
```
$ ssh user@storage "cat > /srv/backup/etc.tar.gz" < etc.tar.gz
```

---

### 103.5 Criar, monitorar e eliminar processos

#### processos, ps, pstree, pgrep

Tudo que é executado, como scripts, bash, etc são processos. Cada processo é identificado pelo seu PID (Process ID)

PPID (Parent Process ID), é o processo pai (quando executamos um processo a partir do bash - sentido de hierarquia)

O primeiro processo iniciado pelo linux é o `init`, que vai receber o PID `1`

#### ps

Usado para ver os processos em execução no linux. Ele deriva de vários ambientes (Unix, BSD, GNU), e olhando no seu `man` é possível notar que (isso faz o `ps` ser um dos comandos com mais opções no linux):
- **UNIX**: são precedidos de `-`
- **BSD**: não possuem nada precedido, **SEM** o `-`
- **GNU**: opções longas, que são precedidos de `--`

Exemplo (pesquisar os processos iniciados por um usuário determinado):

```
ps U carol (BSD)
ps -u carol (UNIX)
ps --user carol (GNU)
```

- `ps`: mostra os processos que estão em execução do usuário corrente, no terminal em que está executando o comando `ps`
- `ps -u` (pode usar também `ps -u usuario`): modo de exibição de usuário (mostra mais opções), sendo as colunas:
    - **USER**: usuário que iniciou o processo (proprietário do processo)
    - **PID**: é o identificador único do processo no sistema (usado para comandos como kill para encerrar processos)
    - **%CPU**: percentual de uso da CPU pelo processo
    - **%MEM**: percentual de uso da Memória física pelo processo
    - **VSZ**: Tamanho virtual do processo (em kilobytes)
    - **RSS**: Memória residente usada pelo processo (em kilobytes) - Memória física não trocada usada pelo processo em KiB.
    - **TTY**: `Terminal Type ou TT`: O terminal associado ao processo. Um terminal físico ou virtual (como `pts/0`, que representa uma conexão remota via `SSH`). Se o processo não estiver associado a nenhum terminal, pode aparecer como `?`
    - **STAT**: código que representa o estado do processo. Além de `S`, `R` e `Z` (que vimos ao descrever a saída de `top`), outros valores possíveis seriam: `D` (dormente sem interrupção - geralmente esperando por `I/O`), `T` (interrompido - normalmente por um sinal de controle). Alguns modificadores extras incluem: `<` (prioridade maior que o convencional), `N` (prioridade menor que o convencional), ou `+` (no grupo de processos em primeiro plano).
    - **START** ou **STARTED**: horário que processo foi iniciado
    - **TIME**: indica o tempo total de CPU usado pelo processo, somando todo o tempo que o processo esteve em execução
    - **COMMAND**: o nome ou comando que iniciou o processo. Pode ser abreviado se for muito longo

- `ps -u usuario -f`: (`-f` é de full-format listing): lista parecido com `ps -u`, mas inclui algumas novas colunas, conforme exemplo de saída para explicar as colunas:
```
UID        PID  PPID  C STIME TTY          TIME CMD
joao     12345     1  0 10:00 pts/0    00:00:02 bash
joao     12346 12345  1 10:01 pts/0    00:00:01 top
joao     12347 12345  0 10:02 pts/0    00:00:00 ps

```
- **UID**: o usuário que iniciou o processo (`joao` neste caso).
- **PPID (Parent Process ID)**: o `PID` do processo pai. Por exemplo, `12345` iniciou `top` (`PPID` é o `PID` do `bash`)
- **C**: Percentual de CPU usado pelo processo (não confundir com `%CPU` de `ps aux`).
- **STIME**: Hora de início do processo

- `ps -u -x`: mostra processos que não foram iniciados pelo terminal `TTY` ou `pts` (só do usuário corrente) 
    - (`x`:Lift  the  BSD-style  "must have a tty" restriction, which is imposed upon the set of all processes when some BSD-style (without "-") options are used or when the ps personality setting is BSD-like. The set of processes selected in this manner is in addition to the  set  of  processes  selected  by  other means. An  alternate description is that this option causes ps to list all processes owned by you (same EUID as ps), or to list all processes when used together with the a option.)

- `ps -axu`: mostra processos de todos os usuário (inclusive root)
    - `a`: mostra processos que estão vinculados a um `tty` ou terminal.
    - `u`: exibe formato orientado ao usuário.
    - `x: mostra processos que não estão vinculados a um `tty` ou terminal.
- `ps -axuf`: o `-f` mostra em formato mais parecido de árvore (mostrando qual processo é filho de qual processo, etc)
- `ps u -C vBoxClient`: restringe ao processo `vBoxClient` que está rodando no usuário corrente (como se fosse um filtro, traz o processo pai e seus filhos - interessante rodar com `f` para ver a árvore dos processos)

#### pstree

Mostra os processos em formato de árvore, seguindo a hierarquia de execução dos processos.

- `pstree`: mostra os processos em formato de árvore.
- `pstree -p` ou `--show-pids`: mostra a árvore e o `PID` dos processos.

>[!NOTE]
>
>Note que com esse comando de mostrar os processos, o processo número 1 está com o `systemd`, que é um outro padrão adotado no linux que substitui o `init`, para gerenciar processos. Entretanto ele apenas aponta para o outro.

#### pgrep

Mostra os IDs dos processos de acordo com os parâmetros fornecidos:

- `pgrep bash`: mostra o ID do processo `bash`. Pode confirmar que realmente é esse ID com o comando `ps axu | grep ID_PROCESSO` (conforme os usuários logarem, vai abrindo novos processos `bash`, que o `pgrep` irá listar)
- `pgrep bash -u root`: retorna o ID do processo `bash` que o usuário `root` está usando.

>[!NOTE]
>
>Pode-se usar o comando `pidof`. Tem o mesmo efeito de `pgrep`. Exemplo: `pidof firefox`

Para fazer com que `kill` funcione de forma semelhante a `pkill` ou `killall` (evitando os comandos para descobrir os PIDs correspondentes), podemos usar a substituição de comandos:
```
$ kill -1 $(pgrep sleep)
```
Como você já deve saber, uma sintaxe alternativa é <code>kill -1 \`pgrep sleep\`</code>

>[!TIP]
>
>Para uma lista exaustiva de todos os sinais de `kill` e seus códigos, digite `kill -l` no terminal. Use `-KILL` (`-9` ou `-s KILL`) para eliminar processos rebeldes quando todos os outros sinais falharem.

#### top

Por padrão, a saída é classificada pela porcentagem de tempo da CPU usada por cada processo em ordem decrescente

- `load avarage`: seria a fila para processos serem executados no linux
    - considerando um computador com uma CPU, um valor bom é abaixo de `1`. A partir de `1` precisa ser analisado.
    - um computador com `4` CPUs, o normal seria ir até `4` (aceitável)

- `load average: 0,12, 0,06, 0,01`: respectivamente significa:  
    - **média do último minuto**; 
    - **média dos últimos 5 minutos**; 
    - **média dos últimos 15 minutos**.

- `M`: classifica por uso da **memória**
- `N`: classifica pelo **número ID** do processo
- `P`: classifica por **porcentagem** de uso da CPU
- `T`: classifica por **tempo** de execução

>[!TIP]
>
>Para alternar entre a ordem crescente/decrescente, basta pressionar `R`.

- `u`: abre caixa de diálogo para digitar o usuário desejado para listar os processos (por padrão, são mostrados os processos de todos os usuários).
- `r`: muda prioridade de algum processo (`renice`). `top` pede o valor de `nice` (Os valores possíveis variam de `-20` a `19`, mas apenas o superusuário (root) pode definir um valor negativo ou inferior ao atual.)
- `n`: abre caixa de diálogo para digitar quantidade desejada para listar os processos
- `k`: abre caixa de diálogo perguntando qual processo (PID) deseja enviar sinal de encerrar (por padrão, `SIGTERM` ou `15`)
- `c`:mostra os caminhos absolutos dos programas e diferencia os processos do espaço do usuário dos processos do espaço do kernel (entre colchetes).
- `V`:visão de floresta/hierárquica dos processos.
- `t` e `m`: mudam a aparência das leituras da CPU e da memória, respectivamente, em um ciclo de **quatro estágios**:   
    - os **dois primeiros** pressionamentos mostram barras de progresso
    - o **terceiro** oculta a barra
    - e o **quarto** a traz de volta.
- `W`: salva as definições de configuração em `~/.toprc`
- `?` ou `h`: mostra mais opções do comando `top`
<br>

>[!TIP]
>
>Uma versão mais sofisticada e amigável de `top` é `htop`. Outra alternativa, talvez mais exaustiva, é `atop`. Se ainda não estiverem instalados em seu sistema, use seu gerenciador de pacotes para instalá-los e experimentá-los.

- `top -b` ou `--batch`: batch mode, apenas joga a informação na tela (como um screenshot, para redirecionar para um arquivo, por exemplo)
- `top -b -d3` ou `--delay`: faz a tela atualizar a cada 3 segundos
- `top -b -d3 -n3` ou `--iterations`: faz a tela atualizar a cada 3 segundos, com 3 atualizações (`-n` ou `--iterations` - isso é útil para jogar para um arquivo)
    - exemplo: `top -b -d2 -n5 > processo.out`: a cada 2 segundos, por 5 vezes, joga os processos no arquivo `processo.out`

#### Explicação da saída de top

A saída de `top` é dividida em **duas áreas**: a área de **resumo** e a área de **tarefas**.

#### A área de resumo em `top`

A área de resumo é composta pelas **cinco linhas superiores** e nos fornece as seguintes informações:
```
top - 11:10:29 up 2:21, 1 user, load average: 0,11, 0,20, 0,14
```
- hora atual (em formato de 24 horas): `11:20:29`
- tempo de atividade (há quanto tempo o sistema está ativo e funcionando): `up 2:21`
- número de usuários logados e carga média da CPU nos últimos 1, 5 e 15 minutos, respectivamente: `load average: 0,11, 0,20, 0,14`
```
Tasks: 73 total, 1 running, 72 sleeping, 0 stopped, 0 zombie 
```
(informações sobre os processos)
- número total de processos em modo ativo: `73 total`
- em execução (os que estão sendo executados): `1 running`
em espera (os que estão esperando para retomar a execução): `72 sleeping`
- interrompidos (por um sinal de controle do trabalho): `0 stopped`
- zumbi (os que concluíram a execução mas ainda estão esperando que o processo pai os remova da tabela de processos): `0 zombie`
```
%Cpu(s): 0,0 us, 0,3 sy, 0,0 ni, 99,7 id, 0,0 wa, 0,0 hi, 0,0 
si, 0,0 st
```
(porcentagem de tempo da CPU gasto em:)
- processos de usuário: `0,0 us`
- processos do sistema/kernel: `0,4 sy`
- processos com um valor nice configurado — quanto mais alto o valor nice, menor a prioridade: `0,0 ni`
- nada — tempo ocioso da CPU: `99,7 id`
- processos aguardando operações de I/O: `0,0 wa`
- processos atendendo interrupções de hardware — periféricos enviando ao processador sinais que precisam de atenção: `0,0 hi`
- processos atendendo interrupções de software: `0,0 si`
- processos atendendo tarefas de outras máquinas virtuais em um ambiente virtual, e que portanto roubam tempo: `0,0 st`
```
- KiB Mem : 1020332 total, 909492 free, 38796 used, 72044 buff/cache
```
(informações da memória em kilobytes)
- quantidade total de memória: `1020332 total`
- memória não utilizada: `909492 free`
- memória em uso: `38796 used`
- memória armazenada em buffer e em cache para evitar acesso excessivo ao disco: `72044 buff/cache`

Note como o `total` é a soma dos outros três valores — `free`, `used` e `buff/cache` - (aproximadamente 1 GB em nosso caso).
```
- KiB Swap: 1046524 total, 1046524 free, 0 used. 873264 avail Mem 
```
(informações de troca em kilobytes)
- quantidade total de espaço de troca: `1046524 total`
- espaço de troca não utilizado: `1046524 free`
- espaço de troca em uso: `0 used`
- quantidade de memória de troca que pode ser alocada a processos sem causar mais trocas: `873264 avail Mem`

#### A área de tarefas em `top`: Campos e colunas

Abaixo da área de resumo fica a área de tarefas, que inclui uma série de campos e colunas que informam sobre os processos em execução:

- `PID`: Identificador do processo.
- `USER`: Usuário emissor do comando que originou o processo
- `PR`: Prioridade de processo para o kernel.
- `NI`: Valor nice do processo. Os valores mais baixos têm mais prioridade que os valores altos.
- `VIRT`: Quantidade total de memória usada por processo (incluindo Troca).
- `RES`: Memória RAM usada por processo.
- `SHR`: Memória compartilhada do processo com outros processos.
- `S`: Status do processo. Os valores incluem: `S` (suspensão interrompível — esperando que um evento termine), `R` (executável — em execução ou na fila para ser executado) ou `Z` (zumbi — processos filhos encerrados cujas estruturas de dados ainda não foram removidas da tabela de processos).
- `%CPU`: Porcentagem de CPU usada pelo processo.
- `%MEM`: Porcentagem de RAM utilizada pelo processo, ou seja, o valor de RES expresso em porcentagem.
- `TIME+`: Tempo total de atividade do processo.
- `COMMAND`: Nome do comando/programa que gerou o processo.

---

<a id="kill"></a>
#### kill, killall, pkill

Normalmente os processos monitoram sinais (mensagens) que são enviados pelo kernel ou pelos usuários

- `kill`: geralmente é associado a matar processos, no entanto o correto é dizer que é um comando usado para enviar sinais a um processo. (no `man kill` já diz: send a signal to a process - normalmente é o sinal de encerrar o processo, mas as vezes pode ser usado outros tipos de sinais)
- `kill -l` ou `--list`: mostra todos os sinais que pode-se enviar para um processo (**64 tipos de sinais**). Dependendo da forma que o processo foi desenvolvido, ele pode não aceitar algum sinal.
    - pode usar o ID do sinal ou o nome dele. Ex. `ID 15` é o `SIGTERM`, já o `ID 9` é o `SIGKILL`. O `SIG` pode ser omitido, ficando apenas `TERM` ou `KILL`

#### Princiais sinais

- `SIGHUP` ou `ID 1`: pode terminar ou reiniciar um processo ou ainda fazer com que o processo releia suas configurações.
- `SIGINT` ou `ID 2`: interrompe um processo (esse é quando usamos o `CTRL+C`, que envia um `SIGINTERRUPT`)
    - normalmente quando usa `CTRL+C` ou `CTRL+D`, é na realidade enviado um sinal ao processo
- `SIGQUIT` ou `ID 3`: encerra/fecha/para o processo
- `SIGKILL` ou `ID 9`: mata abruptamente um processo. É o único sinal que o processo não pode ignorar.
- `SIGTERM` ou `ID 15`: solicita que o processo finalize (termina sessões ativas e encerra). Vem de `TERMINATION`, e é o **PADRÃO** do `kill`. Ex. `kill 223`: encerra o processo `223` mandando o sinal `SIGTERM` por padrão.

#### uso do kill

Primeiro é preciso achar o PID do processo que quer encerra. Por exemplo, vamos simular que seja o Firefox. 

Para encontrar use: `ps axu | grep firefox` ou `pgrep firefox`:

```
$ ps axu | grep firefox
lpi1   104105  4.3  3.5 20911036 574184 ?     Sl   18:12   3:47 /usr/lib/firefox/firefox

$ pgrep firefox
104105
```

- `kill 104105` equivale a `kill -s 15 104105` ou ainda a `kill -s SIGTERM 104105` ou (`--signal`): envia o sinal para encerrar o firefox, de forma soft (`SIGTERM`, `ID 15`). Digite `pgrep firefox` para confirmar.
    - o `-s` pode ser omitido, ficando: `kill -15 104105`
    - para a descrição do sinal também: `kill -SIGTERM 104105`
- `kill -s 9 104105`: encerra o firefox com `SIGKILL` (`ID 9`)

#### killall

Se por um lado o `kill` encerra os processos baseado no **PID**, o `killall` encerra os processos baseado no **nome**.

- `killall firefox`: encerra todos os processos que tiver com o nome firefox no linux (que o usuário que está executando seja dono - não é possível encerrar o processo de outro usuário, a não ser que seja root).
- `killall ssh`: encerra todos processos relacionados ao ssh

#### pkill

Assim como há o `pgrep`, que encontra o `PID` baseado no **nome**, o `pkill` funciona da mesma forma, ou seja, encontra o **processo** e o **encerra**.

- `pkill firefox`: encerra o firefox (internamente faz a busca pelo PID do firefox e encerra - se não especificar o sinal, manda o padrão `-15`)
- `pkill -1 firefox -u lpi1` ou `--euid`, `euid`: envia o sinal `1` a para  o firefox apenas do usuário `lpi1` (normalmente usado como root, para encerrar processos dos usuários)

#### Exercícios interessantes

1. `oneko` é um programa divertido que mostra um gato perseguindo o cursor do mouse. Se ele ainda não estiver instalado em seu sistema desktop, instale-o usando o gerenciador de pacotes de sua distribuição. Vamos usá-lo para estudar o controle de jobs.

Inicie o programa. Qual o procedimento?<br>
Resporta: Digitar `oneko` no terminal.

Mova o cursor do mouse para ver como o gato o persegue. Agora suspenda o processo. Qual o procedimento? Qual é a saída?
Resposta: pressionar a combinação de teclas `Ctrl+z`:
```
[1]+  Stopped                 oneko
```
Verifique quantos jobs estão presentes atualmente. O que você digita? Qual é a saída?
Resposta:
```
$ jobs
[1]+  Stopped                 oneko
```

Agora envie-o para o segundo plano especificando seu ID de trabalho. Qual é a saída? Como você pode saber se o job está sendo executado em segundo plano?
Resposta:
```
$ bg %1
[1]+ oneko &
```
O gato está se movendo outra vez.

Finalmente, encerre o job especificando seu ID de trabalho. O que você digita?<br>
Resposta: `$ kill %1`

2. O sinal `SIGHUP` pode ser usado como forma de reiniciar certos daemons. Com o servidor web Apache HTTPD - por exemplo - enviar `SIGHUP` para o processo pai (iniciado por init) elimina seus filhos. O pai, no entanto, relê seus arquivos de configuração, reabre os arquivos de log e gera um novo conjunto de filhos. Execute as seguintes tarefas:

Inicie o servidor web:
```
$ sudo systemctl start apache2
```

Certifique-se de conhecer o `PID` do processo pai:
```
$ ps auxf | grep apache2
root      159528  0.0  0.0   6804  4832 ?        Ss   19:59   0:00 /usr/sbin/apache2 -k start
www-data  159530  0.0  0.0 1999328 5352 ?        Sl   19:59   0:00  \_ /usr/sbin/apache2 -k start
www-data  159531  0.0  0.0 1999400 6376 ?        Sl   19:59   0:00  \_ /usr/sbin/apache2 -k start
```

O processo pai é aquele iniciado pelo usuário root. Em nosso caso, o `PID` é `159528`.

Faça o servidor web Apache HTTPD reiniciar enviando o sinal `SIGHUP` para o processo pai:
```
$ kill -SIGHUP 159528
```

Verifique se o pai não foi eliminado e se novos filhos foram gerados:
```
$ ps auxf | grep apache2
root      159528  0.0  0.0   6804  5344 ?        Ss   19:59   0:00 /usr/sbin/apache2 -k start
www-data  159988  0.0  0.0 1999444 5240 ?        Sl   20:00   0:00  \_ /usr/sbin/apache2 -k start
www-data  159989  0.0  0.0 1999444 5496 ?        Sl   20:00   0:00  \_ /usr/sbin/apache2 -k start
```
Agora você deve ver o processo pai apache2 junto com dois novos filhos.

3. Como vimos, por padrão, `top` classifica as tarefas por porcentagem de uso da CPU em ordem decrescente (com os valores mais altos no topo). Esse comportamento pode ser modificado com as teclas interativas `M` (uso de memória), `N` (identificador único do processo), `T` (tempo de execução) e `P` (porcentagem de tempo de CPU). No entanto, também podemos classificar a lista de tarefas a gosto, iniciando `top` com a opção `-o` (para saber mais, verifique a página man de `top`). Agora, execute as seguintes tarefas:

Inicie o `top` para que as tarefas sejam classificadas por uso da memória:
```
$ top -o %MEM
```
Verifique se digitou o comando correto destacando a coluna da memória:<br>
Pressione `x`.

- `-o`, `--sort-override` = `FIELDNAME`: specifies the name of the field on which tasks will be sorted, independent of what is reflected in the configuration file.

4.  `ps` também tem uma opção `o` para especificar as colunas que você deseja mostrar. Estude esta opção e execute as seguintes tarefas:

Inicie o `ps` para exibir somente informações sobre o usuário, porcentagem de memória usada, porcentagem de tempo da CPU usado e comando completo:
```
$ ps o user,%mem,%cpu,cmd
```
Agora, inicie o `ps` para que as únicas informações exibida sejam o usuário e o nome dos programas que ele está usando:
```
$ ps o user,comm
```

---

#### uptime, free, screen

- `uptime`: mostra a quanto tempo o computador está ativo, a hora atual do sistema, quanto usuários estão logados e o load average.

---

- `free`: mostra a quantidade de **memória** e **swap** utilizada pelo sistema.
- `free -m`: uso mais comum, pois só o `free` mostra em kylobytes, com `-m` ou `--mebi` mostra em mebibytes (`--mega` mostra em megabytes)
    - assim como `-g` ou `--gibi` que mostra em gibibytes ou `--giga` para mostrar em gigabytes

**Observação importante**: o campo **used** é importante frisar que o linux assumiu a quantidade mostrada e irá usar essa memória quando precisar (não necessariamente que toda essa memória está em uso). Tomar cuidado quando a memória em swap estiver bastante em uso, pois aí significa que a memória principal já foi toda usada.

---

<a id="screen"></a>
#### screen (multiplexadores de terminal)

Em eletrônica, um multiplexador (ou mux) é um dispositivo que permite que várias entradas sejam conectadas a uma única saída.

Nos primórdios do Unix (anos 1970-80), os computadores consistiam basicamente em terminais conectados a um computador central. Era só isso mesmo, sem um monte de janelas ou abas. E essa foi a razão por trás da criação do GNU Screen em 1987: emular múltiplas telas VT100 independentes em um único terminal físico.

- `screen` (`apt install screen`): gerenciar e trabalhar em várias abas (só `screen` entra no modo de abas)
    - `screen` é útil para trabalhar com `ssh`, para evitar de criar múltiplas conexões.

<br>

- `CTRL + a `: modo para aceitar comandos (sempre antes dos comandos, teremos que digitar `CTRL + a`)

<br>

Os comandos a seguir são depois de apertar `CTRL + a` (modo de comando):

- `w`: mostra as janelas (enumeradas) na parte inferior
- `c`: de create, cria nova aba (digite `w` para ver como enumerou outra janela - observe o **asterisco** que indica a que está sendo exibida no momento)
- `A`: renomeia as janelas (antes as duas se chamavam `bash`)
- `screen -t nova-janela`: cria uma nova janela com o nome `nova-janela`

#### movendo entre janelas

- `n`: next em inglês, vai para a próxima janela
- `p`: previous em inglês, vai para a janela anterior
- `"`: lista as janelas para escolha

>[!TIP]
>
>Usando `Ctrl + a` e o `número` da janela (ir para a janela número número). Observer o asterisco para saber em qual janela está.

Ao trabalhar com janelas, é importante lembrar o seguinte:

- As janelas executam seus programas de forma totalmente independente umas das outras.
- Os programas continuarão a ser executados mesmo que suas janelas não estejam visíveis (inclusive quando a sessão de screen for desanexada, como veremos em breve).

Para **remover uma janela**, basta encerrar o programa que está em execução nela (quando a última janela for removida, o próprio screen será encerrado). Outra alternativa é usar `Ctrl`+`a`-`k` enquanto estiver na janela que deseja remover; será solicitada a confirmação:
```
Really kill this window [y/n]
Window 0 (bash) killed.
```

#### dividindo a tela (regiões)

- `S`: divide a tela horizontalmente
- `|`: divide a tela verticalmente

A única coisa que a nova região mostrará é -- na parte inferior, o que significa que está vazia:
```
   1 ps                                                               --
```

- `Tab`: muda de região (pode usar também por número de janela)
- `Q`: encerra todas as regiões, exceto a atual
- `X`: encerra a região atual (O encerramento de uma região não encerra a janela associada a ela)

#### sessões screen

Até agora vimos algumas janelas e regiões, mas todas pertencentes à mesma e única sessão. É hora de começar a ver as sessões. Para ver uma lista de todas as sessões, digite `screen -list` ou `screen -ls`:
```
There is a screen on:
        179522.pts-0.PC-Rodrigo      (01/15/2025 20:15:58 PM)        (Attached)
1 Socket in /run/screen/S-rodrigo
```
- onde `179522` é o `PID`
- `pts-0.PC-Rodrigo` é o nome (indicando o terminal, sendo nesse caso um *pseudo-terminal escravo* + nome do host)
- `Attached` é o status

Para criar um nova sessão: `screen -S "segunda sessao"`
```
$ screen -list 
There are screens on:
        181111.segunda sessao   (01/15/2025 20:39:31 PM)        (Attached)
        179522.pts-0.PC-Rodrigo      (01/15/2025 20:15:58 PM)        (Attached)
2 Sockets in /run/screen/S-rodrigo.
```

Para encerrar uma sessão, saia de todas as janelas ou simplesmente digite o comando `screen -S SESSION-PID -X quit` (também é possível fornecer o nome da sessão). Vamos nos livrar de nossa primeira sessão:
```
$ screen -S 179522 -X quit
```

Você será enviado de volta ao prompt do terminal fora de `screen`. Mas lembre-se, nossa segunda sessão ainda está viva
```
$ screen -list
There is a screen on:
	181111.segunda sessao	(01/15/2025 08:39:31 PM)	(Detached)
1 Socket in /run/screen/S-rodrigo
```

No entanto, como eliminamos a sessão pai, ela recebe um novo rótulo: `Detached` (desanexada).

#### Desanexando sessões

Por uma série de razões, podemos querer desanexar uma sessão do screen do terminal a que pertence:

- Para deixar o computador da empresa cumprir seu dever e conectar-se remotamente mais tarde, de casa.
- Para compartilhar uma sessão com outros usuários.

- `d`: Detach (sai da sessão atual do screen - **NÃO** encerra as abas - para sair precisa alternar para a aba que não está em uso)
```
detached from 181111.segunda sessao]
```

Para entrar novamente na sessão desanexada, use o comando `screen -r SESSION-PID`. Outra alternativa é `SESSION-NAME`, como vimos acima. Se houver apenas uma sessão desanexada, nenhuma dessas opções é obrigatória:
```
$ screen -r
```

Este comando basta para anexar novamente a segunda sessão:
```
$ screen -ls
There is a screen on:
        181111.segunda sessao   (01/15/2025 20:39:32 PM)        (Attached)
1 Socket in /run/screen/S-rodrigo.
```

Para fechar a janela é só digitar `exit`

- `screen top`: vai iniciar o screen com o `top`

#### Opções importantes para reanexar sessões:

- `-d` `-r`: reanexa uma sessão e — se necessário — a desanexa primeiro.
- `-d` `-R`: igual a `-d` `-r`, mas o screen cria primeiro uma sessão caso ela não exista.
- `-d` `-RR`: igual a `-d` `-R`. No entanto, usa a primeira sessão se houver mais de uma disponível.
- `-D` `-r`: reanexa uma sessão. Se necessário, o comando a desanexa e faz logout remotamente primeiro.
- `-D` `-R`: se uma sessão estiver rodando, ela é reanexada (desanexando e desconectando remotamente primeiro, caso necessário). Se não for o caso, ela é criada e o usuário, notificado.
- `-D` `-RR`: igual a `-D` `-R` — só que mais poderoso.
- `-d` `-m`: inicia o screen em modo `detached` (desanexado). Uma nova sessão é criada, mas desanexada. Útil para scripts de inicialização do sistema.
- `-D` `-m`: igual a `-d` `-m`, mas não bifurca um novo processo. O comando é encerrado se a sessão terminar.

#### Copiar e colar: Modo de rolagem

O GNU Screen apresenta um modo de cópia ou modo de rolagem. Dentro dele, você pode mover o cursor na janela atual e através do conteúdo de seu histórico usando as setas do teclado. Você pode marcar o texto e copiá-lo nas janelas. As etapas a seguir são:

1. Entre no modo de cópia/rolagem: `Ctrl+a-[`.
2. Vá para o início da parte do texto que deseja copiar usando as setas do teclado.
3. Marque o início do trecho de texto que deseja copiar: `Espaço`.
4. Vá para o final da parte do texto que deseja copiar usando as setas do teclado.
5. Marque o final do trecho de texto que deseja copiar: `Espaço`.
6. Vá para a janela de sua escolha e cole o texto: `Ctrl+a-]`.

#### Personalização de screen

O arquivo de configuração de todo o sistema para screen é `/etc/screenrc`. Também é possível usar `~/.screenrc` no nível do usuário. O arquivo inclui quatro seções de configuração principais:

- `SCREEN SETTINGS`: Você pode definir configurações gerais especificando a diretiva seguida por um espaço e o valor, como em: `defscrollback 1024`.
- `SCREEN KEYBINDINGS`: esta seção é bastante interessante, pois permite redefinir os atalhos de teclado que podem interferir no seu uso diário do terminal. Use a palavra-chave `bind` seguida por um espaço, o caractere a ser usado após o prefixo do comando, outro espaço e o comando, como em: `bind l kill` (esta configuração mudará a forma padrão de eliminar uma janela para `Ctrl`+`a`-`l`).

Para exibir todos os atalhos de screen, digite `Ctrl`+`a`-`?` ou consulte a página de manual.

>[!TIP]
>
>Claro, você também pode alterar o próprio prefixo do comando. Por exemplo, para ir de `Ctrl`+`a` a `Ctrl`+`b`, basta adicionar esta linha: `escape ^Bb`.

- `TERMINAL SETTINGS`: Esta seção inclui as configurações relacionadas aos tamanhos de janela de terminal e buffers — entre outros. Para habilitar o modo sem bloqueio para lidar melhor com conexões SSH instáveis, por exemplo, a seguinte configuração é usada: `defnonblock 5`.
- `STARTUP SCREENS`: Podemos incluir comandos para que diversos programas sejam executados após a inicialização de `screen`; por exemplo `screen -t top top` (o screen abre uma janela chamada `top` com `top` dentro dela).



>[!NOTE]
>
>`screen` é similar ao [tmux](#tmux)

---

#### jobs, bg, fg, nohup

#### foreground
- supõe o seguinte comando no terminal: `$ firefox`: vai abrir o firefox, mas vai ficar "preso" ao terminal (processo em `foreground`). Assim que fechar o firefox, o terminal é liberado

#### background
- `firefox &` (só colocar `&` no final) executa o firefox em `background` (processo em `background`), vai listar:
```
[1]   2477
```
Onde `[1]` é a tarefa (*task*) ou job do processo, e `2477` é o PID (o processo fica desassociado do terminal).

#### jobs

Jobs (trabalhos) são processos iniciados de forma interativa através de um terminal, enviados para o segundo plano e ainda não finalizados.

- `jobs`: mostra as tarefas (*task*) que estão executando em `background`
- `jobs -l`: mostra o PID também (assim como também mostra o *status*):
```
[1]+ 2477 Running
```

- `jobs -n`: lista apenas os processos que mudaram de status desde a última notificação. Os possíveis status incluem `Running`, `Stopped`, `Terminated` ou `Done`:
- `jobs -p`: lista os IDs do processo.
- `jobs -r`: lista apenas os jobs em execução.
- `jobs s`: lista apenas os jobs interrompidos (ou suspensos). 

>[!NOTE]
>
>Lembre-se, um job tem um `ID` de trabalho e um `ID` de processo (`PID`).

#### situação interessante

Se abrirmos o `gnome-calculator` no terminal, vai abrir a calculadora e "travar" (ou ficar "preso") o terminal.

No terminal, aperte `CTRL+Z` e será enviado um sinal para o processo da calculadora ficar em `stopped` (`SIGSTOP` ou sinal `19`).

É possível ver com o comando `jobs -l` que realmente o processo da culculadora está em `stopped`.

Procure a calculadora em modo gráfico, e ela estará "congelada".

No terminal, se digitarmos `bg`, vai ser colocado em brackground o **último processo que trabalhamos**, no caso, a calculadora. Voltando nela no modo gráfico, ela voltará a funcionar normalmente.

Se digitarmos `fg`, vai ser pego o **último processo que trabalhamos** (ainda a calculadora) e esse será colocado em `foreground` ("prende" o terminal)

Caso tenhamos mais de um job (*task*) rodando, para colocar em `background` ou `foreground`, usamos o **número** do job (*task*)

Exemplo:
```
[1]- 2477 Running       firefox &
[2]+ 2604 Stopped       gnome-calculator
```

- `bg 2`: colocamos em `background` o job (*task*) `2`. Note o sinal de `+` na task `2`, isso significa que é o último processo trabalhado (para rodar diretamente `fg` ou `bg`)

>[!NOTE]
>
>Lembrando que só `bg` ou `fg` (sem especificar número), vai pegar o último processo para por em `background` ou `foreground`

Para encerrar o processo, usamos o `kill` normalmente: `fill 2477` (encerra o firefox). Depois se digitarmos `jobs -l`, teremos a saída:
```
[1]- Terminated         firefox
```

Agora encerrar a calculadora: `kill -9 2604`. Rode novamente `jobs -l`:
```
[2]+ Killed         gnome-calculador
```

Repare que de acordo com o sinal enviado, `jobs -l` retorna o `SIG` usado para encerrar o processo.

---

#### nohup

Quando acessamos por ssh, e a conexão cai, o shell envia um sinal de `SIGHUP` para os programas abertos naquela sessão, para evitar isso, usamos o `nohup`.

O `nohup` faz com que os programas abertos por ele, ignorem o sinal de `HUP` (o `nohup` não aceita sinal `HUP`)

É possível desvincular jobs de sessões e executá-los mesmo após o encerramento da sessão. Isso é feito com o comando nohup (“no hangup”). A sintaxe é a seguinte:

```
nohup COMMAND &
```

Lembre-se, o `&` envia o processo para o segundo plano e libera o terminal em que estamos trabalhando

>[!NOTE]
>
>O único sinal que não pode ser evitado é o `9` (`SIGKILL`). Os demais podem

- `nohup firefox &`: poderia ser qualquer programa ou script.

Um exemplo bom de uso, mostrado no site da lpi.org:

Vamos desvincular o job em segundo plano ping localhost da sessão atual:
```
$ nohup ping localhost &
[1] 1251
$ nohup: ignoring input and appending output to 'nohup.out'
^C
```

A saída mostra o ID do trabalho (`[1]`) e o PID (`1251`), seguido por uma mensagem nos informando sobre o arquivo `nohup.out`. Este é o arquivo padrão no qual **stdout** e **stderr** serão salvos. Agora podemos pressionar `Ctrl+C` para liberar o prompt de comando, fechar a sessão, iniciar outra como `root` e usar `tail -f` para verificar se o comando está rodando e a saída está sendo escrita no arquivo padrão:
```
$ exit
logout
$ tail -f /home/carol/nohup.out
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.070 ms
64 bytes from localhost (::1): icmp_seq=4 ttl=64 time=0.068 ms
64 bytes from localhost (::1): icmp_seq=5 ttl=64 time=0.070 ms
^C
```

Com isso, não importa se feche o terminal, o comando continuará executando, até o que encerre com comando `kill`, por exemplo.

>[!TIP]
>
>Em vez de usar o `nohup.out` padrão, poderíamos ter especificado um arquivo de saída à escolha com `nohup ping localhost > /path/to/your/file &`.

Se quisermos encerrar o processo, devemos especificar seu PID:
```
# kill 1251
```

---

#### watch, tmux

- `watch`: executa um programa periodicamente, mostrando a saída na tela (execute a program periodically, showing output fullscreen)
- `watch date`: executa `date` a cada 2 segundos (padrão: 2 segundos)
- `watch "ps axu | grep firefox"`: fica monitorando os processos de firefox (de 2 em 2 segundos)
- `watch -n6 free -h`: executa o comando `free -h` a cada 6 segundos (pode usar `--interval` ou `-n`)

---

<a id="tmux"></a>
#### tmux (terminal multiplexer)

- `tmux` (`apt install tmux`): controle de vários terminais em uma sessão/conexão apenas (similar ao [screen](#screen))

O tmux foi lançado em 2007. Embora muito semelhante ao `screen`, ele apresenta algumas diferenças notáveis:

- Modelo cliente-servidor: o servidor fornece uma série de sessões, cada uma das quais pode ter várias janelas anexadas a ele que podem, por sua vez, ser compartilhadas por vários clientes.
- Seleção interativa de sessões, janelas e clientes via menus.
- A mesma janela pode ser anexada a várias sessões.

Disponibilidade de atalhos do vim e do Emacs.
- Suporte para terminal UTF-8 e 256 cores.

O comando `tmux` entra no modo de janelas (nome da janela fica no rodapé)
```
[0] 0:bash*                                                        "debian" 18:53 27-Aug-19
```
Além do `hostname`, a `hora e a data`, a barra de status fornece as seguintes informações:
- Nome da sessão: [0]
- Número da janela: 0:
- Nome da janela: `bash*`. Por padrão, esse é o nome do programa em execução dentro da janela e — ao contrário de `screen` — o `tmux` irá atualizá-lo automaticamente para refletir o programa em execução atual. Observe o **asterisco** indicando que esta é a janela atual em exibição

Você pode atribuir nomes de sessão e janela ao invocar tmux:
```
$ tmux new -s "LPI" -n "Window zero"
```

A barra de status será alterada de acordo:
```
[LPI] 0:Window zero*                                                 "debian" 19:01 27-Aug-19
```

- `CTRL + B`: modo de comandos:
    - `c`: cria nova janela/aba (vai listar no rodapé, acrescentando um número ordinal referente a cada janela)
    - `,` (vírgula): renomeia ma janela (lembrar que precisa apertar `CTRL + B` antes)
    - `p` (previous): volta uma janela
    - `n` (next): vai para a próxima janela (olhar no asterisco `*` que aparece nos números de cada janela - no caso com asterisco é a janela corrente)
    - `l` (last): vai para última janela que estava anteriormente
    - `1-9`: vai de acordo com o número (`CTRL + B ` antes e o número da janela desejada)
    - `w`: lista as janelas que tem, basta escolher e apertar `Enter`
    - `x` ou `&`: close current pane, ou usa `exit`
    - `f`: encontra uma janela pelo nome
    - `.`: altera o número do índice da janela

#### painéis (dividir o terminal)

A facilidade de divisão de janelas do `screen` também está presente no `tmux`. As divisões resultantes não são chamadas de regiões, mas de painéis. A diferença mais importante entre regiões e painéis é que os últimos são pseudoterminais completos anexados a uma janela. Isso significa que eliminar um painel também eliminará seu pseudo-terminal e todos os programas associados em execução nele.

- `%`: abre o painel vertical (divide a tela com 2 terminais/janelas, uma na esquerda e outra na direita)
    - se repetir o comando anterior, vai dividir o painel corrente. Ex. caso esteja no painel da direita, vão ficar paines com 50% de tamanho na esqueda, e dois paineis com 25% de tamanho cada.
- `"`: abre o painel horizontal (mesmo esquema do vertical).

Para destruir o painel atual (junto com o pseudoterminal rodando dentro dele e quaisquer programas associados), use `Ctrl`+`b`-`x`. Será solicitada a confirmação na barra de status:
```
kill-pane 1? (y/n)
```

#### Comandos importantes dos painéis:

- `Ctrl`+`b`-`↑`,`↓`,`←`,`→`: mover-se entre painéis.
- `Ctrl`+`b`-`;`: passar para o último painel ativo.
- `Ctrl`+`b`-`Ctrl`+`seta`: redimensionar o painel em uma linha.
- `Ctrl`+`b`-`Alt`+`seta`: redimensionar o painel em cinco linhas.
- `Ctrl`+`b`-`{`: trocar de painel (do atual para o anterior).
- `Ctrl`+`b`-`}`: trocar de painel (do atual para o seguinte).
- `Ctrl`+`b`-`z`: aproximar/afastar o painel.
- `Ctrl`+`b`-`t`: O `tmux` exibe um relógio elegante dentro do painel (para removê-lo, pressione `q`).
- `Ctrl`+`b`-`!`: transforma o painel em janela.
- `o`: vai para o próximo painel
- `;`: alterna entre os paineis

Segurando `CTRL + B` e usando as setas do teclado, recimenciona os paineis

#### sessões tmux

Para listar as sessões no tmux, você pode usar `Ctrl`+`b`-`s`:
```
(0) + LPI: 2 windows (attached)
```
Outra alternativa é usar o comando `tmux ls`:
```
$ tmux ls
LPI: 2 windows (created Tue Aug 27 19:01:49 2019) [158x39] (attached)
```
Existe apenas uma sessão (`LPI`) que inclui duas janelas. Vamos criar uma nova sessão de dentro de nossa sessão atual. Isso pode ser feito usando `Ctrl`+`b`. Digite `:new` no prompt e pressione Enter. Você será enviado para a nova sessão, conforme pode ser observado na barra de status:
```
[2] 0:bash*                                                       "debian" 19:15 27-Aug-19
```
Por padrão, o `tmux` denomina a sessão `2`. Para renomeá-la, use `Ctrl`+`b`-`$`. Quando solicitado, informe o novo nome e pressione Enter:
```
(rename-session) Second Session
```
Para trocar de sessão, o atalho é `Ctrl`+`b`-`s` (use as setas do teclado e `enter`):
```
(0) + LPI: 2 windows
(1) + Second Session: 1 windows (attached)
```
Para eliminar uma sessão, você pode usar o comando tmux kill-session -t SESSION-NAME. Se digitar o comando de dentro da sessão atual anexada, você será retirado do tmux e levado de volta à sua sessão de terminal inicial:
```
$ tmux kill-session -t "Second Session"
[exited]
$
```

#### desanexando sessões (detach)

Ao eliminar `Second Session`, fomos levados para fora do `tmux`. No entanto, ainda temos uma sessão ativa. Peça ao `tmux` uma lista de sessões e você certamente a encontrará ali:
```
$ tmux ls
LPI: 2 windows (created Tue Aug 27 19:01:49 2019) [158x39]
```
No entanto, esta sessão está desanexada de seu terminal. Podemos anexá-la com `tmux attach -t SESSION-NAME` (`attach` pode ser substituído por `at` ou — simplesmente — `a`). Quando há apenas uma sessão, a especificação do nome é opcional:
```
$ tmux a
```
Agora você está de volta à sua sessão; para desanexá-la, pressione `Ctrl`+`b`-`d`:
```
[detached (from session LPI)]
$
```
>[!TIP]
>
>A mesma sessão pode ser anexada a mais de um terminal. Se quiser anexar uma sessão e ter certeza de que ela foi primeiramente desanexada de quaisquer outros terminais, use a opção `-d`: `tmux attach -d -t SESSION-NAME`.

- `Ctrl`+`b`-`D`: seleciona o cliente a desanexar.
- `Ctrl`+`b`-`r`: atualiza o terminal do cliente.

- `tmux ls`ou `tmux list-sessions`: mostra as sessões criadas. Mesmo fechando o terminal e abrindo novamente, vai continuar as sessões.

Exemplo de como é mostrado: `0: 3 windows (createad Fri Jan 15:37:06 2019)`. Sendo o `0` o número de sessão

Para se conectar novamente (na conexão `0`): `tmux attach -t 0`

- `tmux new -s nome_conexao`: nova conexão
- `tmux kill-session -t 0`: encerra conexão. Pode usar o nome da conexão em vez do número

É possível compartilhar o terminal com `tmux`: abra uma sessão `tmux` normalmente, abra outro terminal e conecta na mesma sessão `tmux`. Com isso, tudo que faz em um terminal, reflete no outro.

#### Copiar e colar: Modo de rolagem

O `tmux` também possui um modo de cópia, basicamente igual ao do `screen` (lembre-se de usar o prefixo de comando do tmux e não o de screen!). A única diferença em termos de comando é que usamos `Ctrl` + `Espaço` para marcar o início da seleção e `Alt`+`w` para copiar o texto selecionado.

#### Personalização do tmux

Os arquivos de configuração do `tmux` tipicamente se localizam em `/etc/tmux.conf` and `~/.tmux.conf`. Quando iniciado, o `tmux` procura por esses arquivos, se eles existirem. Também existe a possibilidade de iniciar o `tmux` com a opção `-f` para fornecer um arquivo de configuração alternativo. Um exemplo de arquivo de configuração do `tmux` pode ser encontrado em `/usr/share/doc/tmux/example_tmux.conf`. O nível de personalização é altíssimo. Eis algumas das coisas que é possível fazer:

- Alterar a tecla de prefixo
```
# Change the prefix key to C-a
set -g prefix C-a
unbind C-b
bind C-a send-prefix
```
- Definir atalhos de teclado extras para janelas superiores a 9
```
# Some extra key bindings to select higher numbered windows
bind F1 selectw -t:10
bind F2 selectw -t:11
bind F3 selectw -t:12
```

Para ver uma lista abrangente com todos os atalhos, digite `Ctrl`+`b`-`?` (pressione `q` para sair) ou consulte a página de manual.

---

### 103.6 Modificar prioridades de execução de processos

#### nice, renice

Internamente o linux tem um algoritmo de gerenciamento de processos, ele gerencia, durante a execução, quem vai ter prioridade a mais do que outro.

É possível ver essa informação com o comando `top` ou `ps -l`

No `top` tem as colunas `PR` e `NI`
- `PR`: prioridade que o linux determina em um dado momento para quem vai consumir mais memória e cpu
- `NI`: ou simplesmente `nice`: propriedade que permite o usuário ou administrador influenciar nessa prioridade.

O `NI` pode ser alterado pelo comando `nice` e `renice`
- `nice`: define o `nice` de um comando assim que o inicia
- `renice`: altera o `nice` de um processo que já está em execução

Os valores do `nice` podem ser definidos entre `-20` até `+19` (pense em um range `-20`-`+19`)

Lembrando que quanto menor o número (**negativo**), maior vai ser a prioridade. Consequentemente, quanto **maior** o número (**positivo**), **menor** será a prioridade (lembrar que são inversamente proporcionais)

O `nice` padrão é `0` (zero)

>[!NOTE]
>
>Apenas o `root` pode colocar um valor **negativo** em um processo. `Usuário comuns` só podem definir valor positivo, ou seja, **podem apenas diminuir** a prioridade de seus processos!

---

#### nice

Exemplo de como iniciar o firefox com prioridade 15 (diminuir a prioridade)
```
$ nice -n 15 firefox &
```
Pode usar `-n` ou `--adjustment`=`N`, ou omitir, usando `-15` diretamente

Agora no `top` é possível ver o firefox com prioridade `15`

Para abrir o `gnome-calculator` com prioridade `-15` (aumentar a prioridade) usamos (como root - lembre-se que apenas root pode ajustar prioridade negativa):
```
# nice -n -15 gnome-calculator &
```

>[!WARNING]
>
>Se for omitir o `-n` para valores negativos, use: `--15` (cuidado pois confunde bastante). Como já visto, poderia usar `--adjustment=-15`

Resumidamente a **calculadora** está com **mais prioridade** do que o **firefox**.

>[!NOTE]
>***********
>Caso o `nice` seja utilizado sem especificar valor, o valor atribuído é `10`
```
nice firefox &
```
Vai executar o firefox com prioridade `10`

Será padrão (`0` zero) quando aberto diretamente.

---

#### renice

O `renice` altera prioridade de processo já em execução.

Exemplo de sintaxe (abaixo veja alterando de `15` para `8` o `gnome-calculator`): `renice -n 8 <PID>`
```
# renice -n 8 193634
193634 (process ID) old priority 15, new priority 8
```

>[!WARNING]
>
>Caso queira omitir o `-n`, tomar cuidado pois omite tudo (é uma pequena diferença do `nice` para o `renice`). Veja abaixo o exemplo:

- `renice -7 <PID>`: para valores negativos
- `renice 7 <PID>`: para valores positivos

Mais exemplos:

- `renice -n 5 -u lpi1` ou `--user`: muda a prioridade de todos os processos do usuário `lpi1` para 5. Pode usar `-g` ou `--pgrp` para grupos.

>[!TIP]
>
>Além de `renice`, a prioridade dos processos pode ser modificada com outros programas, como `top`. No alto da tela principal, o valor nice de um processo pode ser modificado pressionando `r` e, em seguida, o número `PID` do processo. A mensagem `PID to renice [default pid = 1]` aparece, com o primeiro processo listado selecionado por padrão. Para alterar a prioridade de outro processo, digite o `PID` dele e pressione `Enter`. A mensagem `Renice PID 1 to value` será exibida (com o número `PID` solicitado) e um novo valor `nice` poderá ser atribuído.

#### Exercícios interessantes

1. A alteração da prioridades dos processos geralmente é necessária quando um processo está ocupando muito tempo da CPU. Usando `ps` com opções padrão para imprimir todos os processos do sistema em formato longo, qual sinalizador de `--sort` permite classificar os processos por utilização da CPU, em ordem crescente?
```
$ ps -el --sort=pcpu
```

2. O comando `schedtool` pode definir todos os parâmetros de agendamento da CPU de que o Linux é capaz ou exibir informações para determinados processos. Como ele pode ser usado para exibir os parâmetros de agendamento do processo `1750`? Além disso, como `schedtool` pode ser usado para alterar o processo `1750` para tempo real com prioridade -90 (conforme exibido por `top`)?
```
$ schedtool 1750
$ schedtool -R -p 89 1750
```
---

### 103.7 Pesquisar em arquivos de texto usando expressões regulares

#### grep, intro regex

Regex, Regular Expression (conteúdo/padrão de texto) é um conjunto de caracteres e metacaracteres que vai definir um padrão de texto (diferente de [file globbing](#fileglobbing), que é uma forma do shell identificar grupos de arquivos pelo nome)

Nas expressões regulares básicas, precisamos proteger os caracteres especiais.

#### grep

- `grep Linux texto.txt`: busca pela palavra `Linux` dentro do arquivo `texto.txt`. Se houver ocorrências, retorna a linha. Lembrar que `grep` é **case sensitive**.
- `grep -c Linux texto.txt` ou `--count`: retorna a quantidade de ocorrências ou quantas linhas achou o padrão pesquisado. Se usar com com o `-v` ou `--invert-match`, conta as linhas que não teve o padrão pesquisado
- `grep -c Linux *` (file globbing): pesquisa em todos os arquivos do diretório atual a quantidade de linhas que houve ocorrências com a palavra pesquisada. Lista os arquivos seguido de `:` com a quantidade:
```
$ grep -c Linux *
teste:0
saida:0
Aula3:2
texto.txt:3
```

- `grep -i Linux texto.txt` ou `--ignore-case`: mostra tanto `Linux` como `linux`. Ignora o case sensitive. Tomar cuidado com buscas muito grandes, pois é mais pesado pois fica testando as duas possibilidades (maiúsculo e minúsculo)
- `grep -r Linux t*`: procura por arquivos que começam com a letra `t` dentro dos diretórios que existem dentro da pasta atual.

No grep conseguimos usar regex avançado (expande as opções de padrão de expressões regulares) com: `egrep` ou `grep -E` ou `--extended-regexp`

Existe ainda o `fgrep`, que no caso **NÃO** aplica expressões regulares (considera tudo como texto apenas). Equivalente a `grep -F`

- `grep -v Linux texto.txt` ou `--invert-match`: mostra todas as linhas que a ocorrência `Linux` não seja satisfeita (mostra as linhas que **não** tenha `Linux`)

---

Mais opções do grep

- `-f` `FILE` ou `--file=FILE`: Indica um arquivo contendo a expressão regular a ser usada.
- `-n` ou `--line-number`: Mostra o número da linha.
- `-H` ou `--with-filename`: Mostra também o nome do arquivo que contém a linha.
- `-z` ou `--null-data`: Em vez de fazer com que o `grep` trate os fluxos de dados de entrada e saída como linhas separadas (usando newline por padrão), ele passa a encarar a entrada ou saída como uma sequência de linhas. Ao combinar a saída do comando `find` usando a opção `-print0` com o comando `grep`, a opção `-z` ou `--null-data` deve ser usada para processar o fluxo da mesma maneira.


---

#### intro regex, sed

Usando conchetes `[]`

- `egrep "b[aei]g" texto.txt`: busca por uma palavra que começe por `b`, e contenha ou `a` ou `e` ou `i` e termine com `g`
- ``egrep "b[a-u]g" texto.txt``: nos mesmos moldes do exemplo anterior, mas entre o `b` e o `g`, busca as letras de `a` até `u` (não apenas as vogais, mas todas as letras de `a` a `u`)

Começo (`^`) e final de linha (`$`)

- `egrep "^Linux" texto.txt`: busca pela palavra `Linux` toda vez que estiver no **começo da linha**.
- `egrep "Linux$" texto.txt`: busca pela palavra `Linux` toda vez que estiver no **final da linha**.
- `egrep "^#" /etc/ssh/sshd_config`: mostra todos os comentários do arquivo em questão
- `egrep -v "^#" /etc/ssh/sshd_config`: mostra todas as linhas que não possuem comentário - retira os comentários (pode usar `--invert-match`)
- `egrep "^$" texto.txt`: busca por linha em branco
- `egrep -v "^$" texto.txt`: exclui as linhas em branco

#### Uso do `*`

- `*`: Pode aparecer ou não, pode aparecer várias vezes (se usado para letras anterior, não precisa aparecer ou pode aparecer várias vezes).

Considere o arquivo `texto.txt` com o seguinte conteúdo:
```
O Xubuntu é baseado no Ubuntu
bag
beg
big
beginner
bigger
bege
bee
```

- `egrep "b[a-i]g*" texto.txt`: vai retornar:
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">bigg</b>er
<b style="color: red">beg</b>e
<b style="color: red">be</b>e
</pre>

Repare que **pode não** conter o `g` (<b style="color: red">ba</b>seado), e pode conter diversos `g` (<b style="color: red">bigg</b>er)

- `egrep "b[a-i]g*e" texto.txt`: vai retornar (aqui precisa ter um `e` depois do `*`):
<pre>
<b style="color: red">bigger</b>
<b style="color: red">bege</b>
<b style="color: red">bee</b>
</pre>

Como precisa ter um `e` após o asterisco e pode ou não ter o `g` antes do asterisco, retorna a saída acima.

#### Uso do `+`

- `+`: tem que ter ao menos 1 caracter. Pode aparecer várias vezes (se usado co letra anterior, precisa aparecer pelo menos 1 vez)

- `egrep "b[a-i]g+" texto.txt`: apenas a palavra `baseado`, da linha `Xubuntu é baseado no Ubuntu` que não vai aparecer, pois aqui exige o `g` pelo menos 1 vez. (`bee` também não vai aparecer pelo mesmo motivo)

<pre>
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">bigg</b>er
<b style="color: red">beg</b>e
</pre>

#### uso da `?`

- `?`: pode aparecer nenhuma ou só 1 vez.

- `egrep "b[a-i]g?" texto.txt`: mostra quando a letra `g` não aparece nenhuma vez ou apenas 1 vez. Tendo a saída:
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">big</b>ger
<b style="color: red">beg</b>e
<b style="color: red">be</b>e
</pre>

- `egrep "b[a-i]g?e" texto.txt` (incluindo `e` no final): mostra quando a letra `g` não aparece nenhuma vez ou apenas 1 vez e a letra `e` aparece imediatamente após.
<pre>
<b style="color: red">bege</b>
<b style="color: red">bee</b>
</pre>

### uso do `.`

- `.`: significa 1 único caracter (o espaço também é considerado um caracter).

Vamos fazer uma comparação:

- `egrep "b[a-i]g" texto.txt`: deixando padrão, sem nenhum quantificador, teremos a saída:
<pre>
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">big</b>ger
<b style="color: red">beg</b>e
</pre>

Agora incluindo o `.`

- `egrep "b[a-i]g." texto.txt`: repare que com o ponto, o qual exige que tenha um único caracter, exclui as palavras que não possuem letras depois do `g`
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu

<b style="color: red">begi</b>nner
<b style="color: red">bigg</b>er
<b style="color: red">bege</b>
</pre>

- `egrep "b[a-i]g..." texto.txt`: mostra a palavra que tem 3 letras (`...`) após o `g`:
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu

<b style="color: red">beginn</b>er
<b style="color: red">bigger</b>
</pre>

---

#### algumas diferenças entre `grep` e `egrep`

Nos exemplos a seguir, cosidere o arquivo `arquivo.txt` com o seguinte conteúdo:
```
ba{1,3}h
ba
baah
baaah
baaaah
```

- `grep 'ba{1,3}h' arquivo.txt`: vai listar apenas a primeira linha, pois usando apenas o `grep`, o retorno irá tratar as chaves apenas como um caracter normal, e não especial

<pre>
<b style="color: red">ba{1,3}h</b>
</pre>

Tratando chaves `{}` como caracter especial, teríamos um quantificador de vezes que determinada palavra vai aparecer.

Exemplo:

- `{1,3}`: determinado caracter vai aparecer de `1` até `3` vezes
- `{4}`: determinado caracter vai aparecer `4` vezes
- `ba{,4}`: agora como `a` está ao lado da chave, ele vai ser a referêcia, e no caso, a letra `a` vai aparecer no máximo 4 vezes
- `ba{4,}`: aqui o caracter `a` vai aparecer no mínimo 4 vezes até N vezes

No `grep` (antigo), temos que "proteger" as chaves para que funcione como expressão regular:
- `grep 'ba\{1,3\}h' arquivo.txt`: dessa forma, retorna:

<pre>
<b style="color: red">bah</b>
<b style="color: red">baah</b>
<b style="color: red">baaah</b>
</pre>

Agora usando `egrep` ou `grep -E`:

- `egrep 'ba{1,3}h' arquivo.txt`: temos o mesmo resultado do comando acima.
<pre>
<b style="color: red">bah</b>
<b style="color: red">baah</b>
<b style="color: red">baaah</b>
</pre>

#### Mais exemplos com quantificador `{}`

- `{i}`: O átomo deve aparecer exatamente `i` vezes (sendo `i` um número inteiro). Por exemplo, `[[:blank:]]{2}` corresponde a exatamente dois caracteres em branco.
- `{i,}`: O átomo deve aparecer pelo menos `i` vezes (sendo `i` um número inteiro). Por exemplo,`[[:blank:]]{2,}` corresponde a qualquer sequência de dois ou mais caracteres em branco.
- `{i,j}`: O átomo deve aparecer ao menos `i` vezes e no máximo `j` vezes (`i` e `j` sendo números inteiros, `j` maior que `i`). Por exemplo, `xyz{2,4}` corresponde à string `xy` seguida por dois a quatro caracteres `z`.

De toda forma, se uma substring corresponder a uma expressão regular e uma substring mais longa começando no mesmo ponto também corresponder, a substring mais longa será considerada.

As expressões regulares básicas também suportam chaves, mas elas devem ser precedidas por `\`, `\{` e `\}`. Sozinhas, `{` e `}` são interpretadas como caracteres literais. Uma `\{` seguida por um caractere diferente de um dígito é um caractere literal, não uma abertura de chave.

**Curiosidade**: caso proteja o caracter `{}` usando `egrep`, teremos o mesmo efeito de usar `grep` sem proteger `{}`:
<pre>
<b style="color: red">ba{1,3}h</b>
</pre>

Mais informações sobre regex: `man 7 regex`

#### caracter set (caracteres de representação)

- `.`: qualquer caracter
- `[]`: lista normal
    - As listas de expressão de colchetes também aceitam classes em vez de apenas caracteres únicos e intervalos. As classes de caracteres tradicionais são:

        - `[:alnum:]`: Representa um caractere alfanumérico.
        - `[:alpha:]`: Representa um caractere alfabético.
        - `[:ascii:]`: Representa um caractere que pertence ao conjunto de caracteres ASCII.
        - `[:blank:]`: Representa um caractere em branco, ou seja, um espaço ou tabulação.
        - `[:cntrl:]`:Representa um caractere de controle.
        - `[:digit:]` Representa um dígito (de 0 a 9).
        - `[:graph:]` Representa qualquer caractere imprimível, exceto espaço.
        - `[:lower:]` Representa um caractere em minúsculas.
        - `[:print:]` Representa qualquer caractere imprimível, incluindo espaço.
        - `[:punct:]` Representa qualquer caractere imprimível que não seja um espaço ou um caractere alfanumérico.
        - `[:space:]` Representa os caracteres de espaço em branco: espaço, alimentação de formulário (\f), nova linha (\n), retorno de carro (\r), tabulação horizontal (\t) e tabulação vertical (\v).
        - `[:upper:]` Representa uma letra maiúscula.
        - `[:xdigit:]` Representa dígitos hexadecimais (de 0 a F).
- `[^]`: lista negada

#### Quantificadores

- `?`: um caracter específico aparecer ou nenhuma vez
- `*`: pode ou não aparecer (quantas vezes for necessário)
- `+`: tem que ter ao menos um ou aparecer vários caracteres
- `{}`: define quantas vezes vai aparecer

#### Âncoras (Anchors)

- `^`: começo da linha
- `$`: final da linha
- `\b`: começo ou fim de uma palavra

Exemplo:
- `egrep '\bLinux\b' texto.txt`: retorna só a palavra `Linux` (se tivesse `Linux Ubuntu`, **NÃO** retornaria)

O `\b` considera letras, números e sublinhados (já não entenderia se houvesse hífen)

#### uso do operador ou `|`

Ideal para busca com dois ou mais termos

- `egrep 'bag|beg' texto.txt`: retorna:
<pre>
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">beg</b>inner
<b style="color: red">beg</b>e
</pre>

- `egrep '(bag|beg)inner' texto.txt`: `bag` ou `beg` + terminando com `inner`:
<pre>
<b style="color: red">beg</b>inner
</pre>

---

### 103.8 Edição básica de arquivos

#### vi e vim

- `vi /etc/fstab`: abre o arquivo `/etc/fstab`
- `vi +9 /etc/fstab`: abre o arquivo `/etc/fstab` e posiciona o cursor na 9ª linha (se usar só o `+`, vai diretamente para última linha)
- `~`: indica onde o arquivo termina
- `vi --version`: para verficiar se já é o Vi Improved, caso não seja, instalar `apt install vim`

#### Modo de Navegação
- `/` (semelhante ao `less`): busca no arquivo
    - `n`: próxima ocorrencia da busca
    - `N`: ocorrência anterior (de baixo para cima)
- `?`: modo de busca començando do final do arquivo
    - `n`: busca de baixo para cima
    - `N`: busca de cima para baixo
- `h`: caracter anterior ←
- `j`: linha de baixo ↓
- `k`: linha de cima ↑
- `l`: próximo caracter →

##### Copiar/Colar:
- `cc`: recorta a linha que o cursor estiver e entra no modo de `-- INSERT --`
    - se sair do modo de inserção, com `ESC`, aperte `p` (de paste) para colar o que foi recortado anteriormente com `cc`
- `dd`: recorta, mas **NÃO** entra no modo de edição
- `d3d`: recorta as três linhas que o cursor estiver (a própria que o cursor estiver + as duas seguintes)
    - `p`: cola o que foi recortado
- `yy`: copia a linha que estiver com o cursor.
    - `p`: cola o que foi copiado
- `y3y`: copia as três linhas que o cursor estiver (a própria que o cursor estiver + as duas seguintes)

#### Modo de Comando (ou Modo Normal)

Esse é o modo que o `vim` inicia por padrão.

Mais comuns no dia a dia (**Comandos de dois pontos**).

Os comandos de dois pontos permitem ao usuário realizar pesquisas, salvar, sair, executar comandos do shell, alterar as configurações do vi, etc. Para voltar ao modo normal, executamos o comando :visual ou pressionamos a tecla Enter sem qualquer comando

Comandos de dois pontos mais comuns:
- `:w`: salva e continua no arquivo
- `:q` ou `quit`: quit (se já estiver salvo, sai sem alertar nada)
- `:q!`: sai sem salvar
- `:wq`: salva e sai
- `x` ou `:e` ou `:exit`: salva e sai
- `ZZ`: salva e sai (sem os dois pontos `:`)
- `:! comando`: executa o `comando` no shell e volta para o `vi`
- `:s/REGEX/TEXT/g`: substituir todas as ocorrências da expressão regular `REGEX` por `TEXT` na linha atual. Ele aceita a mesma sintaxe do comando `sed`, incluindo endereços.
- `:visual`: volta ao modo de navegação

>[!TIP]
>
>Os usuários novatos podem ter dificuldade para memorizar todas as teclas de comando do `vi` de uma vez. As distribuições que adotam o vim também possuem o comando `vimtutor`, que usa o próprio `vim` para abrir um guia passo a passo das principais atividades. O arquivo é uma cópia editável que pode ser usada para praticar os comandos e se acostumar progressivamente com eles.

No modo de inserção (digitando a tecla `i` - mais comum)
- `o`: entra no modo `-- INSERT --` a partir da linha de **baixo**
- `O`: entra no modo `-- INSERT --` a partir da linha de **cima**
- `a`: entra no modo `-- INSERT --` a partir do **próximo caracter** que o cursor estiver
- `A`: entra no modo `-- INSERT --` no **final da linha** que o cursor estiver.
- `ESC`: sai do modo de inserção e vai para o modo de navegação

Mais comandos:
- `0, $`: Ir para o início e o fim da linha.
- `1G, G`: Ir para o início e o fim do documento.
- `(, )`: Ir para o início e o fim da frase.
- `{, }`: Ir para o início e o fim do parágrafo.
- `w, W`: Pular palavra e pular palavra incluindo a pontuação.
- `e or E`: Ir para o fim da palavra atual.
- `s, S`: Apagar o caractere sob o cursor ou a linha inteira e entrar no modo de inserção.
- `c`: Alterar o(s) caractere(s) sob o cursor.
- `r`: Substituir o caractere sob o cursor.
- `x`: Excluir os caracteres selecionados ou o caractere sob o cursor.
- `v, V`: Iniciar uma nova seleção com o caractere atual ou a linha inteira.
- `y, yy`: Copia (arranca) o(s) caracter(es) ou a linha inteira.
- `p, P`: Colar o conteúdo copiado, antes ou depois da posição atual.
- `u`: Desfazer a última ação.
- `Ctrl-R`: Refazer a última ação.
- `ZZ`: Fechar e salvar.
- `ZQ`: Fechar e não salvar.

##### Combinações de teclas

Se precedido por um número, o comando será executado o mesmo número de vezes. Por exemplo, pressione `3yy` para copiar a linha atual mais as duas seguintes, pressione `d5w` para deletar a palavra atual e as 4 palavras seguintes, e assim por diante.

A maioria das tarefas de edição são combinações de vários comandos. Por exemplo, a sequência de teclas `vey` é usada para copiar uma seleção começando na posição atual até o final da palavra atual. A repetição de comandos também pode ser usada em combinações, então v3ey copiaria uma seleção começando na posição atual até o final da terceira palavra a partir de lá.

O `vi` pode organizar o texto copiado em registros, permitindo manter conteúdos distintos ao mesmo tempo. Um registro é especificado por um caractere precedido por `"` e, uma vez criado, é mantido até o final da sessão atual. A seqüência de teclas `"ly` cria um registro contendo a seleção atual, que estará acessível através da tecla `l` . Então, o registro `l` pode ser colado com `"lp`.

>[!NOTE]
>
Se quiser saber mais sobre os outros modos de execução, abra o vi e digite: `:help vim-modes-intro`

#### mais sobre vi

Se digitar somente `vi`, abrimos o `vi`, mas sem arquivo definido. Se digitar qualquer coisa e tentar salvar, será emitido o alerta `E32: No file name` (mesmo que use `:wq!`, vai dar o mesmo erro). Nesse caso precisa salvar e dar um nome ao arquivo: `:w novo-arquivo.txt`

Se estivermos com um arquivo aberto, e em outro terminal executarmos `echo "teste" >> arquivo.txt`, ao voltar no `vi` que estamos editando o arquivo e tentarmos salvar, vai dar um *warning* `W11: Warning: The file "arquivo.txt" has been changed since editing started`. Se tenta salvar, vai alertar que o arquivo mudou desde a leitura, se deseja salvar:
- `y`: sobreescreve e ignora o outro processo
- `n`: continua na edição corrente
- `:e!` (`e` de `edit`): carrega a edição feita por outro processo. O `!` é apenas para quando houver alteração no arquivo, caso só venha o processo externo, basta usar `e` (lembrar, `e` de `edit`)

---

#### nano e emacs

#### nano

Os comandos no nano são dados usando a tecla `Ctrl` ou a tecla `Meta` (dependendo do sistema, `Meta` é `Alt` ou `⌘`).

Atalhos listados no site da lPI.org:
- `Ctrl-6` ou `Meta-A`: Iniciar uma nova seleção. Também é possível criar uma seleção pressionando Shift e movendo o cursor.
- `Meta-6`: Copiar a seleção atual.
- `Ctrl-K`: Cortar a seleção atual.
- `Ctrl-U`: Colar o conteúdo copiado.
- `Meta-U`: Desfazer.
- `Meta-E`: Refazer.
- `Ctrl-\`: Substituir o texto na seleção.
- `Ctrl-T`: Iniciar uma sessão de verificação ortográfica para o documento ou seleção atual.

Atalhos mostrados no curso:
- `^`: significa `Ctrl`
- `^Y`: previous page (paginando)
- `^V`: next page (paginando)
- `^_`: informa qual linha quer ir (pode ser linha e coluna)
- `^W`: pesquisa
- `^X`: sai
- `Alt /`: vai para o **final** do texto
- `Alt \`: vai para o **começo** do texto

---

#### emacs

O Emacs é outro editor de texto muito popular para o ambiente de shell. Ao passo que o texto é inserido com a digitação simples, como no `nano`, a navegação é auxiliada por comandos do teclado, como no vi. O Emacs inclui muitos recursos que o tornam mais do que apenas um editor de texto. Também é um IDE (ambiente de desenvolvimento integrado) capaz de compilar, executar e testar programas. O Emacs pode ser configurado como cliente de email, notícias ou RSS, tornando-o um verdadeiro pacote de produtividade.

Caso não tenha instalado, use `apt install emacs`

- `emacs arquivo.txt`: vai abrir com o emacs, no entanto se estiver usando interface gráfica, vai aparecer o emacs gráfico.

Temporariamente mude a variável de ambiente $DISPLAY para vazio: `export DISPLAY=`

- `CTRL + x`: habilita as opções (faça os demais seguido de `CTRL + x`)
    - `CTRL + c` sai do emacs
    - `CTRL + V` procura por arquivo (supõe que abriu só ele)
    - `CTRL + F` criar ou abrir um arquivo (após abrir, pode digitar o arquivo normalmente)
    - `CTRL + S` salvar sem perguntar nada (se usar só `S`, pergunta se deseja salvar)
    - `CTRL + W`: salvar como
    - `CTRL + K`: recorta a partir do cursor (diferente de `vi` que copia a linha toda)
    - `CTRL + /`: desfaz (um recorte, por exemplo - `undo`)
    - `CTRL + Y`: colar
    - `HOME/EDN`: começo ou final da linha
    - `CTRL + E/CTRL + A`: começo ou final da linha
    - `ALT + SHIFT + >/<`: começo/final do texto
    - `ALT + x`: muda o modo de interpretar o arquivo (como html, perl, etc)

---

#### definir o editor padrão

Há algumas situações que o Linux vai requerer que edite algum arquivo por meio de algum comando que chame o editor de texto, nesse caso o Linux vai chamar o editor padrão, como por exemplo: `crontab -e`, para editar o arquivo o cron em relação ao agendamento de tarefas.

- `select-editor`: abre opções para mudar o editor padrão (com o sinal de `<` é o padrão)

- `update-alternatives --config editor`: altera o `editor` (se chamar diretamente `editor`, também vai abrir o editor padrão): escolhe o editor padrão (precisa ser root)

É possível ainda alterar por meio da variável de ambiente `$EDITOR`: `export EDITOR=nano`, aceita `vim`, `emacs`, etc. (sobrescreve a configuração que está no `select-editor`)

Podemos usar também a variável de ambiente `$VISUAL`

Podemos ainda alterar o `~/.bash_rc` ou `~/.bash_profile` do user local, e no final do arquivo colocar: `export VISUAL=vim` (ou `EDITOR`)

---

#### exercícios interessantes site lpi.org

1. O `vi` é usado principalmente como editor de arquivos de configuração e código-fonte, onde a indentação ajuda a identificar seções de texto. Uma seleção pode ser recuada para a esquerda pressionando `<` e para a direita pressionando `>`. Quais teclas devem ser pressionadas no modo normal para recuar a seleção atual três passos para a esquerda?

**Resposta**: As teclas `3<`, que indicam três passos para a esquerda.

2. Uma linha inteira pode ser selecionada pressionando `V` no modo normal do `vi`. No entanto, o caractere de término da nova linha também será incluído. Quais teclas devem ser pressionadas no modo normal para selecionar a partir do caractere inicial até o caractere de nova linha, sem incluí-lo?

**Resposta**: As teclas `0v$h`, que significam `0` (“pular para o início de uma linha”), `v` (“iniciar a seleção de caracteres”), `$` (“ir ao final da linha”) e `h` (“voltar uma posição”).

3. Como o `vi` deve ser executado na linha de comando para abrir `~/.bash_profile` e pular direto para a última linha?

**Resposta**: O comando `vi + ~/.bash_profile` abre o arquivo e posiciona o cursor na última linha.

4. Quais teclas devem ser pressionadas no modo normal do `vi` para excluir caracteres desde a posição atual do cursor até o caractere de ponto final seguinte?

**Resposta**: As teclas `dt.`, que significam `d` (“iniciar a exclusão”), `t` (“pular para o próximo caractere”) and `.` (caractere de ponto final).

5. O `vim` permite selecionar blocos de texto com largura arbitrária, não apenas seções com linhas inteiras. Ao pressionar `Ctrl+V` no modo normal, uma seleção é feita movendo o cursor para cima, para baixo, para a esquerda e para a direita. Usando esse método, como excluir um bloco começando no primeiro caractere da linha atual, contendo as próximas oito colunas e cinco linhas de texto?

**Resposta**: A combinação `0`, `Ctrl-V` e `8l5jd` seleciona e remove o bloco correspondente.

6. Uma sessão do `vi` foi interrompida por uma falha de energia inesperada. Ao reabrir o arquivo, o `vi` pergunta ao usuário se deseja recuperar o arquivo de troca (uma cópia automática feita pelo `vi`). O que o usuário deve fazer para descartar o arquivo de troca?

**Resposta**: Pressionar `d` quando solicitado pelo `vi`.

7. Em uma sessão do `vim`, uma linha foi previamente copiada para o registro `l`. Qual combinação de teclas gravaria uma macro no registro `a` para colar a linha do registro `l` imediatamente antes da linha atual?

**Resposta**: A combinação `qa"lPq`, que significa `q` (“iniciar a gravação da macro”), `a` (“atribuir o registro a à macro”), `"l` (“selecionar o texto no registro `l`”), `P` (“colar antes da linha atual”) e `q` (“encerrar a gravação da macro”).

## 102-500

### 105.1 Personalizar e trabalhar no ambiente shell

Relembrando:
- `env` ou `printenv`: imprime uma lista de todas as variáveis de ambiente

- `printenv` ainda pode ser usado de forma semelhante ao comando `echo`:<br>

    $ echo $PWD
    /home/user2
    $ printenv PWD
    /home/user2
Note, entretanto, que com `printenv` o nome da variável não é precedido por `$`.

- `echo $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

>[!NOTE]
>
>Para remover variáveis definidas (locais ou globais), usamos o comando  `unset`:

    $ echo $reptile
    tortoise
    $ unset reptile
    $ echo $reptile
    $

>[!NOTE]
>
>`unset` deve ser seguido somente pelo nome da variável (não precedido pelo símbolo `$`)

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Para criarmos variáveis imutáveis, basta a deixarmos como **readonly** (somente leitura).<br>
Ex. `readonly reptile=tortoise`<br>
Ou transformá-las depois de criá-las:<br>

    reptile=tortoise
    readonly reptile

Agora, se tentarmos alterar o valor de  `reptile`, o Bash se recusará:

    $ reptile=lizard
    -bash: distro: readonly variable

>[!NOTE]
>
>Para listar todas as variáveis somente leitura da sessão atual, digite `readonly` ou `readonly -p` no terminal

Para que uma variável local do shell se torne uma variável de ambiente, usamos o comando  `export`:

    $ export reptile

Com  `export reptile`, transformamos nossa variável local em uma variável de ambiente para que os shells filhos possam reconhecê-la e usá-la:

    $ bash
    $ echo $reptile
    tortoise

Da mesma maneira,  `export`  pode ser usado para definir e exportar uma variável de uma só vez:

    $ export amphibian=frog

Agora podemos abrir uma nova instância do Bash e referenciar com sucesso a nova variável:

    $ bash
    $ echo $amphibian
    frog

>[!NOTE]
>
>Com `export -n <VARIABLE-NAME>`, a variável será novamente transformada em variável local do shell.

- `export` ou `export -p`: lista todas as variáveis de ambiente existentes. (`declare -x` é equivalente a `export`)

Comando `alias`: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente `alias`, é mostrado os alias cadastrados no bash atual.

- `unalias alias_criado`: remove o alias criado

Podemos escapar um alias com  `\`:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ \where?
    -bash: where?: command not found

O escape de um alias é útil quando um alias tem o mesmo nome de um comando regular. Nesse caso, o alias tem precedência sobre o comando original, que, no entanto, ainda pode ser acessado escapando-se o alias.

Da mesma forma, podemos colocar um alias dentro de outro alias:

    $ where?
    /home/user2
    $ alias my_home=where?
    $ my_home
    /home/user2

Além disso, também é possível colocar uma função dentro de um alias, como será demonstrado mais adiante.

#### Expansão e avaliação de aspas em aliases

Ao se usar aspas com variáveis de ambiente, as aspas simples tornam a **expansão dinâmica**:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2/Music

No entanto, com aspas duplas, a expansão é feita **estaticamente**:

    $ alias where?="echo $PWD"
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2

#### Persistência de aliases: scripts de inicialização

Como no caso das variáveis, para que nossos aliases se tornem persistentes devemos colocá-los em scripts de inicialização que são originados quando o sistema é iniciado. Como já sabemos, um bom arquivo para os usuários colocarem seus aliases pessoais é  `~/.bashrc`. Já deve haver alguns aliases por lá (a maioria deles comentados e prontos para uso, bastando remover o  `#`  inicial):

    $ grep alias .bashrc
    # enable color support of ls and also add handy aliases
        alias ls='ls --color=auto'
        #alias dir='dir --color=
        #alias vdir='vdir --color=
        #alias grep='grep --color=
        #alias fgrep='fgrep --color'
        #alias egrep='egrep --color=
    # some more ls aliases
    #ll='ls -al'
    #alias la='ls -A'
    #alias l='ls -CF'
    # ~/.bash_aliases, instead of adding them here directly.
    if [ -f ~/.bash_aliases ]; then
       . ~/.bash_aliases

Como podemos ver nas últimas três linhas, é possível ter nosso próprio arquivo dedicado aos aliases — `~/.bash_aliases` — para o  `.bashrc`  abrir e executar a cada inicialização do sistema. Ao escolher essa opção, criamos e preenchemos esse arquivo:

    ###########
    # .bash_aliases:
    # a file to be populated by the user's personal aliases (and sourced by ~/.bashrc).
    ###########
    alias git_info='which git;git --version'
    alias greet='echo Hello world!'
    alias ll='ls -al'
    alias where?='echo $PWD

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Como no caso das variáveis e aliases, se quisermos que as funções sejam persistentes durante as reinicializações do sistema, temos de colocá-las em scripts de inicialização do shell, como  `/etc/bash.bashrc`  (global) ou  `~/.bashrc`  (local).

>[!WARNING]
>
>Depois de adicionar aliases ou funções para qualquer arquivo de script de inicialização, é preciso executar  `.`  ou  `source`  nesses arquivos para que as alterações tenham efeito (caso você não queira fazer logout e login novamente ou reinicializar o sistema).

#### Variáveis integradas especiais do Bash

O  _Bourne Again Shell_  vem com um conjunto de variáveis especiais que são particularmente úteis para funções e scripts. Elas são especiais porque só podem ser referenciadas — e não atribuídas. Eis uma lista das mais relevantes:

- `$?`: a referência desta variável se expande para o resultado do último comando executado. Um valor de  `0`  significa sucesso:

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $?
    0

Um valor diferente de  `0`  significa erro:

    user1@debian:~$ ps aux |rep bash
    -bash: rep: command not found
    user1@debian:~$ echo $?
    127

- `$$`: expande-se para o PID do shell (ID do processo):

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $$
    420

- `$!`: expande-se para o PID do último trabalho em segundo plano:

    $ ps aux | grep bash &
    [1] 663
    $ user2      420  0.0  0.4  21156  5012 pts/0    Ss+  17:10   0:00 -bash
    user2      663  0.0  0.0  12784   972 pts/0    S    18:08   0:00 grep bash
    ^C
    [1]+  Done                   ps aux | grep bash
    $ echo $!
    663

>[NOTE]
>
>Lembre-se, o e comercial (`&`) é usado para iniciar processos em segundo plano.

#### Parâmetros posicionais  `$0`  a  `$9`

Expandem-se para os parâmetros ou argumentos que estão sendo passados para a função (alias ou script) — `$0`  se expande para o nome do script ou shell.

Um _parâmetro posicional_ é um parâmetro denotado por um ou mais dígitos diferentes do dígito único `0`. Por exemplo, a variável `$1` corresponde ao primeiro argumento dado ao script (parâmetro posicional um), `$2` corresponde ao segundo argumento e assim por diante. Se a posição de um parâmetro for maior que nove, ele deve ser referenciado com chaves, como em `${10}`, `${11}` etc.

Vamos criar uma função para demonstrar os parâmetros posicionais — note  `PS2`  (`>`) indicando novas linhas após as quebras de linha:

    $ special_vars() {
    > echo $0
    > echo $1
    > echo $2
    > echo $3
    }

Agora, vamos invocar a função (`special_vars`) passando três parâmetros para ela (`debian`,  `ubuntu`,  `zorin`):

    $ special_vars debian ubuntu zorin
    -bash
    debian
    ubuntu
    zorin

Tudo funcionou como esperado.

>[!WARNING]
>
>Embora seja tecnicamente possível passar parâmetros posicionais para aliases, não é lá muito prático, já que — com aliases — os parâmetros posicionais são sempre passados no final:

    $ alias great_editor='echo $1 is a great text editor'
    $ great_editor emacs
    is a great text editor emacs

#### Outras variáveis integradas especiais do Bash incluem:

- `$#`: expande-se para o número de argumentos passados para o comando.
- `$@`,  `$*`: expandem-se para os argumentos passados para o comando.
-`$_`:  expande-se para o último parâmetro ou o nome do script (dentre outras coisas; consulte  `man bash`  para saber mais!):

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada **ETCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

#### Variáveis

Pode conter letras (`a-z, A-Z`), números (`0-9`) e sublinhados (`_`). E não deve começar com um número para não confundir o Bash. Não deve conter espaços (nem mesmo entre aspas), por convenção, os sublinhados são usados no lugar dos espaços.

No que diz respeito à referência ou valor das variáveis, também é importante considerar uma série de regras. As variáveis podem conter quaisquer caracteres alfanuméricos (`a-z`,`A-Z`,`0-9`), além da maioria dos outros caracteres (`?`,`!`,`*`,`.`,`/`, etc.). Os valores das variáveis devem ser postos entre aspas se contiverem espaços simples.

Os valores das variáveis também devem ser postos entre aspas se contiverem caracteres como os usados para redirecionamento/canalização (`<`,`>`) ou o símbolo de barra vertical (`|`). A única coisa que o comando a seguir faz é criar um arquivo vazio chamado  `zorin`:

    $ distro=>zorin
    $ echo $distro
    
    $ ls zorin
    zorin

Mas quando usamos as aspas, a coisa funciona:

    $ distro=">zorin"
    $ echo $distro
    >zorin

No entanto, aspas simples e duplas nem sempre são intercambiáveis. Dependendo do que estamos fazendo com uma variável (atribuindo ou referenciando), o uso de uma ou de outra tem implicações e produzirá resultados diferentes. No contexto da atribuição de variáveis, as **aspas simples** consideram  _literalmente_  todos os caracteres do valor da variável, enquanto as **aspas duplas** permitem a substituição de variáveis:

    $ lizard=uromastyx
    $ animal='My $lizard'
    $ echo $animal
    My $lizard
    $ animal="My $lizard"
    $ echo $animal
    My uromastyx

Por outro lado, ao referenciar uma variável cujo valor inclui alguns espaços iniciais (ou extras) — às vezes combinados com asteriscos — é obrigatório usar aspas duplas após o comando  `echo`  para evitar  _divisão de campos_  e  _expansão de nome de caminho_:

    $ lizard="   genus   |   uromastyx"
    $ echo $lizard
    genus | uromastyx
    $ echo "$lizard"
       genus   |   uromastyx

Se a referência da variável contiver um ponto de exclamação no final, este deve ser o último caractere da string (caso contrário, o Bash pensará que estamos nos referindo a um evento de  `history`):

    $ distro=zorin.?/!os
    -bash: !os: event not found
    $ distro=zorin.?/!
    $ echo $distro
    zorin.?/!

Todas as barras invertidas devem ser escapadas com outra barra invertida. Aliás, se uma barra invertida for o último caractere na string e não o escaparmos, o Bash interpretará que queremos uma quebra de linha e criará uma nova linha:

    $ distro=zorinos\
    >
    $ distro=zorinos\\
    $ echo $distro
    zorinos\

- `env -i bash`: inicia um bash removendo a maioria das variáveis (além de funções e aliases)

    $ env -i bash

Agora, a maioria das nossas variáveis de ambiente se foi:

    $ echo $USER
    $

Restam apenas algumas:

    $ env
    LS_COLORS=
    PWD=/home/user2
    SHLVL=1
    _=/usr/bin/printenv

`PS1`

Essa variável armazena o valor do prompt do Bash. No trecho de código a seguir (igualmente de  `/etc/profile`), a declaração  `if`  testa a identidade do usuário e lhe atribui um prompt bastante personalizado (  `#`  para  `root`  ou  `$`  para usuários regulares):

    if [ "`id -u`" -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi

>[!NOTE]
>
>O  `id`  de  `root`  é  `0`. Entre como  `root`  e teste você mesmo com  `id -u`.

Eis algumas outras variáveis de prompt:
- `PS2`: normalmente definido como  `>`  e usado como prompt de continuação para comandos longos de muitas linhas.
- `PS3`: usado como prompt para o comando  `select`.
- `PS4`: normalmente definido como  `+`  e usado para depuração.
- `SHELL`: esta variável armazena o caminho absoluto do shell atual:

    $ echo $SHELL
    /bin/bash

- `USER`: armazena o nome do usuário atual:

    $ echo $USER
    carol

- `echo $DISPLAY` retorna `reptilium:0:2`, que quer dizer: a máquina **reptilium** tem um servidor X rodando e estamos usando a **segunda** tela do sistema

### 105.2 Editar e escrever scripts simples

Ao criar um `script.sh` (script = sequencia de comandos) comum, como por exemplo:

    clear
    echo "===== Primeiro Script======"
    echo ""
    uptime
    free -m
    echo ""
    echo "Fim Script"

Podemos executá-lo usando apenas o comando source ou ponto (.)<br>
Quando um script é executado, os comandos nele contidos não são executados diretamente na sessão atual, mas sim por um novo processo do Bash, chamado _sub-shell_. Isso evita que o script sobrescreva as variáveis de ambiente da sessão atual e faça modificações indesejadas nela. Se o objetivo é executar o conteúdo do script na sessão atual do shell, ele deve ser executado com `source script.sh` ou `. script.sh` (note que há um espaço entre o ponto e o nome do script).

    $ source script.sh
    $ . script.sh

Isso inclusive faz com que seja executado no bash atual, sem mudar para um processo filho.

Se tentar executar usando `./script.sh` ou o caminho absoluto dele, vai dar erro de permissão, pois o arquivo não tem permissão de execução. Precisaria executar `chmod u+x script`, para dar permissão de execução para o arquivo (nesse caso, permissão para o usuário dono do arquivo).

- `exec script.sh`: executa o script e fecha a sessão atual (nem dá pra ver o resultado, pois já fecha em seguida)
- `bash script.sh`: também executa o script sem o bit de execução.

>[!WARNING]
>
>Um script que executa ações restritas pode ter sua permissão SUID ativada e, portanto, os usuários comuns também podem executar o script com privilégios de root. Nesse caso, é muito importante garantir que nenhum usuário além do root tenha permissão para escrever no arquivo. Caso contrário, um usuário comum poderá modificar o arquivo para realizar operações arbitrárias e potencialmente prejudiciais.

Caso queira direcionar algum outro interpretador, usa-se o she-bang, que no caso é indicar no começo do arquivo: `#!/bin/bash`

>[!TIP]
>
>O Bash chama qualquer comando indicado após o `#!` como interpretador do arquivo de script. Pode ser útil, por exemplo, empregar o shebang para outras linguagens de script, como _Python_ (`#!/usr/bin/python`), _Perl_ (`#!/usr/bin/perl`) ou _awk_ (`#!/usr/bin/awk`).

#### Parâmetro em shell script

- `$*`: imprime todos os argumentos passados para o script.
- `$@`: todos os argumentos passados para o script. Se usado com aspas duplas, como em  `"$@"`, todos os argumentos serão colocados entre aspas duplas.
- `$0`: imprime o nome do arquivo que está sendo executado
- `$#`: imprime a quantidade de parâmetros utilizados
- `$1`, `$2`, etc: imprime os parâmetros sequencialmente conforme entrada
- `$!`: PID do último programa executado.
- `$$`: PID do shell atual.
- `$?`: código de status de saída numérico do último comando concluído. Para processos POSIX padrão, um valor numérico de  `0`  indica que o último comando foi executado com sucesso, o que também se aplica a scripts do shell.
```
echo "O meu script se chama $0"
echo ""
echo "Esse script recebeu $# parâmetros, que são, $1 e $2"
```

#### Receber uma variável com read

É possível, ao usuário digitar, receber um valor de variável durante a execução de um script, usando o read:

```
echo -n "Digite um valor: "
read VAR1
echo "O valor digitado foi $VAR1"
```
- `echo -n`: não quebra linha

echo "Do you want to continue (y/n)?"
read ANSWER

O valor retornado será armazenado na variável  `ANSWER`. Se o nome da variável não for fornecido, o nome da variável  `REPLY`  será usado por padrão. Também é possível usar o comando  `read`  para ler mais de uma variável simultaneamente:

    echo "Type your first name and last name:"
    read NAME SURNAME

Neste caso, cada termo separado por espaços será atribuído às variáveis  `NAME`  e  `SURNAME`  respectivamente. Se o número de termos dados for maior que o número de variáveis, os termos excedentes serão armazenados na última variável. O próprio  `read`  pode exibir a mensagem para o usuário com a opção  `-p`, tornando o comando  `echo`  redundante nesse caso:

    read -p "Type your first name and last name:" NAME SURNAME

#### Declarando variáveis

A declaração de variáveis **NÃO** usa cifrão (`$`), já no uso da variável, **TEM QUE USAR**. Exemplo:<br>

    echo ""
    VAR1=`cat /etc/passwd|wc -l`
    VAR2=$(date +%H)
    echo ""
    echo "O arquivo /etc/passwd possui $VAR1 linhas. A hora atual é $VAR2."

*Podemos colocar execução de comandos utilizando crase (\`) ou com a sitaxe `$()`
**A notação de crase é conhecida como **backtick**

##### Comprimento de uma variável
O comprimento de uma variável, ou seja, a quantidade de caracteres que ela contém, é retornado acrescentando-se um hash  `#`  antes do nome da variável. Esse recurso, no entanto, requer o uso da sintaxe das chaves para indicar a variável:

    $ OS=$(uname -o)
    $ echo $OS
    GNU/Linux
    $ echo ${#OS}
    9

##### Arrays (matriz unidimensionais)

O Bash também apresenta variáveis de matriz (array) unidimensionais, de forma que um conjunto de elementos relacionados pode ser armazenado com um único nome de variável. Cada elemento de uma matriz possui um índice numérico, que deve ser usado para escrever e ler valores no elemento correspondente. Ao contrário das variáveis comuns, as matrizes devem ser declaradas com o comando interno do Bash  `declare`. Por exemplo, para declarar uma variável chamada  `SIZES`  como uma matriz:

    $ declare -a SIZES

As matrizes também podem ser declaradas implicitamente quando preenchidas a partir de uma lista predefinida de itens, usando a notação de parênteses:

    $ SIZES=( 1048576 1073741824 )
    $ set | grep SIZES
    SIZES=([0]="1048576"   [1]="1073741824")

No exemplo, os dois grandes valores inteiros foram armazenados na matriz  `SIZES`. Os elementos da matriz devem ser referenciados usando chaves e colchetes, caso contrário o Bash não alterará nem exibirá o elemento corretamente. Como os índices da matriz começam em 0, o conteúdo do primeiro elemento está em  `${SIZES[0]}`, o segundo em  `${SIZES[1]}`  e assim por diante:

    $ echo ${SIZES[0]}
    1048576
    $ echo ${SIZES[1]}
    1073741824

Diferente da leitura, a alteração do conteúdo de um elemento da matriz é realizada sem as chaves (por exemplo,  `SIZES[0]=1048576`). Como no caso das variáveis comuns, o comprimento de um elemento em uma matriz é retornado com o caractere hash (por exemplo,  `${#SIZES[0]}`  para o comprimento do primeiro elemento da matriz  `SIZES`). O número total de elementos em uma matriz é retornado se  `@`  ou  `*`  forem usados como o índice:

    $ echo ${#SIZES[@]}
    2
    $ echo ${#SIZES[*]}
    2

As matrizes também podem ser declaradas usando-se, como elementos iniciais, a saída de um comando, por meio da substituição de comando. O exemplo a seguir mostra como criar uma matriz do Bash cujos elementos são os sistemas de arquivos suportados pelo sistema atual:

    $ FS=( $(cut -f 2 < /proc/filesystems) )

O comando  `cut -f 2 < /proc/filesystems`  exibe todos os sistemas de arquivos atualmente suportados pelo kernel em execução (listados na segunda coluna do arquivo  `/proc/filesystems`), de forma que a matriz  `FS`  agora contém um elemento para cada sistema de arquivos suportado. Qualquer conteúdo de texto pode ser usado para inicializar uma matriz, já que, por padrão, quaisquer termos delimitados por caracteres de  _espaço_,  _tabulação_  ou  _nova linha_  **se tornarão um elemento de matriz**.

>[!TIP]
>
>O Bash trata cada caractere do  `$IFS`  (_Input Field Separator_  ou separador de campos) de uma variável de ambiente como um delimitador. Para alterar o delimitador de campo apenas para caracteres de nova linha, por exemplo, a variável IFS deve ser redefinida com o comando  `IFS=$'\n'`.

#### Instruções condicionais (if e case)

Vejamos um exemplo:

    if [ -f /etc/bash.bashrc ]; then
	    .	/etc/bash.bashrc
	fi
ou

    if test -f /etc/bash.bashrc ; then
	    .	/etc/bash.bashrc
	fi
Ambas as instruções produzem o mesmo efeito. Para que a instrução aninhada no `if` execute, ela deve ser **verdadeira**, no caso o que estiver entre os colchetes, ou após a instrução `test`. <br>Nesse exemplo é testado se o arquivo `/etc/bash.bashrc` existe e é um arquivo regular.

- `-f`: testa se arquivo existe e é um arquivo regular;
- `-e`: testa apenas se arquivo existe;
- `-s`: verifica se o tamanho do arquivo é maior que 0 (zero)
- `-z`: verifica se o tamanho da string é zero (usado com variáveis)
- `-n`: verifica se o tamanho da string é diferente de zero (nonzero)

Vejamos outro exemplo

    if [ "`id -u`" -eq 0]; then
	    PS1='# '
	else
		PS1='$ '
	fi

Nesse caso verificar, por meio do comando `id -u`, se o retorno é igual a 0 (zero), caso seja, retorna `#`, senão `$`. No caso testa se o usuário é root. Lembrando que id 0 é do root. Lembrando também que podemos executar comandos com a crase e por meio do cifrão abrindo e fechando parênteses `$()`

O comando  `test`  avalia as expressões usando duas sintaxes diferentes: as expressões de teste podem ser dadas como um argumento para o comando  `test`  ou podem ser postas entre colchetes, caso em que o comando  `test`  é dado implicitamente. Assim, o teste para avaliar se  `/etc`  é um diretório válido pode ser escrito como  `test -d /etc`  ou como  `[ -d /etc]`:

    $ test -d /etc
    $ echo $?
    0
    $ [ -d /etc ]
    $ echo $?
    0

O comando `test` pode ser executado no terminal diretamente. Vejamos alguns exemplos:

- `test LPI1 = LPI1`: precisamo ver no **return code**. Basta executar `echo $?` (**0** é igual sucesso, **1** ou outro número informa que não é verdadeiro)
- `test LPI1 = LPI2`: return code será **1**
- `test -f /etc/profile`: testa se o arquivo `/etc/profile` existe. (**0** = existe, **1** = não existe)
- `test 10 -gt 20`: se 10 é maior que (**greater than**) 20 (retorna **1**, pois 10 não é maior que 20)

Supõe que a variável $VAR guarde um caminho para um arquivo ou diretório. Podemos ter as seguintes opções:

- `-a "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos e é um arquivo.
- `-b "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de bloco especial.
- `-c "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de caractere especial.
- `-d "$VAR"`: avalia se o caminho em  `VAR`  é um diretório.
- `-e "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos.
- `-f "$VAR"`: avalia se o caminho em  `VAR`  existe e é um arquivo regular.
- `-g "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SGID.
- `-h "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico.
- `-L "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico (como  `-h`).
- `-k "$VAR"`: avalia se o caminho em  `VAR`  tem a permissão  _sticky bit_.
- `-p "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo  _pipe_.
- `-r "$VAR"`: avalia se o caminho em  `VAR`  é legível pelo usuário atual.
- `-s "$VAR"`: avalia se o caminho em  `VAR`  existe e não está vazio.
- `-S "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de socket.
- `-t "$VAR"`: avalia se o caminho em  `VAR`  está aberto em um terminal.
- `-u "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SUID.
- `-w "$VAR"`: avalia se o caminho em  `VAR`  é gravável pelo usuário atual.
- `-x "$VAR"`: avalia se o caminho em  `VAR`  é executável pelo usuário atual.
- `-O "$VAR"`: avalia se o caminho em  `VAR`  é de propriedade do usuário atual.
- `-G "$VAR"`: avalia se o caminho em  `VAR`  pertence ao grupo efetivo do usuário atual.
- `-N "$VAR"`: avalia se o caminho em  `VAR`  foi modificado desde o último acesso.
- `"$VAR1" -nt "$VAR2"`: avalia se o caminho em  `VAR1`  é mais recente que o caminho em  `VAR2`, de acordo com as datas de modificação respectivas.
- `"$VAR1" -ot "$VAR2"`: avalia se o caminho em  `VAR1`  é mais antigo que  `VAR2`.
- `"$VAR1" -ef "$VAR2"`: esta expressão avalia como True (Verdadeiro) se o caminho em  `VAR1`  é um link físico para  `VAR2`.

##### Também existem testes para variáveis de texto arbitrárias, descritos a seguir:

- `-z "$TXT"`: avalia se a variável  `TXT`  está vazia (tamanho zero).
- `-n "$TXT"`  ou  `test "$TXT"`: avalia se a variável  `TXT`  não está vazia.
- `"$TXT1" = "$TXT2"`  ou  `"$TXT1" == "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  são iguais.
- `"$TXT1" != "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  não são iguais.
- `"$TXT1" < "$TXT2"`: avalia se  `TXT1`  vem antes de  `TXT2`, em ordem alfabética.
- `"$TXT1" > "$TXT2"`: avalia se  `TXT1`  vem depois de  `TXT2`, em ordem alfabética.

- `$NUM1 -lt $NUM2`: avalia se  `NUM1`  é menor que  `NUM2`.
- `$NUM1 -gt $NUM2`: avalia se  `NUM1`  é maior que  `NUM2`.
- `$NUM1 -le $NUM2`: avalia se  `NUM1`  é menor ou igual a  `NUM2`.
- `$NUM1 -ge $NUM2`: avalia se  `NUM1`  é maior ou igual a  `NUM2`.
- `$NUM1 -eq $NUM2`: avalia se  `NUM1`  é igual a  `NUM2`.
- `$NUM1 -ne $NUM2`: avalia se  `NUM1`  não é igual a  `NUM2`.

Todos os testes podem receber os seguintes modificadores:

`! EXPR`

Avalia se a expressão  `EXPR`  é falsa.

`EXPR1 -a EXPR2`

Avalia se tanto  `EXPR1`  quanto  `EXPR2`  são verdadeiras.

`EXPR1 -o EXPR2`

Avalia se ao menos uma das duas expressões é verdadeira.



Outro exemplo interessante:<br>

    if [ "$BASH" ] && [ "$BASH" != "/bin/sh" ]; then
	    #executa rotina
	fi
No caso acima, verifica se a variável `$BASH` está declarada **e** se a variável `$BASH` é diferente de `/bin/sh`, então vai para a rotina.

Vejamos um exemplo que verifica se o diretório `/etc/profile.d` existe:<br>

    if [ -d /etc/profile.d ]; then
	    # executa rotina
	fi

Abaixo, outro exemplo um pouco mais complexo:

    if [ -z "${debian_chroot:-}"] && [ -r /etc/debian_chroot ]; then
	    debian_chroot=$(cat /etc/debian_chroot)
	fi
O `-z` significa se o tamanho (length) da string é zero e o `-r` quer dizer se o arquivo existe e se está com permissão de somente leitura.

##### Case
Exemplo1:<br>

    read VAR1
    case $VAR1 in
	    0)
		    echo "O valor digitado foi 0"
	    ;;
	    1|2|3|4|5)
		    echo "O valor digitado foi entre 1 e 5"
		    sleep 3
	    ;;
	    *)
		    echo "O valor digitado foi maior que 5"
	esac

Exemplo 2:<br>

    #!/bin/bash
    
    DISTRO=$1
    
    echo -n "Distribution $DISTRO uses "
    case "$DISTRO" in
    	debian | ubuntu | mint)
        echo -n "the DEB"
      ;;
    	centos | fedora | opensuse )
        echo -n "the RPM"
      ;;
    	*)
        echo -n "an unknown"
      ;;
    esac
    echo " package format."

Cada lista de padrões e comandos associados deve terminar com  `;;`,  `;&`, ou  `;;&`. O último padrão, um asterisco, será usado se não for encontrada uma correspondência para nenhum outro padrão anterior. A instrução  `esac`  (_case_  de trás pra frente) conclui a construção  `case`. Supondo que o script de amostra anterior se chame  `script.sh`  e seja executado com  `opensuse`  como primeiro argumento, a seguinte saída será gerada:

    $ ./script.sh opensuse
    Distribution opensuse uses the RPM package format.
>[!TIP]
>
>
> O Bash tem uma opção chamada `nocasematch` que ativa a correspondência de padrões sem distinção entre maiúsculas e minúsculas para a construção `case` e outros comandos condicionais. O comando interno `shopt` alterna os valores das configurações que controlam comportamentos opcionais do shell: `shopt -s` habilita (_set_) a opção fornecida e `shopt -u` desabilita (_unset_) a opção fornecida. Portanto, colocar `shopt -s nocasematch` antes da construção case permite encontrar padrões sem diferenciar maiúsculas de minúsculas. As opções modificadas por `shopt` afetarão apenas a sessão atual, de forma que as opções modificadas dentro de scripts em execução em um sub-shell — o que é a maneira padrão de executar um script — não afetarão as opções da sessão pai.

#### Loops

- `seq`: faz uma sequencia de acordo com o número que coloque.<br>
Ex.<br>
    $ seq 5
    1
    2
    3
    4
    5

- `expr`: faz conta aritmética<br>
Ex.<br>

    $ expr 1 + 2
    3

    $ expr 1 - 2
    -1

##### for

	read VAR1
    for i in 1 2 3 4 5
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
	done

>[!TIP]
>
>O comando `expr` pode ser substituído por `$(())`, de forma que o exemplo anterior no laço `for` poderia ser reescrito como `j=$(( $i + $VAR1 ))`

>[!TIP]
>
>É possível escrever potenciação com o operador duplo asterisco (`**`). Ex.<br>

    $ echo $( (5**2 ) )
    25

Exemplo1:<br>

Usando o `seq`:

    read VAR1
    for i in `seq $1` # $1 = parâmetro 1
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
		sleep 1
	done

Exemplo2:<br>

    #!/bin/bash
    
    SEQ=( 1 1 2 3 5 8 13 )
    
    for (( IDX = 0; IDX < ${#SEQ[*]}; IDX++ ))
    do
    	echo -n "${SEQ[$IDX]} is "
    	if [ $(( ${SEQ[$IDX]} % 2 )) -ne 0 ]
    	then
    		echo "odd."
    	else
    		echo "even."
      fi
    done

Este script gera exatamente a mesma saída do exemplo anterior. No entanto, em vez de usar a variável  `NUM`  para armazenar um item por vez, a variável  `IDX`  é empregada para rastrear o índice da matriz atual em ordem crescente, começando de 0 e continuando a adicionar enquanto esse número permanecer abaixo do número de itens na matriz  `SEQ`. O item em si é recuperado de sua posição na matriz com  `${SEQ[$IDX]}`.



##### while

    while [ $VAR1 -le $1 ] #enquanto o teste = Verdadeiro, faça...
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 + 1`
	    sleep 1
	done

##### until

    until [ $VAR1 = 0 ] #até que isso seja verdadeiro, faça...chegando no 0, não executa o looping
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 - 1`
	    sleep 1
	done

#### Execução sequencial de comandos

Ex. `cat teste | wc -l`: executa o primeiro comando e a saída do mesmo serve de entrada para o próximo comando, no caso `wc`.

Ex. `date ; ls -l ; teste2 ; echo Exemplo`: executa todos, mesmo que dê erro

Ex. `ls -ls teste && echo Exemplo`: só executa o segundo comando, se o primeiro der sucesso (caso exista o arquivo teste, senão seria erro, caso ele não exista - ou seja, o status de saída igual a `0`)

Ex. `ls -ls teste || echo Exemplo`: só executa o segundo comando, se o primeiro falhar. Executando o primeiro já encerra a execução.

Ex. `ls -ls teste || echo Exemplo || date`: é sequencial, na hora que chegar em um que executou com sucesso, ele para.

Exemplo de uso de `||`
Imagine uma checagem de um arquivo muito importante, caso ele desaparece, tenha qualquer problema, mudança de permissão, etc, avise o usuário administrador ou root sobre isso:

    ls -l arquivo_importante || mail -s "arquivo não existe mais" root < .
Se executar o comando acima e der sucesso, não faz nada. Mas se der erro, executa o segundo comando, no caso, enviar um email avisando que o arquivo não existe mais.

###$$ Saída do script (echo e printf)

Mesmo quando a finalidade de um script envolve apenas operações orientadas a arquivos, é importante exibir mensagens relacionadas ao progresso na saída padrão, para que o usuário seja informado sobre quaisquer problemas e possa, eventualmente, usar essas mensagens para gerar logs de operação.

O comando interno do Bash  `echo`  é comumente usado para exibir strings de texto simples, mas ele também oferece alguns recursos estendidos. Com a opção  `-e`, o comando  `echo`  é capaz de exibir caracteres especiais usando sequências de escape (uma sequência de barra invertida designando um caractere especial). Por exemplo:

    #!/bin/bash
    
    # Get the operating system's generic name
    OS=$(uname -o)
    
    # Get the amount of free memory in bytes
    FREE=$(( 1000 * `sed -nre '2s/[^[:digit:]]//gp' < /proc/meminfo` ))
    
    echo -e "Operating system:\t$OS"
    echo -e "Unallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora o uso de aspas seja opcional ao se usar  `echo`  sem opções, é necessário adicioná-las ao incluir a opção  `-e`; caso contrário, os caracteres especiais podem não ser lidos corretamente. No script anterior, ambos os comandos  `echo`  usam o caractere de tabulação  `\t`  para alinhar o texto, resultando na seguinte saída:

    Operating system:       GNU/Linux
    Unallocated RAM:        1491 MB

O caractere de nova linha  `\n`  pode ser usado para separar as linhas da saída, de forma que exatamente a mesma saída é obtida combinando-se os dois comandos  `echo`  em um só:

    echo -e "Operating system:\t$OS\nUnallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora adequado para exibir a maioria das mensagens de texto, o comando  `echo`  pode não ser o melhor para padrões de texto mais específicos. O comando interno do Bash  `printf`  oferece mais controle sobre a exibição das variáveis. O comando  `printf`  usa o primeiro argumento como formato da saída, onde os marcadores serão substituídos pelos argumentos seguintes na ordem em que aparecem na linha de comando. Assim, a mensagem do exemplo anterior poderia ser gerada com o seguinte comando  `printf`:

    printf "Operating system:\t%s\nUnallocated RAM:\t%d MB\n" $OS $(( $FREE / 1024**2 ))

O espaço reservado  `%s`  destina-se ao conteúdo de texto (será substituído pela variável  `$OS`) e o espaço reservado  `%d`  destina-se a números inteiros (será substituído pelo número resultante de megabytes livres na RAM). O  `printf`  não acrescenta um caractere de nova linha no final do texto, então o caractere de nova linha  `\n`  deve ser posto ao fim do padrão, se necessário. Todo o padrão deve ser interpretado como um único argumento e, portanto, deve ser posto entre aspas.

>[!TIP]
>
> O formato de substituição do espaço reservado realizada por  `printf`  pode ser personalizado com o mesmo formato usado pela função  `printf`  da linguagem de programação C. A referência completa para a função  `printf`  pode ser encontrada em sua página de manual, acessada com o comando  `man 3 printf`.

Com  `printf`, as variáveis são postas fora do padrão de texto, o que torna possível armazenar o padrão de texto em uma variável separada:

    MSG='Operating system:\t%s\nUnallocated RAM:\t%d MB\n'
    printf "$MSG" $OS $(( $FREE / 1024**2 ))

Este método é particularmente útil para exibir formatos de saída distintos, dependendo dos requisitos do usuário. Fica mais fácil, por exemplo, produzir um script que use um padrão de texto distinto se o usuário precisar de uma lista CSV (valores separados por vírgula) em vez de uma mensagem de saída padrão.
cho $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Comando alias: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente **alias**, é mostrado os alias cadastrados no bash atual.

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada E**TCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

### 106.1 Instalar e configurar o X11

Em cima do X ou X11, que roda os gerenciadores de janela, como gnome, kde, xfce, etc.
Display Manager: aquela tela de login inicial.<br>
O servidor X funciona como um modelo cliente-servidor. Os apps que são executados são clientes do servidor X, que provê as disponibilidades gráficas. Assim como a calculadora, que também é um cliente do servidor X.

Normalmente as configurações ficam em `/etc/X11/xorg.conf` (por padrão já nem vem mais com as distros, tendo em vista que tudo já vem muito bem configurado.). No entanto, para explorar, teria que criar o arquivo `xorg.conf` manualmente.

Trecho LPI: [Tradicionalmente, o principal arquivo de configuração usado para configurar um servidor X é o arquivo `/etc/X11/xorg.conf`. Nas distribuições Linux modernas, o servidor X configura a si mesmo em tempo de execução quando é iniciado e, portanto, nenhum arquivo `xorg.conf` pode existir.]

O arquivo  `xorg.conf`  é dividido em estrofes separadas chamadas  _seções_. Cada seção começa com o termo  `Section`  e, após este termo está o  _nome da seção_, que se refere à configuração de um componente. Cada  `Section`  é encerrada por uma  `EndSection`  correspondente. Um arquivo  `xorg.conf`  típico contém as seguintes seções:

- `InputDevice`: usada para configurar um modelo específico de teclado ou mouse.
- `InputClass`: InputClass Nas distribuições Linux modernas, esta seção é tipicamente encontrada em um arquivo de configuração à parte, localizado em  `/etc/X11/xorg.conf.d/`.  `InputClass`  é usada para configurar uma classe de dispositivos de hardware como teclados e mouses, e não um componente específico de hardware. Veja abaixo um exemplo de arquivo  `/etc/X11/xorg.conf.d/00- keyboard.conf`:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "us"
            Option "XkbModel" "pc105"
    EndSection

A opção de  `XkbLayout`  determina a disposição das teclas de um teclado, como Dvorak, canhoto ou destro, QWERTY e idioma. A opção de  `XkbModel`  é usada para definir o tipo de teclado utilizado. Há uma tabela de modelos, layouts e suas descrições em  `xkeyboard-config(7)`. Os arquivos associados aos layouts de teclado podem ser encontrados em  `/usr/share/X11/xkb`. Um layout de teclado grego politônico em um computador Chromebook apareceria desta maneira:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "gr(polytonic)"
            Option "XkbModel" "chromebook"
    EndSection

Alternativamente, o layout de um teclado pode ser modificado durante uma sessão X em execução com o comando  `setxkbmap`. Eis um exemplo desse comando para configurar o layout grego politônico em um computador Chromebook:

    $ setxkbmap -model chromebook -layout "gr(polytonic)"

Essa configuração só permanecerá ativa enquanto a sessão X estiver em uso. Para que essas alterações se tornem permanentes, modifique o arquivo  `/etc/X11/xorg.conf.d/00-keyboard.conf`  de forma a incluir as configurações necessárias.

>[!NOTE]
>
>O comando  `setxkbmap`  utiliza a X Keyboard Extension (XKB). Este é um exemplo da funcionalidade aditiva do X Window System por meio do uso de extensões.

As distribuições Linux modernas fornecem o comando  `localectl`  através do  `systemd`, que também pode ser usado para modificar um layout de teclado e cria automaticamente o arquivo de configuração  `/etc/X11/xorg.conf.d/00-keyboard.conf`. Novamente, eis um exemplo de configuração de um teclado grego politônico em um Chromebook, desta vez com o comando  `localectl`:

    $ localectl --no-convert set-x11-keymap "gr(polytonic)" chromebook

A opção  `--no-convert`  é usada aqui para impedir que o  `localectl`  modifique o mapa do teclado no console do hospedeiro.

- `Monitor`: a seção  `Monitor`  descreve o monitor físico utilizado e onde está conectado. Eis um exemplo de configuração que mostra um monitor de hardware conectado à segunda porta de vídeo e usado como monitor principal.

    Section "Monitor"
            Identifier  "DP2"
            Option      "Primary" "true"
    EndSection

- `Device`: a seção  `Device`  descreve a placa de vídeo física utilizada. A seção também contém o módulo do kernel usado como driver para a placa de vídeo, junto com sua localização física na placa-mãe.

    Section "Device"
            Identifier  "Device0"
            Driver      "i915"
            BusID       "PCI:0:2:0"
    EndSection

- `Screen`: a seção  `Screen`  reúne as seções  `Monitor`  e  `Device`. Um exemplo de seção  `Screen`  seria semelhante ao seguinte:

    Section "Screen"
            Identifier "Screen0"
            Device     "Device0"
            Monitor    "DP2"
    EndSection

-`ServerLayout`: a seção  `ServerLayout`  agrupa todas as seções como mouse, teclado e telas em uma única interface do X Window System.

    Section "ServerLayout"
    	Identifier   "Layout-1"
    	Screen       "Screen0" 0 0
    	InputDevice  "mouse1"  "CorePointer"
    	InputDevice  "system-keyboard"  "CoreKeyboard"
    EndSection

>[!NOTE]
>
>Nem todas as seções estão presentes em um arquivo de configuração. Nos casos em que uma seção está ausente, os valores padrão são fornecidos pela instância do servidor X em execução.

Os arquivos de configuração específicos ao usuário também residem em `/etc/X11/xorg.conf.d/`. Os arquivos de configuração fornecidos pela distribuição localizam-se em `/usr/share/X11/xorg.conf.d/`. Os arquivos de configuração localizados em `/etc/X11/xorg.conf.d/` são analisados antes do arquivo `/etc/X11/xorg.conf` se ele existir no sistema.

O comando  `xdpyinfo`  é usado em um computador para exibir informações sobre uma instância do servidor X em execução. Veja abaixo um exemplo de saída do comando (determinar quais extensões Xorg estão disponíveis em um sistema):

    $ xdpyinfo
    name of display:    :0
    version number:    11.0
    vendor string:    The X.Org Foundation
    vendor release number:    12004000
    X.Org version: 1.20.4
    maximum request size:  16777212 bytes
    motion buffer size:  256
    bitmap unit, bit order, padding:    32, LSBFirst, 32
    image byte order:    LSBFirst
    number of supported pixmap formats:    7
    supported pixmap formats:
        depth 1, bits_per_pixel 1, scanline_pad 32
        depth 4, bits_per_pixel 8, scanline_pad 32
        depth 8, bits_per_pixel 8, scanline_pad 32
        depth 15, bits_per_pixel 16, scanline_pad 32
        depth 16, bits_per_pixel 16, scanline_pad 32
        depth 24, bits_per_pixel 32, scanline_pad 32
        depth 32, bits_per_pixel 32, scanline_pad 32
    keycode range:    minimum 8, maximum 255
    focus:  None
    **number of extensions:    25
        BIG-REQUESTS
        Composite
        DAMAGE
        DOUBLE-BUFFER
        DRI3
        GLX
        Generic Event Extension
        MIT-SCREEN-SAVER
        MIT-SHM
        Present
        RANDR
        RECORD
        RENDER
        SECURITY
        SHAPE
        SYNC
        X-Resource
        XC-MISC
        XFIXES
        XFree86-VidModeExtension
        XINERAMA
        XInputExtension
        XKEYBOARD
        XTEST
        XVideo
    default screen number:    0
    number of screens:    1
    
    screen #0:
      dimensions:    3840x1080 pixels (1016x286 millimeters)
      resolution:    96x96 dots per inch
      depths (7):    24, 1, 4, 8, 15, 16, 32**
      root window id:    0x39e
      depth of root window:    24 planes
      number of colormaps:    minimum 1, maximum 1
      default colormap:    0x25
      default number of colormap cells:    256
      preallocated pixels:    black 0, white 16777215
      options:    backing-store WHEN MAPPED, save-unders NO
      largest cursor:    3840x1080
      current input event mask:    0xda0033
        KeyPressMask             KeyReleaseMask           EnterWindowMask
        LeaveWindowMask          StructureNotifyMask      SubstructureNotifyMask
        SubstructureRedirectMask PropertyChangeMask       ColormapChangeMask
      number of visuals:    270
    ...

As partes mais relevantes da saída estão em negrito, como o nome da tela (que é idêntico ao conteúdo da variável de ambiente  `DISPLAY`), as informações de versão do servidor X em uso, o número e a listagem das extensões do Xorg em uso e mais informações sobre a tela em si.

Com `ps axu | grep X`, podemos ver o processo `/usr/lib/xorg/Xorg`, que roda no terminal **tty7**. E para gerar o `xorg.conf`, é necessário parar esse processo, logo terá que mudar para o **tty1** (`Ctrl+Alt+F1`), acessar como root e parar o processo **Xorg**.

É necessário mudar para o modo de multiusuários, mas sem interface gráfica, por meio do comando: `# systemctl isolate multi-user.target`. Confirme com `ps axu | grep X`, e verá que o servidor X não está mais rodando.

Agora resta executar o comando `Xorg -configure` (ubuntu 16.04) que irá gerar um arquivo `xorg.conf` em `/root`. Copie esse arquivo para `/etc/x11/xorg.conf`. Rode `startx` para subir o servidor X (mas sem a tela de login), para sair basta fazer um logout. Volte para a interface gráfica padrão executando o comando `systemctl default`. O `xorg.conf` é separado por seções, com identificadores e opções, para mouse, teclado, telas, fontes (que podem ser remotas inclusive), etc.

Vejamos algumas:

- **Module**: carregamento dinâmico de módulos.

Exemplo:  

    _Section "Module"  
    Load "glx"  
    Load "dbe"  
    Load "extmod"  
    EndSection  

_ **Files**: caminhos para alguns arquivos e diretórios utilizados pelo servidor X, como módulos mas principalmente as  **fontes**.

Exemplos:

    _Section "Files"  
    ModulePath "/usr/lib/xorg/modules"  
    FontPath "/usr/share/fonts/X11/misc"  
    FontPath "/usr/share/fonts/X11/Type1"  
    FontPath "/usr/share/fonts/X11/100dpi"  
    FontPath "/usr/share/fonts/X11/75dpi"  
    FontPath "built-ins"  
    FontPath "unix:/7100"  
    FontPath "tcp/fonts.server.com:7100"  
    EndSection_
  
- **InputDevice**: contêm configurações referentes aos dispositivos de entrada, principalmente  **mouse** e  **teclado**.  _Identifier_ e  _Driver_  são parâmetros obrigatórios utilizados para especificar o dispositivo. Além disso parâmetros  _Option_ podem ser adicionados para implementar configurações específicas

Exemplo:

    _Section "InputDevice"  
    Identifier "Keyboard0"  
    Driver "kbd"  
    Option "XkbModel" "pc105"  
    Option "XkbLayout" "us"  
    Option "AutoRepeat" "500 200"  
    EndSection_

      _Section "InputDevice"  
    Identifier "Mouse0"  
    Driver "mouse"  
    Option "Protocol" "auto"  
    Option "Device" "/dev/input/mice"  
    Option "Emulate3Buttons" "no"  
    Option "ZAxisMapping" "4 5"  
    EndSection_

  
- **Device**: seção utilizada principalmente para configuração da  **placa de vídeo**. Semelhante ao InputDevice, tem os parâmetros  _Identifier_ e  _Driver_ como obrigatórios.

Exemplo:

    _Section "Device"  
    Identifier "VideoCard0"  
    Driver "nv"  
    VendorName "nVidia"  
    BoardName "GeForce 6100"  
    VideoRam 131072  
    EndSection_

  
- **Monitor**: configurações específicas do monitor utilizado, como  _HorizSync_ e  _VertRefresh_.

Exemplo:

    _Section "Monitor"  
    Identifier "Monitor0"  
    VendorName "Monitor Vendor"  
    ModelName "Monitor Model"  
    HorizSync 30.0 - 83.0  
    VertRefresh 55.0 - 75.0  
    EndSection_

  
- **Screen**: a seção screen é uma combinação entre o monitor e a placa de vídeo, dizendo ao X quais os modos que ele pode trabalhar. Na sub-seção  **Display**, são informados por exemplo as  **resoluções** suportadas,  **color depth** (bits por pixel), e etc.

    _Section "Screen"  
    Identifier "Screen0"  
    Device "Card0"  
    Monitor "Monitor0"  
    SubSection "Display"  
    Viewport 0 0  
    Depth 1  
    EndSubSection  
    SubSection "Display"  
    Viewport 0 0  
    Depth 4  
    EndSubSection  
    SubSection "Display"  
    Depth 24  
    Modes "1920x1080" "1280x1024" "1024x768"  
    EndSubSection  
    SubSection "Display"  
    Depth 8  
    Modes "1024x768" "800x600" "640x480"  
    EndSubSection  
    EndSection_

  
- **ServerLayout**: esta seção agrega as outras definições da configuração do X, associando principalmente as informações do Screen e InputDevices.

Exemplo:

    _Section "ServerLayout"  
    Identifier "X.org Configured"  
    Screen 0 "Screen0" 0 0  
    InputDevice "Mouse0" "CorePointer"  
    InputDevice "Keyboard0" "CoreKeyboard"  
    EndSection_

#### Uso da variável $DISPLAY

`$Display` mostra, normalmente, a seguinte informação:<br>

    :0.0

    hostname:displaynumber.screennumber

O nome de exibição também informa a um aplicativo gráfico onde ele deve ser renderizado e em qual hospedeiro (no caso de uma conexão X remota).

O  `hostname`  refere-se ao nome do sistema que exibirá o aplicativo. Se o nome de exibição não contiver o nome do hospedeiro, o host local será pressuposto.

O  `displaynumber`  faz referência à coleção de “telas” que estão em uso, seja uma única tela de laptop ou diversas telas em uma estação de trabalho. Cada sessão do servidor X em execução recebe um número de exibição começando em  `0`.

O  `screennumber`  padrão é  `0`. Esse pode ser o caso se apenas uma tela física ou diversas telas físicas estiverem configuradas para funcionar como uma só tela. Quando todas as telas de uma configuração de múltiplos monitores são combinadas em uma única tela lógica, as janelas do aplicativo podem ser movidas livremente entre as telas. Em situações em que cada tela é configurada para funcionar independentemente uma da outra, cada tela abrigará as janelas dos aplicativos que forem abertos dentro delas e as janelas não podem ser movidas de uma tela para outra. A cada tela independente será atribuído seu próprio número. Se houver apenas uma tela lógica em uso, o ponto e o número da tela serão omitidos.

Para iniciar um aplicativo em uma tela específica, atribua o número da tela à variável de ambiente  `DISPLAY`  antes de iniciar o aplicativo: $

    $ DISPLAY=:0.1 firefox &

Esse comando iniciaria o navegador Firefox na tela à direita do diagrama acima. Alguns kits de ferramentas também oferecem opções de linha de comando para instruir um aplicativo a ser executado em uma tela especificada. Procure por  `--screen`  end  `--display`  na página do manual de  `gtk-options(7)`  para ver um exemplo..

O nome de exibição de uma sessão X em execução é armazenado na variável de ambiente  `DISPLAY`:

    $ echo $DISPLAY
    :0

A saída detalha o seguinte:

1.  O servidor X em uso está no sistema local, portanto não há nada impresso à esquerda dos dois pontos.
    
2.  A sessão atual do servidor X é a primeira indicada por  `0`  imediatamente após os dois pontos.
    
3.  Há apenas uma tela lógica em uso, portanto um número de tela não é visível.

Quando não há nada antes dos dois pontos (`:`), considera-se que o valor é `localhost`. Para executar algum app em outro computador, precisa-se mudar o valor da variável de ambiente DISPLAY:<br>

    export DISPLAY="192.168.0.100:0.0"

No host que irá receber a abertura do programa escolhido, é preciso liberá-lo para essa conexão. Por meio do comando `xhost` é possível verificar quem que está autorizado a permitir essa conexão. Para liberar o acesso, digite o comando:<br>

    xhost +192.168.0.99

Digite `xhost` novamente para confirmar que realmente foi liberado. Para liberar completamente o controle de acesso, digite `xhost +` (comando para restringir novamente é: `xhost -`)

Ainda assim não será possível realizar a tarefa, pois o **Display Manager** está bloqueando. No caso, seria o **lightdm**. Se olhar no processo Xorg (`ps axu | grep X`), é possível notar que **lightdm** está rodando com a opção `-nolisten tcp`, e é necessário mudar essa opção (isso para distros baseadas no Debian/Ubuntu).

Vá até `/usr/share/lightdm/lightdm.conf.d`, e edite o arquivo `50-xserver-command.conf`e adicione `xserver-allow-tcp=true` no final do arquivo. Reinicie o `lightdm: systemctl restart lightdm`. Se olhar no processo Xorg **NÃO** terá mais o `-nolisten tcp`

Agora do computador que irá executar o comando para abertura de algum app, execute **xcalc** ou qualquer outro aplicativo para abrir no outro computador.<br>
*O processamento todo está sendo feito pelo PC que abriu a aplicação, no caso o PC de origem. O de destino apenas está gerando a parte gráfica.

#### X11 e o Desktop Environment

Desktop Environment: é um **conjunto de aplicações**, com a finalidade de prover uma interface gráfica amigável ao usuário.<br>
Exemplos: KDE, GNOME, MATE, Cinnamon, LXDE, Xfce

##### Gerenciador de Janelas (Window Manager)

- Controla a criação e fechamento das janelas no ambiente, além do posicionamento e aparência
- São clientes X
- Podem ser parte integrada de um DE ou independentes
- Exemplos: mutter (GNOME), KWin (DKE), Muffin (Cinnamon), Xfwm (XFCE), enligntenment, window maker, Openbox, etc
*É requisito ter um **Window Manager** dentro do **Desktop Environment**

- `update-alternatives --display x-window-manager`: verifica qual é o gerenciador de janelas, ou com o comando:
- `ls -l /etc/alternatives/ | grep window`

##### Interface Gráfica (GUI)

Quando falamos qual interface gráfica você usa? E respondemos KDE, GNOME, etc. Na realidade tecnicamente estamos falando de **Desktop Environment (DE)**.

Já a Interface Gráfica em que o usuário interage, que é o que é usado pelo usuário, é chamado de, por exemplo, do KDE é o KDE Plasma. Do GNOME, é o GNOME Shell, etc

Portanto, a interface gráfica é um dos muitos componentes dentro do DE.

Se estiver usando o GNOME, faça o teste:

- `ps axu | grep gnome`: lista diversas aplicações, como gnome-settings, gnome-software, etc. Essas são aplicações que fazem parte do DE. Uma delas vai ser o `gnome-shell`, que no caso é a interface gráfica.
 
##### Display Managers (DM)

- Interface para realização do login
- Exemplos: GDM (GNOME), LightDM (XFCE), XDM, LXDM
*Geralmente termina em DM (Display Manager)

##### Wayland

É uma alternativa ao X11, criado pelo xorg.

- Protocolo que especifica a comunicação entre o servidor gráfico (Compositor Wayland) e os clientes
- Criado com a intenção de substituir o X, com uma arquitetura diferente visado melhor performance geral
- Atualmente utilizando por padrão no Fedora com GNOME, mas é uma opção em todos os DE
- Projeto em Desenvolvimento

#### Comandos e Arquivos

Em `/usr/share/X11/xorg.conf.d` ficam alguns arquivos de configuração de aplicativos ligados ao hardware, como GPUs, com padrão Section e EndSection

Todos os usuário terão em seu diretório padrão o arquivo `.xsession-errors`, que é um arquivo de log para guardar os erros que ocorrem relacionados à interface gráfica

O acesso remoto que foi feito usando **xhost**, pode ser feito usando o `xauth list`, pegando o magic cookie do computador que quer executar os aplicativos, e adicionando esse magic coockie no computador que irá realizar o acesso, usando o comando:

- `xauth add 192.168.0.100 MIT-MAGIC-COOKIE-1 hash_gerada`

### 106.2 Desktops gráficos

Desktops Environments: GNOME, KDE, MATE, Cinnamon, XFCE, LXDE

- **GNOME**: forte associação ao Projeto GNU, usa biblioteca gráfica **GTK**, Window Manager: mutter.
- **KDE**: pode ser usado em Linux, FreeBSD, Solaris, Windows e Mac OS X, usa biblioteca gráfica **Qt**, Window Manager: KWin
- **MATE**: derivado do GNOME 2, utiliza biblioteca GTK, Window Manager: marco
- **Xfce**: pretende ser rápido e leve, utiliza biblioteca GTK, Window Manager: xfwm

*O **LXDE** é um ambiente de desktop adaptado para baixo consumo de recursos, sendo assim uma boa escolha para instalação em equipamentos mais antigos ou computadores de placa única. Embora não ofereça todas as capabilidades dos ambientes de trabalho mais pesados, o LXDE inclui todos os recursos básicos esperados de uma interface gráfica de usuário moderna

#### Protocolos para acesso remoto a Desktops

- **XDMCP** (X Display Manager Control Protocol)
	- Protocolo nativo do X
	- Implementado pelo Display Manager
	- Não implementa segurança/criptografia
	- Não faz compressão (ocupa bastante banda  )

Para conexão remota utilizando XDMCP, configure o arquivo `/etc/lightdm/lightdm.conf` de maneira que habilite o XDMCPServer:<br>

    [XDMCPServer]
    enable=true

Em outro terminal, execute: `Xorg -terminate -query 192.168.0.100 :1`

- **VNC** (Virtual Networking Computing)
	- utiliza o protocolo RFB (Remote Framebuffer Protocol)
	- Não é totalmente seguro, mas as senhas são criptografadas
	- É possível executar muitos servidores VNC na mesma máquina, mas cada servidor VNC precisa de uma porta TCP exclusiva na interface de rede que aceite solicitações de sessão de entrada. Por convenção, o primeiro servidor VNC deve usar a porta TCP 5900, o segundo deve usar 5901 e assim por diante

- **SPICE** (Simple Protocol for Independent Computing Environment)
	- solução open source completa para acesso remoto
	- solução mais segura

- **RDP** (Remote Desktop Protocol): é usado sobretudo para acessar remotamente a área de trabalho de um sistema operacional _Microsoft Windows_ por meio da porta de rede TCP 3389
	- utilizado para o Microsoft Terminal Service

### 106.3 Acessibilidade

Acessibilidade também é chamada de **AccessX**. Pode ser alterado com a linha de comando: `xkbset`

Locais para acesso: O módulo de configurações de acessibilidade é chamado de _Acesso universal_ na área de trabalho do Gnome, enquanto que no KDE ele está em _Configurações do sistema_, _Personalização_, _Acessibilidade_. Outros ambientes de desktop, como o _Xfce_, também o chamam de _Acessibilidade_ em seu gerenciador de configurações gráficas. Porém, de maneira geral eles oferecem um conjunto reduzido de funcionalidades em comparação com o Gnome e o KDE.

- `sticky keys` (teclas de aderência): é para quem não consegue apertar mais de uma tecla ao mesmo tempo (Ex. shift + A ou S, etc). Se habilitar, basta apertar a tecla do atalho e a outra sequencial (sem necessidade de segurar) - (O KDE também oferece a opção de _Teclas de bloqueio_: se habilitada, as teclas Alt, Ctrl e Shift permanecerão “apertadas” se o usuário as pressionar duas vezes, semelhante ao comportamento da tecla Caps lock) - (o recurso de teclas de aderência será ativado pressionando-se a tecla Shift cinco vezes consecutivas. Para ativar o recurso de teclas lentas, a tecla Shift deve ser mantida pressionada por oito segundos consecutivos)
- `slow keys`(teclas lentas): usado por quem tem problema motor, as teclas lentas exigem que o usuário mantenha a tecla pressionada por um período de tempo especificado antes de ela ser aceita
- `bouce keys`(teclas de repercussão): serve para inibir pressionamentos de tecla não intencionais adicionando um tempo de latência entre eles (se precisar digitar a mesma tecla, precisa aguardar o delay)
- `mouse emulation`: para usar o mouse com o teclado numérico da direita. (Ex. 8=cima, 2=baixo, 6=direita e 4=esquerda, 5=pressionar - clique esquerdo)
- `Preferências do mouse  na janela de configuração do sistema`: se o usuário não conseguir pressionar um ou mais botões do mouse, os cliques podem ser simulados usando diferentes técnicas. Na seção  _Assistência de clique_  do  _Acesso Universal_  do Gnome, a opção  _Clique secundário simulado_  simula um clique com o botão direito se o usuário pressionar e segurar o botão esquerdo do mouse. Com a opção  _Clique flutuante_  habilitada, um evento de clique será disparado quando o usuário segurar o mouse sem movê-lo. No KDE, o aplicativo  _KMouseTool_  fornece esses mesmos recursos para facilitar as ações com o mouse.
- `GOK (Gnome On-board Keyboard)`: teclado virtual On-board
- `KMag`: screen magnifier (ampliador de tela - LUPA)
- `Orca e emacspeak`: leitor de tela, sendo o Orca o principal
- `BRLTTY`: app do Linux para entender e usar o [Braille Display](https://www.google.com/search?q=braille+display&oq=brai&gs_lcrp=EgZjaHJvbWUqBggAEEUYOzIGCAAQRRg7MgYIARBFGDkyBggCEEUYPDIGCAMQRRg8MgYIBBBFGEEyBggFEEUYQTIGCAYQRRhBMgYIBxAuGEDSAQgzODQ5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8)]

#### Reconhecimento de voz

Software capaz de executar comandos através do reconhecimento de voz. Diversos projetos Open Source em desenvolvimento (além dos principais para dispositivos móveis, como Siri, Cortana, etc.
- CMUSphinx
- Simon (KDE)
- Julius

Pergunta interessante na [lpi.org](https://learning.lpi.org/pt/learning-materials/102-500/106/106.3/106.3_01/) citando o Orca<br>
De que forma o aplicativo  _Orca_  pode ajudar usuários com deficiência visual a interagir com o ambiente de trabalho?
O Orca é um leitor de tela que gera uma voz sintetizada que descreve os eventos na tela e lê o texto sob o cursor do mouse. Ele também funciona com dispositivos chamados de  _visores braille atualizáveis_, permitindo ao usuário identificar o texto com padrões táteis.

### 107.1 Administrar contas de usuário, grupos e arquivos de sistema relacionados

Cada usuário tem, obrigatoriamente, seu grupo padrão. E pode estar em vários grupos, ou seja, o mesmo usuário pode estar em vários grupos, facilitando para o administrador de sistemas.

- `/etc/passwd`: principal arquivo que contém todos os usuários do sistema
	- `id` e `gid`: id e id do grupo padrão do usuário (**root SEMPRE será id igual a 0 zero, assim como seu gid**)

Se observar há diversos usuários de sistema, como por exemplo o **daemon**. No Linux, para poder criar um processo ou gerar um arquivo, é preciso ter um usuário, no mínimo. Por isso a necessidade de aplicações terem seu usuário

Normalmente (varia de distro para distro), ids a partir de 1000 são os de usuário, abaixo de 1000 são os de sistema. Lembrando que isso é mais comum, mas pode variar, pois é totalmente configurável.

Por convenção, em `/etc/passwd`, é recomendado sempre utilizar caracteres minúsculos, pois haveria distinção de um usuário chamado rodrigo e Rodrigo, pois é case sensitive. Portanto, é recomendado seguir o padrão.

#### Entendendo cada campo do /etc/passwd
Ordem dos campos:<br>
1. nome do usuário
2. senha do usuário: que armazena em `/etc/shadow`. Antigamente armazenava aqui mesmo
3. id do usuário
4. grupo padrão do usuário: que por padrão usa o mesmo nome do usuário, mas também é configurável e possível alterar
5. descrição: normalmente o nome do usuário, mas isso não é regra.
6. home do usuário: local onde usuário poderá gravar sem restrições, e onde também o usuário cai ao fazer login
7. shell padrão do usuário, que é aberto após login. Quando tem `/bin/false`, significa que **NÃO** é um usuário que irá se logar. Assim como quando tiver `/usr/sbin/nologin`.<br>
*Internamente o Linux sempre trabalha com o `id`.<br>
**Pode-se ter dois usuários com o mesmo id, no entanto o Linux tratará os dois como se fosse um só.<br>
***Pode-se alterar o arquivo `/etc/passwd` diretamente, mas não é recomendado, pois há comandos para isso (e pense que o `/etc/passwd` é ligado com o `/etc/shadow`, e mudar uma coisa em um, geraria inconsistência no outro). Ex. Poderia alterar o id de qualquer usuário para o `id = 0`, e esse usuário se comportaria como root. No entanto não é recomendado.

#### Entendendo cada campo do /etc/shadow

Contém as senhas dos usuário<br>
Ordem dos campos:<br>
1. usuário propriamente dito
2. hash da senha (**quando não** tem senha definida, fica um ponto de exclamação - `!`)

#### Entendendo cada campo do /etc/group

Contém os grupos dos usuário<br>
Ordem dos campos:<br>
1. nome do grupo
2. senha (sim, grupo também pode ter senha, que fica em `/etc/gshadow`)
3. ids do grupo
4. usuários que fazem parte do grupo

#### Entendendo cada campo do /etc/login.defs

Contém as definições de login de cada usuário. No caso, aqui também tem as definições de ids dos usuários (fica próximo da linha 172). Por exemplo:<br>

    # Min/max values for automatic uid selection in useradd
    171 #
    172 UID_MIN                  1000
    173 UID_MAX                 60000

Lembrando que é uma convenção, o Linux, por exemplo, pode ter mais que 60k usuários.

É nesse arquivo também que podemos alterar a variável `DEFAULT_HOME` para `yes` para criar o `/home` dos usuários.

Mais algumas diretivas importantes:<br>

- `UID_MIN`  e  `UID_MAX`: O intervalo de IDs de usuário que podem ser atribuídos a novos usuários comuns.
- `GID_MIN`  e  `GID_MAX`: O intervalo de IDs de grupo que podem ser atribuídos a novos grupos comuns.

- `CREATE_HOME`: Especifica se um diretório pessoal deve ser criado por padrão para novos usuários.
- `USERGROUPS_ENAB`: Especifica se o sistema deve, por padrão, criar um novo grupo para cada nova conta de usuário com o mesmo nome do usuário, e se, ao deletar a conta do usuário, o grupo primário do usuário também deve ser removido, caso não contenha mais membros.

- `MAIL_DIR`: O diretório de spool de email.
- `PASS_MAX_DAYS`: O número máximo de dias que uma senha pode ser usada.
- `PASS_MIN_DAYS`: O número mínimo de dias permitido entre mudanças de senha.
- `PASS_MIN_LEN`: O comprimento mínimo aceitável da senha.
- `PASS_WARN_AGE`: O número de dias de aviso antes que uma senha expire.

>[!TIP]
>
>Ao gerenciar usuários e grupos, sempre verifique este arquivo para visualizar e, eventualmente, alterar o comportamento padrão do sistema, se necessário.

#### 107.1 Gerenciamento de Usuários e Grupos - useradd, userdel, usermod, passwd

Basicamente são:<br>
- `useradd`: adiciona usuário
- `userdel`: exclui usuário
- `usermod`: altera configurações usuário

##### useradd
- `useradd usuário1`: cria o **usuário1**, e em `/etc/passwd`, cria uma linha referente a esse usuário. Algumas distros antigas tinham um bug que não informava o shell a ser utilizado, ficando em branco, e tendo que alterar manualmente (é possível mudar com o comando `chsh`)

Exemplo com várias opções:<br>

    useradd -c "Nome do Usuario" -s /bin/bash -g 1001 -G 1010

- `-c`(`--comment`):  string de texto com o comentário do usuário (geralmente nome completo do usuário
- `-s`(--shell): shell padrão desejado pelo novo usuário
- `-g`(`--gid`): grupo primário (padrão) do novo usuário
- `-G` (`--group`): grupo(s) secundários do novo usuário (outros grupos que o usuário vai pertencer)
- `-e` (`--expiredate`) (YYYY-MM-DD): define um tempo que a conta será desabilitada
- `-f`: cria uma nova conta de usuário definindo o número de dias após a expiração de uma senha durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-k`: cria uma nova conta de usuário copiando os arquivos de esqueleto de um diretório personalizado específico (esta opção só é válida se a opção  `-m`  ou  `--create-home`  for especificada).

Outras opções importantes:
- `-d` (`--home-dir`): definir um `/home` para usuário (não precisa ser o padrão)
- `-m` (`--create-home`): caso no `/etc/user.defs` esteja para não criar `/home` por padrão, pode-se usar essa opção para "forçar" criar o `/home` do usuário (conforme definido no skeleton directory) 
- `-M` (`--no-create-home`): não cria o `/home`
- `-p` (`--password`): define a senha. Mas precisa ser em hash, que pode ser criado por outro comando.
- `-u` (`--uid`): id deseja que o usuário tenha

##### userdel

Supõe que **usuario1** tenha entrada referente a ele em `/etc/passwd`, `/etc/shadow`, `/etc/group` e ele possua um diretório em `/home`, sendo `/home/usuario1`. Se executar:<br>

    userdel usuario1

Será apagado as entradas nos três arquivos, mas **não apagará** a pasta `/home/usuario1`. Para apagar, tem que usar a opção `-r`:
- `-r` (`--remove`): remove o /home do usuário

##### usermod

Basicamente muda o que poderia ser definido com o `useradd`. Supõe que usuario1 não tem comentário, podemos adicionar um comentário com o comando:<br>

    usermod -c "Nome usuario 1" usuario1

Mudar o shell do usuário1:<br>

    usermod -s /sbin/ksh usuario1

`usermod -g suporte usuario1`: muda para **suporte** o grupo padrão do **usuario1** (originalmente, quando criado, o grupo padrão (`-g`) do **usuario1** era **usuario1**. Confirme com um `cat /etc/passwd` para ver o id do grupo do **usuario1**.

Repare na similaridade dos dois comandos a seguir:<br>


`usermod -G devops usuario1`: define o grupo **devops** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **devosp**.

`usermod -G qateams usuario1`: define o grupo **qateams** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **qateams**. NO ENTANTO, o usuario1 não faz mais parte do grupo suporte (imagine que o limite de grupos secundários seja 1 grupo por vez), mas podemos podemos manter o grupo secundário com o argumento `-a`, que no caso vai adicionando os grupos. Ficando o comando:<br>

    usermod -G -a qateams usuario1

ou

    usermod -aG qateams usuario1
- `-a` ou `--append`

- `-l` ou `--login`: altera o nome de login da conta de usuário especificada.
- `-L`ou `--lock`:  bloqueia a conta de usuário especificada. Um ponto de exclamação é posto na frente da senha criptografada dentro do arquivo  `/etc/shadow`, desabilitando assim o acesso com senha para esse usuário. (Note: if you wish to lock the account (not only access with a password), you should also set the EXPIRE_DATE to 1).
- `-U`ou `--unlock`: desbloqueia a conta de usuário especificada. Remove o ponto de exclamação na frente da senha criptografada no arquivo  `/etc/shadow`.

>[!TIP]
>
>Lembre que, ao alterar o nome de login de uma conta de usuário, você provavelmente deve renomear o diretório pessoal desse usuário e outros itens relacionados a ele, como arquivos de spool de email. Lembre também que, ao alterar o UID de uma conta de usuário, provavelmente será preciso corrigir a propriedade dos arquivos e diretórios que estejam fora do diretório inicial do usuário (o ID do usuário é alterado automaticamente na caixa de email do usuário e em todos os arquivos pertencentes ao usuário e localizados no diretório inicial do usuário).

##### passwd

Usado para alterar/criar senha para usuários (precisa ser root)

    passwd usuario1 #troca a senha do usuario1
    passwd #troca a senha do usuario root

Lembre-se que ao criar um usuário, no campo referente à senha lá no arquivo `/etc/shadow`, vai ficar com um ponto de exclamação (`!`), indicando que não foi definido uma senha. Após criar uma senha com o comando `passwd`, uma hash entrará no lugar do ponto de exclamação.

    su usuario1 #troca para o usuario1

Mais algumas opções para o uso de `passwd`:<br>

- `-d`: apaga a senha de uma conta de usuário (desabilitando o usuário).
- `-e`:  força a conta de usuário a alterar a senha.
- `-i`:  define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-l`: bloqueia a conta de usuário (a senha criptografada é prefixada com um ponto de exclamação no arquivo  `/etc/shadow`).
- `-n`: define o tempo de vida mínimo da senha.
- `-S`: exibe informações sobre o status da senha de uma conta de usuário específica.
- `-u`: desbloqueia a conta do usuário (o ponto de exclamação é removido do campo de senha no arquivo  `/etc/shadow`).
- `-x`: define o tempo de vida máximo da senha.
- `-w`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>Os grupos também podem ter uma senha, que pode ser definida usando o comando  `gpasswd`. Os usuários que não são membros de um grupo mas conhecem a senha podem ingressar nele temporariamente usando o comando  `newgrp`.  `gpasswd`  também é usado para adicionar e remover usuários de um grupo e para definir a lista de administradores e membros comuns do grupo.

> [!IMPORTANT] 
>
>Há o comando `adduser`, que na realidade é um script que vai interagindo para criação do usuário. A nível de LPI, focar no `useradd`.

#### 107.1 Gerenciamento de Usuários e Grupos - groupadd, groupdel, groupmod

- `groupadd`: adiciona grupo
- `groupdel`: exclui grupo
- `groupmod`: altera configurações do grupo

##### groupadd

- `groupadd suporte`: cria o grupo **suporte**
- `groupadd -g 2000 dev`: cria o grupo **dev** com id 2000

##### groupdel

- `groupdel suporte`: exclui o grupo suporte

##### groupmod

É possível mudar o id e o nome do grupo. No exemplo abaixo está mudando o nome do grupo de **suporte** para **devops**:

- `groupmod -n devops suporte`(`-n` ou `--new-name`): altera o nome do grupo de suporte para devops
- `groupmod -g 2001 suporte`(`-g` ou `--gid`): altera o id do grupo para 2001

*Não é possível excluir um grupo caso se trate do grupo principal de uma conta de usuário. Portanto, é preciso remover o usuário antes de remover o grupo. Quanto aos usuários, se você excluir um grupo, os arquivos pertencentes a esse grupo permanecerão em seu sistema de arquivos e não serão excluídos ou atribuídos a outro grupo.

##### newgrp

Comando faz com que o usuário atual assuma determinado grupo durante a sessão de login.

- `newgrp suporte`: supõe que está logado com **usuario1**, e que esse usuário também faça parte do grupo **suporte**, além de seu próprio (grupo **usuario1**). Ao executar o comando no começo da frase, ele assume o grupo **suporte** como padrão, e arquivos criados serão do grupo **suporte**.

##### senhas nos grupos

Seria uma situação que o usuário não faz parte de um grupo, se tentar, por exemplo, com o comando: `newgrp devops`, e o usuário não fizer parte do grupo, vai pedir uma senha, e somente será admitido ao grupo se souber a senha.

Primeiramente é necessário criar uma senha para o grupo, com o comando:<br>

    gpasswd nome_grupo

Lembrando que se pode observar os grupos que têm senha olhando o arquivo `/etc/gshadow`

Para acessar o grupo, basta usar o comando `newgrp nome_grupo`

> [!CAUTION]
> 
>Utilizar senha em grupo não é recomendado, e é pouquíssimo ou quase não utilizado.

#### 107.1 Gerenciamento de Usuários e Grupos - id, groups, getent e chage

- `id`: imprime o id do usuário e o id dos grupos pertencentes a esse usuário (usuário atual). Ou pode usar colocando o usuário como parâmetro: `id usuario1`

Sequencialmente seria: 
- **id do usuário**; 
- **id do grupo padrão do usuário**;
- **grupos secundários que esse usuário pertence**.

- `groups`: mesmo conceito que no comando `id`, que irá listar os grupos do usuário logado. Podendo também especificar um usuário. Ex. `groups usuario1`<br>
Ex.<br>

```
    $ groups rodrigo
    rodrigo adm cdrom sudo dip plugdev users lpadmin sambashare
```
`getent`: pega informações de grupos/usuários (esse comando exibe entradas de bancos de dados suportados pelas bibliotecas _Name Service Switch_ (NSS) e requer o nome do banco de dados e uma chave de pesquisa)

- `getent passwd rodrigo`: pega informação do usuário rodrigo em `/etc/passwd` (como se fosse um `cat /etc/passwd | grep rodrigo`)
- `getent group suporte`: pega informações do usuário suporte no `/etc/group`

>[!NOTE]
>
>Lembre-se de que o `getent` só pode acessar os bancos de dados configurados no arquivo `/etc/nsswitch.conf`.

##### chage (change age - alterar idade)

`chage`: mostra as propriedades do usuário: quando a senha vai expirar ou ficar ativa/inativo, número máximo entre dias para alterar senha, última vez que usuário mudou a senha, etc
- `chage -l rodrigo`: mostra propriedades do usuário rodrigo (apenas **root** pode ver as propriedades de todos os usuários, os demais somente suas próprias informações)
- `chage -M 60 rodrigo`: força que o usuário troque de senha a cada 60 dias. Execute `chage -l rodrigo` para saber se aplicou mesmo.
- `chage -d "2024-11-13" rodrigo`: (ou `--lastday`): muda a data que da última vez que o usuário mudou a senha. (isso implica se, por exemplo, foi configurado para trocar a senha a cada x dias. Se for 10 dias, e voltar mais de 10 dias da última troca, vai ter que cadastrar uma nova senha, pois a senha é considerada expirada).
- - `chage -E "2024-12-12" rodrigo`: (ou `--expiredate`): define uma data para a conta expirar. Se expirar, ao logar, vai informar que a conta foi expirada, que é preciso falar com o administrador do sistema
- `chage -E -1 rodrigo`: volta a conta ao normal, em referências ao comando anterior.
- `chage -d0 rodrigo`: força o usuário a trocar senha no próximo login (**root enforced**)
- `-I`: define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-W`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>A sequencias mostrada no comando `chage`, é a mesma dentro do arquivo `/etc/shadow`. Inclusive a última coluna, é o número de dias, desde 1970. (Nos sistemas mais novos não foi percebido essa informação).

##### Exercícios interessantes no site lpi.org

Comandos aleatórios:<br>
|   |   |
|---|---|
| `usermod -L` | Bloquear a conta de usuário |
| `passwd -u` | Desbloquear a conta de usuário |
| `chage -E` | Definir a data de expiração da conta de usuário |
| `groupdel` | Excluir o grupo  |
| `useradd -s` |Criar uma nova conta de usuário com um shell de login específico |
| `groupadd -g` | Criar um novo grupo com um GID específico |
| `userdel -r` | Remover a conta de usuário e todos os arquivos em seu diretório inicial, o próprio diretório inicial e o spool de email do usuário |
| `usermod -l` | Alterar o nome de login da conta de usuário |
| `groupmod -n` | Alterar o nome do grupo |
| `useradd -m` | Criar uma nova conta de usuário e seu diretório inicial  |

Comandos correspondentes:<br>

|   |   |
|---|---|
| `passwd -n` | `chage -m` |
| `passwd -x` | `chage -M` |
| `passwd -w` | `chage -W` |
| `passwd -i` | `chage -I` |
| `passwd -S` | `chage -l` |

No Linux, podemos usar o comando `passwd -n` (ou `chage -m`) para definir o número mínimo de dias entre as mudanças de senha, o comando `passwd -x` (ou `chage -M`) para definir o número máximo de dias durante os quais uma senha é válida, o comando `passwd -w` (ou `chage -W`) para definir o número de dias de aviso antes que a senha expire, o comando `passwd -i` (ou `chage -I`) para definir o número de dias de inatividade durante os quais o usuário deve alterar a senha e o comando `passwd -S` (ou `chage -l`) para exibir informações breves sobre a senha da conta de usuário.

Comando para bloquear e desbloquear usuários<br>
`usermod --lock` e `passwd -l`. 
Já para desbloqueá-la, os comandos seriam `usermod -U`, `usermod --unlock` e `passwd -u`.

***O comando `usermod` não inclui a opção de remover apenas um grupo; portanto, você precisa especificar todos os grupos secundários aos quais o usuário pertence.

    # usermod -G administrators,web-designers kevin

Questão 6:<br>
Usando o comando  `chage`, primeiro verifique a data de expiração da conta de usuário  `kevin`  e depois altere-a para 31 de dezembro de 2022. Que outro comando pode ser usado para alterar a data de expiração de uma conta de usuário?

    # chage -l kevin | grep "Account expires"
    Account expires		: never
    # chage -E 2022-12-31 kevin
    # chage -l kevin | grep "Account expires"
    Account expires		: dec 31, 2022

O comando  `usermod`  com a opção  `-e`  equivale a  `chage -E`.

Questão 7:<br>
Adicione uma nova conta de usuário chamada  `emma`  com UID 1050 e defina  `administrators`  como seu grupo principal e  `developers`  e  `web-designers`  como seus grupos secundários.

    # useradd -u 1050 -g administrators -G developers,web-designers emma
    # id emma
    uid=1050(emma) gid=1028(administrators) groups=1028(administrators),1029(developers),1031(web-designers)

## 107.2 Automatizar e agendar tarefas administrativas de sistema

#### Cron

É um daemon, um processo que fica rodando, de agendamento do sistema (normalmente do sistema). Verificar se está rodando com `systemctl status cron`

O arquivo `/etc/crontab` é onde ficam as tarefas de agendamento, que é executado pelo usuário **root** (a tabela de tarefas `cron` é comumente chamado de `contrabs`, que contêm os chamdos `cron jobs` - trabalho cron)

>[!NOTE]
>
>No Linux, também existe o recurso `anacron`, adequado para sistemas que podem ser desligados (como computadores de mesa ou laptops). Ele só pode ser usado pelo root. Se a máquina estiver desligada quando os trabalhos de `anacron` tiverem de ser executados, isso ocorrerá na próxima vez em que se ligar a máquina. O `anacron` está fora do escopo da certificação LPIC-1.

Os 5 primeiros campos são delimitados questões do tempo, sendo, sequencialmente: <br>
**minuto da hora (0-59)** | **hora do dia (0-23)** | **dia do mês - dom (1-31)** | **mês do ano -mon (1-12)** | **dia da semana - dow (0-7 com Domingo=0 ou Domingo=7)**

*Para o mês do ano e o dia da semana, podemos usar as três primeiras letras do nome em vez do número correspondente.

- supõe que esteja com o valor 17 no campo **m** (**minute**), significa que vai executar todo minuto 17.
- `*` = qualquer valor. qualquer minuto, qualquer hora, qualquer dia do mês, etc. Outra forma que facilitar a leitura do asterisco é interpretá-lo como "**seja o dia/hora/mes que for** ou **qualquer valor**"
- **dow (day of week):**
	-  `7` e `0` = domingo, logo: 
	- `1`= segunda-feira, 
	- `2`= terça-feira, etc

- `,`: especifica uma lista de valores possíveis
- `-`(hífen): especifica um intervalor de valores possiveis
- `/`: especifica valores escalonados

A primeira entrada no arquivo `/etc/crontab`:

    17 *	* * *	root	cd / && run-parts --report /etc/cron.hourly

Nesse caso, executa em todo minuto 17, em todas as horas, em todos os dias do mês, todo mês, todos os dias da semana, o que estiver dentro de `/etc/cron.hourly`. A execução de todos os arquivos se deve ao programa `run-parts`.

A sintaxe dos crontabs de sistema é semelhante à dos crontabs de usuário, porém ela requer um campo adicional obrigatório que especifica **qual usuário executará o cron job**. Portanto, cada linha em um crontab de sistema contém sete campos separados por um espaço:

-   O minuto da hora (0-59).
-   A hora do dia (0-23).
-   O dia do mês (1-31).
-   O mês do ano (1-12).
-   O dia da semana (0-7 com Domingo=0 ou Domingo=7).
-   O nome da conta de usuário a ser usada ao executar o comando.
-   O comando a executar.
    
Quanto aos crontabs do usuário, podemos especificar mais de um valor nos campos de tempo usando os operadores  `*`,  `,`  ,  `-`  e  `/`. Também é possível indicar o mês do ano e o dia da semana com as três primeiras letras do nome em vez do número correspondente.

- **crontab de sistema**: `/etc/crontab` e `/etc/cron.d`
	- `/etc/cron.hourly` (de hora em hora)
	- `/etc/cron.daily` (diariamente)
	- `/etc/cron.weekly` (semanalmente)
	- `/etc/cron.monthly` (mensalmente)
- **crontab de usuário**: `/var/spool/cron`

>[!WARNING]
>
>Algumas distribuições usam `/etc/cron.d/hourly`, `/etc/cron.d/daily`, `/etc/cron.d/weekly` e `/etc/cron.d/monthly`. Lembre-se de sempre conferir os diretórios corretos nos quais colocar os scripts que o cron deve executar.

### Especificações de tempo particulares

Ao editar os arquivos crontab, podemos usar atalhos especiais nas primeiras cinco colunas em vez das especificações de tempo:

- `@reboot`: roda a tarefa especificada uma vez após a reinicialização.
- `@hourly`: roda a tarefa especificada uma vez por hora no início da hora.
- `@daily`  (ou  `@midnight`): roda a tarefa especificada uma vez por dia à meia-noite.
- `@weekly`: roda a tarefa especificada uma vez por semana, à meia-noite de domingo.
- `@monthly`: roda a tarefa especificada uma vez por mês, à meia-noite do primeiro dia do mês.
- `@yearly`  (ou  `@annually`): roda a tarefa especificada uma vez por ano, à meia-noite de 1º de janeiro.

**Exemplos**

-   **`@reboot`**
    -   Executa a tarefa apenas uma vez, sempre que o sistema é inicializado.
    -   Exemplo:
        ```
        bash
        
        Copiar código
        
        `@reboot /path/to/script.sh` 
        ```
        
        Uso comum: Iniciar serviços personalizados ou scripts após reiniciar o servidor.
        
-   **`@hourly`**
    -   Executa a tarefa uma vez por hora, no minuto 0.
    -   Equivalente a:
        ```
        `0 * * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@hourly /path/to/script.sh` 
        ```
        
-   **`@daily` (ou `@midnight`)**
    
    -   Executa a tarefa uma vez por dia, à meia-noite.
    -   Equivalente a:
        ```
        `0 0 * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@daily /path/to/script.sh` 
        ```
        
-   **`@weekly`**
    
    -   Executa a tarefa uma vez por semana, no primeiro minuto do domingo.
    -   Equivalente a:
        ```
        `0 0 * * 0` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@weekly /path/to/script.sh` 
        ```
        
-   **`@monthly`**
    
    -   Executa a tarefa uma vez por mês, no primeiro minuto do primeiro dia.
    -   Equivalente a:
        ```
        `0 0 1 * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@monthly /path/to/script.sh` 
        ```
        
-   **`@yearly` (ou `@annually`)**
    
    -   Executa a tarefa uma vez por ano, no primeiro minuto do primeiro dia do ano.
    -   Equivalente a:
        ```
        `0 0 1 1 *` 
        ```
    -   Exemplo:
	   ```
        bash
        
        `@yearly /path/to/script.sh`
	```

#### Variáveis no crontab

Dentro de um arquivo crontab, pode haver atribuições de variáveis definidas antes que as tarefas agendadas sejam declaradas. As variáveis de ambiente comumente definidas são:

- `HOME`: o diretório no qual o  `cron`  invoca os comandos (por padrão, o diretório inicial do usuário).
- `MAILTO`: o nome do usuário ou o endereço para o qual a saída e o erro padrão são enviados (por padrão, o proprietário do crontab). Diversos valores separados por vírgulas também são permitidos, e um valor vazio indica que nenhum email deve ser enviado.
- `PATH`: o caminho no qual os comandos podem ser encontrados.
- `SHELL`: o shell a ser usado (por padrão  `/bin/sh`).

No `crontab`, variáveis como `HOME`, `MAILTO`, `PATH`, e `SHELL` são usadas para definir o ambiente no qual os comandos serão executados. Aqui está uma explicação detalhada e exemplos para cada uma:

---

### 1. **`HOME`**
   - Define o diretório de trabalho padrão para os comandos executados pelo `crontab`.
   - Se não for especificado, o valor padrão geralmente é o diretório home do usuário que criou o crontab.
   - Exemplo:
     ```bash
     HOME=/home/usuario
     @daily /path/to/script.sh
     ```
     Aqui, o script será executado com `/home/usuario` como diretório de trabalho.

---

### 2. **`MAILTO`**
   - Define o endereço de email para o qual serão enviados os logs de saída e erros dos comandos executados.
   - Se definido como vazio (`MAILTO=""`), o email não será enviado.
   - Exemplo:
     ```bash
     MAILTO=admin@exemplo.com
     @hourly /path/to/script.sh
     ```
     Aqui, os logs da execução do script serão enviados para `admin@exemplo.com`.

---

### 3. **`PATH`**
   - Define os diretórios onde o `crontab` buscará os comandos executados.
   - Por padrão, o `PATH` do cron é mais restrito que o de um shell interativo, frequentemente algo como `/usr/bin:/bin`.
   - Exemplo:
     ```bash
     PATH=/usr/local/bin:/usr/bin:/bin
     @daily script.sh
     ```
     Aqui, o cron poderá localizar `script.sh` se ele estiver em qualquer um dos diretórios especificados.

---

### 4. **`SHELL`**
   - Define qual shell será usado para executar os comandos.
   - O valor padrão geralmente é `/bin/sh`.
   - Exemplo:
     ```bash
     SHELL=/bin/bash
     @reboot /path/to/script.sh
     ```
     Aqui, o script será executado usando o Bash em vez do shell padrão.

---

### Exemplo Completo
```bash
SHELL=/bin/bash
HOME=/home/usuario
MAILTO=admin@exemplo.com
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

@hourly /home/usuario/scripts/backup.sh
@daily /home/usuario/scripts/limpeza.sh
```

### O que acontece aqui:
1. O `backup.sh` será executado a cada hora.
2. O `limpeza.sh` será executado diariamente.
3. Os logs dessas tarefas serão enviados para o email `admin@exemplo.com`.
4. Os comandos serão executados no diretório `/home/usuario` usando o Bash.

---

### Dicas Adicionais
- Se seus scripts dependem de variáveis de ambiente específicas (como `JAVA_HOME`), você pode defini-las no início do arquivo `crontab`.
- Teste seus comandos ou scripts manualmente para evitar problemas de execução devido a configurações de ambiente no cron. 

### uso interessante para o dia a dia

    @daily /path/to/script.sh >> /var/log/script.log 2>&1
    
Executa diariamente o script script.sh e joga a saída de sucesso ou de erro no arquivo script.log (2>&1 indica para jogar as duas saídas no arquivo script.log)

Outro exemplo interessante, executar o script  `barfoo.sh`  localizado no diretório  `/root`  todos os dias à 01:30, abra  `/etc/crontab`  com seu editor preferido e adicione a seguinte linha:

    30 01 * * * root /root/barfoo.sh >>/root/output.log 2>>/root/error.log

No exemplo acima, a saída do job é anexada a  `/root/output.log`, enquanto os erros são anexados a  `/root/error.log` (`2>` é a saída padrão para erro, usando `2>>` vai concatenar os valores).

>[!WARNING]
>
>Exceto nos casos em que a saída é redirecionada para um arquivo, como no exemplo acima (ou se a variável `MAILTO` estiver definida como um valor em branco), toda a saída de um trabalho cron será enviada ao usuário via email. Uma prática comum é redirecionar a saída padrão para `/dev/null` (ou para um arquivo, para revisão posterior, se necessário) e não redirecionar o erro padrão. Desta forma, o usuário é notificado imediatamente por email sobre eventuais erros.

### Cron para usuários

Para listar os agendamentos do seu usuário: `contrab -l -u rodrigo`. Se tentar listar agendamentos de outro usuário, se deparará com a mensagem que a opção `-u` deve ser com usuário privilegiado (root ou usuário com privilégio de root).

    must be privileged to use -u

- `crontab -e`: entra no modo de edição do crontab. (primeiro acesso lhe pergunta qual editor que usa). O formato é parecedo com o crontab que foi visto anteriormente, apenas com a exceção que não tem o campo de usuário.

Vejamos um exemplo:<br>

    #m	h	dia	mes	diasemana	comando/script
    15	13	1,10,20,30	* 1-5	/home/rodrigo/Scripts/script.sh >> /tmp/teste-cron.txt

Acima temos:<br>
nos dias 1,10,20,30 às 13h15m, em todo/qualquer mês (`*`), de segunda à sexta-feira (1=segunda, 5=sexta-feira), execute o script em `/home/rodrigo/Scripts/script.sh` e grava a saída do `script.sh` no arquivo `/tmp/teste-cron.txt`<br>
**Observação**: se os dias 1, 10, 20, ou 30 caírem em um sábado ou domingo, o script.sh não vai rodar.

Outro exemplo:

    #m		h	dia		mes	diasemana	comando/script
    */10	*	*		* 	*			/ cd /tmp ; rm -f teste

Nesse caso, a cada 10 minutos o comando será executado. (A `/` significa **a cada**). Se usar `*/5` no dia, seria a cada 5 dias, etc

Mais um exemplo para ilustrar:

    #m		h	dia		mes	diasemana	comando/script
	0		0	1		1	* /usr/bin/fogo-artificio.sh

No dia 1 de Janeiro, de todo ano, às meia noite (hora = 0 e minuto = 0), executa o script `fogos-artificio.sh`

Exemplo com range:<br>

    #m		h		dia		mes	diasemana	comando/script
    20		9-18	*		*	1-5 		/home/usuario/relatorio.sh

Em todo minuto 20, das horas entre 9h e 18h (horário comercial), qualquer dia, qualquer mês, de segunda à sexta-feira, executa o script `relatorio.sh`<br>
Observação: Lembrando que isso é referente ao usuário atual, e os scripts precisam ter permissão de execução.

- `crontab -r`: remove toda configuração do crontab.
- `# crontab -r -u lpi2`: (só root pode) remover crontab de outro usuário
- `crontab -u`: especifica o nome do usuário cujo crontab precisa ser modificado. Esta opção requer privilégios de root e permite que o usuário root edite os arquivos crontab do usuário.

Há possibilidade de criar um arquivo separado contendo as regras da crontab, e importar com o comando: `crontab arquivo_com_contrab`. Confirme com `contrab -l`

Essas modificações, tanto em sistema (`/etc/cron`) como a de usuário, são permanentes, e o(s) arquivo(s) do(s) usuário(s) fica(m) em `/var/spool/cron/crontabs` (precisa ser acesso como **root**). Em algumas distros pode ser que o diretório `crontabs` seja apenas `cron`.

Usuário root pode determinar quem pode e quem não pode utilizar crontab. Isso se baseia nos arquivos:
- /etc/cron.allow ou
- /etc/cron.deny

*Pode ser que esses arquivos não existam, sendo necessário criá-los. A lista de usuários é comum, linha a linha. O `cron.allow` tem prioridade em cima do `cron.deny` (caso tenha os mesmos usuários nas duas listas.

>[!NOTE]
>
>Há uma diferença no comportamento dos arquivos  **/etc/cron.allow**  e  **/etc/cron.deny**  entre sistemas baseados em Debian e RedHat.<br>
No Debian, e distribuições baseadas como o Ubuntu que usamos nesse curso, se ambos arquivos não existem, o uso dos recursos da cron é liberado para todos os usuários.<br>
No entanto, em sistemas baseados em RedHat, como o CentOS, na inexistência dos arquivos, o uso é bloqueado a todos os usuários, exceto para o usuário root.

#### Exercício interessante no lpi.org

Crie um job agendado simples que execute o comando  `date`  todas as sextas-feiras às 13h. Onde você poderia ver o resultado deste trabalho?

    00 13 * * 5 date

A saída é enviada ao usuário; para visualizá-la, use o comando  `mail`(no caso, é possível ver a saída com esse comando, mas precisa ter o pacote **mailutils** instalado (`apt install mailutisl`)

#### Exercício com MAILTO

Como é possível enviar a saída e os erros do seu trabalho agendado para a conta de usuário  `emma`  via email? E como evitar o envio da saída padrão e erros por email?

Para enviar a saída padrão e o erro para  `emma`, definimos a variável de ambiente  `MAILTO`  em nosso arquivo  `crontab`  desta forma:

    MAILTO="emma"

Para dizer ao  `cron`  que nenhum email deve ser enviado, atribuímos um valor vazio à variável de ambiente  `MAILTO`.

    MAILTO=""

### at (agendamento de uma execução)

Tipo de agendamento em determinada hora/momento (executa apenas uma vez)

    at now +2hour
    at> echo "Hora cafe"

Executa o echo `"Hora do café"` daqui duas horas, e poderia ir adicionando comandos. No final use `Ctrl+D` para adicionar essa tarefa (job).<br>
**(Como no caso do `cron`, a saída padrão e o erro são enviados por email)<br>
***Observe que o daemon `atd` precisará estar rodando no sistema para ser possível usar o agendamento de tarefas `at`

>[!NOTE]
>
>No Linux, o comando `batch` é semelhante a `at`, porém os jobs `batch` são executados apenas quando a carga do sistema está baixa o suficiente para permiti-lo.

- `atq` ou `at -l`: mostra os jobs que estão aguardando (vem de `queue`).

>[!NOTE]
>
>Se você executar `atq` como root, ele exibirá os trabalhos na fila para todos os usuários.

```
at 13:20
at> echo "Hora do almoço
```

Executa o echo às `13:20`. Caso já tenha passado esse horário, o at agenda para o dia seguinte. (para especificar quando um job `at` determinado deve ser executado, use o formato `HH:MM`, seguido opcionalmente por **AM** ou **PM** no caso do formato de 12 horas)

Formatos aceitos para passar uma data após a hora:
- `MMDDYY`
- `MM/DD/YY`
- `DD.MM.YY` e
- `YYYY-MM-DD`

- `at midnight`: agenda para meia noite
- `at teatime`: agenda para às 16h ou 4PM (hora do chá)
- `at noon`: agenda para hora do almoço - meio-dia
- `now`: para agora

- `at 02:20pm 05202024`: agenda para dia 20/05/2024 às 14:20

Para **remover** algum job feito pelo at: `atrm 10` ou `at -d 10`: remove o job 10.

>[!NOTE]
>
>O usuário que rodar `atrm` como root pode excluir os jobs de todos os outros usuários.

- `/etc/at.allow`: permite quais usuário usar o `at`
- `/etc/at.deny`: nega quais usuário a usar o `at` (esse já vem criado, preenchido com usuários do sistema, permitindo somente usuários comuns utilizar)

**As opções mais importantes do comando**  `at`  são:

- `-c`: imprime os comandos de um ID de trabalho específico na saída padrão.
- `-d`: exclui trabalhos com base em seu ID de trabalho. É um alias para  `atrm`.
- `-f`: lê o job em um arquivo em vez da entrada padrão.
- `-l`: lista as tarefas pendentes do usuário. Se o usuário for root, todos os trabalhos de todos os usuários serão listados. É um alias para  `atq`.
- `-m`: envia um email para o usuário no final do trabalho, mesmo se não houver saída.
- `-q`: especifica uma fila na forma de uma única letra de  `a`  a  `z`  e de  `A`  a  `Z`  (por padrão,  `a`  para  `at`  e  `b`  para  `batch`). Os jobs nas filas com as letras mais altas são executados com um valor nice maior. Os jobs enviados a uma fila com uma letra maiúscula são tratados como trabalhos em lote (`batch`).
- `-v`: mostra a hora em que o trabalho será executado antes de ler o trabalho.

Leia o arquivo `timespec` na árvore `/usr/share` para saber mais sobre a definição exata das especificações de data e hora.

#### Agendamento de Tarefas - systemd timer

- `systemct list-timers`: lista os agendamentos que já estão no sistema, no caso `UNITs`, com sufixo  (terminam com)`.timer`, ligadas às `ACTIVATES`, com sufixo (terminam com) `.service` (Por padrão, um `timer` ativa um serviço com o mesmo nome, exceto pelo sufixo).
- `systemct list-timers --all`: mostra agendamentos que possam estar inativas
- `systemctl list-units --type=timer`: lista as unidades do tipo `timer`

Para observar uma unit, é possível pode meio do comando:<br>
- `systemct list-timers`

```
$ systemctl status apt-daily-upgrade.timer 
● apt-daily-upgrade.timer - Daily apt upgrade and clean activities
     Loaded: loaded (/usr/lib/systemd/system/apt-daily-upgrade.timer; enabled; preset: enabled)
     Active: active (waiting) since Fri 2024-11-08 16:41:52 -03; 5 days ago
    Trigger: Fri 2024-11-15 06:13:26 -03; 16h left
   Triggers: ● apt-daily-upgrade.service

Nov 08 16:41:52 OptiPlex-3080 systemd[1]: Started apt-daily-upgrade.timer - Daily apt upgrade and clean activities.
```

Na terceira linha, é mostrado onde está configurado o `.timer`, no caso: `/usr/lib/systemd/system/apt-daily-upgrade.timer`(esse arquivo que seria alterado para definir novo agendamento). Sendo em um formato normal de unit, com sua descrição, e demais itens.

O que é interessante é a parte de `[Timer]`, onde tem a opção `onCalendar`, com a seguinte sintaxe:
- `OnCalendar= *-*-* 6:00`: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) às 6 horas.
- `OnCalendar= *-*-* 6..18:00,30 `: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) das 6 até às 18h, no minuto 00 e minuto 30. Se preferir, pode adicionar dois pontos (`:`) e informar os segundos, ou `*` para qualquer segundo.
- `OnCalendar=Mon..Fri *-*-* 6:00`: caso queira colocar de segunda à sexta-feira (entre dois valores para indicar um intervalo contíguo)
- `OnCalendar=Sat,Sun *-*-* 6:00`: caso queira colocar sábado e domingo (padrão para **Debian** e derivados - **RedHat** seria `Mon-Fri`)

- `RandomizedDelaySec=60m`: nessa faixa de 60 minutos, a execução pode fica aleatória dentro desse tempo, para que não tenha várias coisas executando ao mesmo tempo, achando um gap melhor para essa execução.
- `Persistend=true`: grava caso o `.service` seja executado manualmente. E considera essa informação para a próxima execução.

Na Unit do `.service`, é basicamente um `.service` comum, que é descrito o que será executado no `ExecStart`.<br>
Mais detalhes em `man systemd.timer`. Mais detalhes de como especificar a data e hora no calendar, usar: `man systemd.time`

Vejamos o exemplo de `systemd-tmpfiles-clean.timer`:<br:
- executa `systemctl status systemd-tmpfiles-clean.timer` para saber onde está carregado esse arquivo, no caso é em `/usr/lib/systemd/system/systemd-tmpfiles-clean.timer`, tendo como conteúdo:
```
[Unit]
Description=Daily Cleanup of Temporary Directories
Documentation=man:tmpfiles.d(5) man:systemd-tmpfiles(8)
ConditionPathExists=!/etc/initrd-release

[Timer]
OnBootSec=15min
OnUnitActiveSec=1d
```
Em `OnUnitActiveSec`, é informado que se a unidade estiver ativa, para executar o serviço a cada 1 dia. Em `OnBootSec` é nítido que será executado após 15 minutos. Isso é para casos que o sistema não é desligado.

**Outro exemplo interessante listado nas lições da lpi.org**

Por exemplo, para rodar o serviço  `/etc/systemd/system/foobar.service`  às 05:30 da primeira segunda-feira do mês, adicionamos as seguintes linhas no arquivo de unidade  `/etc/systemd/system/foobar.timer`  correspondente:

    [Unit]
    Description=Run the foobar service
    
    [Timer]
    OnCalendar=Mon *-*-1..7 05:30:00
    Persistent=true
    
    [Install]
    WantedBy=timers.target

Depois de criar o novo temporizador, você pode ativá-lo e iniciá-lo executando os seguintes comandos como root:

    # **systemctl enable foobar.timer**
    # **systemctl start foobar.timer**

Podemos alterar a frequência do trabalho agendado modificando o valor  `OnCalendar`  e, em seguida, digitando o comando  `systemctl daemon-reload`.

Finalmente, se você quiser ver a lista de temporizadores ativos ordenados pelo momento em que terminam, use o comando  `systemctl list-timers`. A opção  `--all`  exibe também as unidades de temporizador inativas.

>[!NOTE]
>
>Lembre-se de que os temporizadores são registrados no diário (journal) do systemd e você pode rever os registros das diferentes unidades usando o comando  `journalctl`. Além disso, se estiver trabalhando como um usuário comum, será preciso usar a opção  `--user`  dos comandos  `systemctl`  e  `journalctl`.

##### Criando um agendamento

1. criar um **serviço**, dentro de `/etc/systemd/system`:
	1.1 usar `vim exemplo.servce`
```
[Unit]
Description=Exemplo systemd-timer

[Service]
Type=oneshot
ExecStart=/bin/sh -c '/bin/date >> /tmp/exemplo-system.txt'
```

2. criar um **timer**, dentro de `/etc/systemd/system`:
	2.1 usar `vim exemplo.timer` (usar o mesmo nome, mudando só o final)
```
[Unit]
Description=Teste de systemd

[Timer]
OnCalendar=*-*-* *:*:10 # toda hora, todo min, no segundo 10

AccuracySec=1us # 1 micro segundo ou 1ms, que é a margem para executar com precisão. Se for muito alto, lembrar que tem prioridade.

Unit=teste.service
```

No `OnCalendar`, pode informar só a hora: `OnCalendar=*:*:10`<br>
No `AccuracySec` lembrar da prioridade, se colocar tempo muito alto e se estiver tendo muita execução, vai utilizar um tempo random dentro do intervalo colocado

Se rodar `systemctl list-timer`, o timer feito não aparece. Portanto é preciso iniciar o timer criado: `systemctl start exemplo.timer`. Executando novamente `systemctl list-timer`, já vai aparecer na lista. É interessante também recarregar as informações do daemon do systemctl, com o comando `systemctl daemon-reload`

Em vez da forma normalizada mais longa mencionada acima, é possível usar algumas expressões especiais que descrevem frequências específicas para a execução de um job:

- `hourly`: roda a tarefa especificada uma vez por hora, no início da hora.
- `daily`: roda a tarefa especificada uma vez por dia à meia-noite.
- `weekly`: roda a tarefa especificada uma vez por semana, na meia-noite de segunda-feira.
- `monthly`: roda a tarefa especificada uma vez por mês, na meia-noite do primeiro dia do mês.
- `yearly`: roda a tarefa especificada uma vez por ano, na meia-noite de 1º de janeiro.

Consulte as páginas de manual para ver a lista completa de especificações de hora e data em  `systemd.timer(5)`.

No **`systemd`**, os **timers** substituem ou complementam o uso do `cron` para agendamento de tarefas, proporcionando maior flexibilidade e integração com o sistema. Aqui estão os equivalentes aos atalhos do `crontab` usando **`systemd.timer`**:

---

### Estrutura de um Timer no `systemd`
Um timer no `systemd` geralmente é composto por dois arquivos:

1. **Arquivo de Serviço (`.service`)**
   - Define o que será executado.
2. **Arquivo de Timer (`.timer`)**
   - Define quando será executado.

---

### Equivalentes no `systemd.timer`
Os timers no `systemd` usam o campo `[Timer]` para configurar os intervalos de execução. Aqui estão os exemplos:

1. **`@reboot` (ao iniciar o sistema)**
   - Use o parâmetro **`OnBootSec`** no arquivo `.timer`.
   - Exemplo:
     ```ini
     [Timer]
     OnBootSec=1min
     ```
     Este timer executará a tarefa 1 minuto após o sistema inicializar.

2. **`@hourly` (uma vez por hora)**
   - Use **`OnCalendar`** com o valor `hourly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=hourly
     ```
     Este timer será acionado no início de cada hora.

3. **`@daily` (uma vez por dia, à meia-noite)**
   - Use **`OnCalendar`** com o valor `daily`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=daily
     ```
     O timer será acionado diariamente à meia-noite.

4. **`@weekly` (uma vez por semana, no domingo)**
   - Use **`OnCalendar`** com o valor `weekly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=weekly
     ```
     O timer será acionado no primeiro minuto de cada domingo.

5. **`@monthly` (uma vez por mês, no primeiro dia)**
   - Use **`OnCalendar`** com o valor `monthly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=monthly
     ```
     O timer será acionado no primeiro minuto do dia 1 de cada mês.

6. **`@yearly` (ou `@annually`)**
   - Use **`OnCalendar`** com o valor `yearly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=yearly
     ```
     O timer será acionado no primeiro minuto do primeiro dia de cada ano.

---

### Exemplo Completo
Aqui está um exemplo completo para criar um serviço e um timer que executam um script diariamente.

### Arquivo de Serviço (`exemplo.service`)
```ini
[Unit]
Description=Executa o script de exemplo

[Service]
ExecStart=/path/to/script.sh
```

### Arquivo de Timer (`exemplo.timer`)
```ini
[Unit]
Description=Executa o script de exemplo diariamente

[Timer]
OnCalendar=daily

[Install]
WantedBy=timers.target
```

#### Comandos para Ativar
1. Coloque os arquivos em `/etc/systemd/system/`.
2. Habilite o timer:
   ```bash
   sudo systemctl enable exemplo.timer
   ```
3. Inicie o timer:
   ```bash
   sudo systemctl start exemplo.timer
   ```

---

### Vantagens do `systemd.timer`
- Integração nativa com o `systemd` (logs em `journalctl`).
- Opções adicionais, como **`AccuracySec`** (ajustar precisão) e **`Persistent`** (executar tarefas perdidas durante períodos de inatividade).

Isso torna o `systemd` uma alternativa poderosa ao `cron` para tarefas agendadas! 

##### systemd-run (equivalente ao at)

Normalmente ele é usado para criar uma unidade transiente de temporizador para que um comando seja executado em um momento específico sem a necessidade de se criar um arquivo de serviço

Por exemplo, atuando como root, você pode executar o comando  `date`  às 11h30 em 06/10/2019 usando o seguinte:

    # **systemd-run --on-calendar='2019-10-06 11:30' date**

Se quiser executar o script  `foo.sh`, localizado em seu diretório atual, depois de dois minutos, use:

    # **systemd-run --on-active="2m" ./foo.sh**

- `system-run --on-active=60s /bin/touch /tmp/exemplo-run.txt`: roda após **60 segundos** o comando `touch` que criar o arquivo `exemplo-run.txt` em `/tmp`
- `system-run --on-active=60s --time-property=AccuracySec=1ms /bin/touch /tmp/exemplo-run.txt`: faz o mesmo do comando anterior, mas em system-run também tem a questão de prioridade, e se quiser com precisão, precisar incluir o argumento `--time-property`

É possível observar que após rodar o `system-run` acima, será retornado um run, que no caso é algo parecido com isso: `run-sequecia-caracteres.timer`

Se pegar esse `.timer` e olhar no `journalctl`, com a opção `-u` `--unit`, mais o `run` (`journalctl -u run-sequecia-caracteres.timer`), é possível notar que já está rodando (mas o comando ainda não foi executado - lembre-se, foi configurado para 60 segundos).

Se olhar no `systemctl list-timers` o `run-sequecia-caracteres.timer` que foi criado, vai estar listado, mostrando quanto tempo falta para sua hora de executar.

Depois que passar os 60 segundos, ele irá executar, e **não** irá mais aparecer no `systemctl list-timers`. Mostrando que fez 1 execução apenas. É possível ter certeza verificando o .service dele, com o comando `journalctl -u run-sequecia-caracteres.service`

Consulte as páginas de manual para aprender todos os usos possíveis de  `systemd-run`  com  `systemd-run(1)`.

>[!NOTE]
>
>Os temporizadores são registrados no diário do systemd e você pode rever os registros das diferentes unidades usando o comando `journalctl`. Além disso, se estiver trabalhando como um usuário comum, precisará usar a opção `--user` dos comandos `systemctl` e `journalctl`.

## 107.3 Localização e internacionalização

Para o Linux, o horário padrão é o UTC (Tempo Universal Coordenado). O UTC substituiu o GMT (Greenwich Meridian Time) ou Z (Zulu), que se baseava na hora local de Greenwich. Depois disso ele pega e converte para o que foi configurado de acordo com a localização.

- `timedatectl`: (disponível em distribuições que usam o `systemd`) é um date melhorado, mais completo, que descreve a **data/hora** em diferentes formatos (embora o `date` também mostre o deslocamento em relação a UTC.)

Tudo isso fica configurado em `/etc/localtime` (é um arquivo que não tem como ler, nele fica configurado a questão do **timezone**, horário de verão - **daylight saving time**). Lembrando que `/etc/localtime` aponta para `/usr/share/zoneinfo/America/Sao_Paulo` (a depender da sua localização).

    ls -l /etc/localtime 
    lrwxrwxrwx 1 root root 37 Nov  8 16:21 /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo

Vendo em `/usr/share/zoneinfo/Brazil` é possível notar onde `/etc/localtime` está apontando:

    ls -l /usr/share/zoneinfo/Brazil/
    total 0
    lrwxrwxrwx 1 root root 21 Nov  8 16:20 Acre -> ../America/Rio_Branco
    lrwxrwxrwx 1 root root 18 Nov  8 16:20 DeNoronha -> ../America/Noronha
    lrwxrwxrwx 1 root root 20 Nov  8 16:20 East -> ../America/Sao_Paulo
    lrwxrwxrwx 1 root root 17 Nov  8 16:20 West -> ../America/Manaus

Em `/etc/timezone` está contido o fuso horário padrão padrão do sistema: (se der um `cat` nesse arquivo, retorna `America/Sao_Paulo`)

Os nomes genéricos de fusos horários indicados pela diferença em relação a UTC devem incluir  `Etc`  na primeira parte do nome. Assim, para definir o fuso horário padrão como GMT+3, o nome do fuso horário deve ser  `Etc/GMT+3`:

    $ **cat /etc/timezone**
    Etc/GMT+3

- `tzselect`: usado para ajudar a selecionar o **timezone** correto/desejado. (Também é possível especificar o fuso horário com coordenadas geográficas ou com a notação de deslocamento, também conhecida como _formato Posix TZ_)

Para alterar o timezone apenas da sessão atual, pode-se alterar a variável `$TZ`:<br>

    - export TZ=America/Chicago<br>

*Faça um date antes e depois de alterar o timezone para perceber as mudanças:<br>

    $ date
    Mon Nov 18 20:22:49 AM -03 2024
    $ export TZ=America/Los_Angeles
    $ date
    Mon Nov 18 15:23:05 AM PST 2024

*Lembrando que isso apenas está traduzindo o que está internamente no UTC. Para voltar a data no timezone que estava antes, basta executar: `unset TZ`.

Ainda alterando o `TZ`, se criar um arquivo, a data de criação atualiza caso o `TZ` seja alterado. Isso se torna interessante quando há usuário de diferentes timezones, para que possa ajustar de acordo com a localização (ajustar no `.bashrc`, por exemplo - ou até mesmo para todos os usuário, em `/etc/profile`).

>[!NOTE]
>
>Só o território brasileiro abrange quatro fusos horários.

A mudança por meio da variável prevalece a configuração em `/etc/localtime`. Podemos preencher da forma por extenso também:

    TZ=:/usr/share/zoneinfo/America/Sao_Paulo

Para alterar por meio do `/etc/localtime`, basta remover o link atual, e apontar para um novo (esse novo é possível consultar por meio das opções que há em `/usr/share/zoneinfo`)

    $ ls -l /etc/localtime
    /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo
    
    rm -f /etc/localtime
    
    ln -s /usr/share/zoneinfo/Asia/Bangkok /etc/localtime

Confirme as mudanças com os comandos `date` e `timedatectl`. As mudanças são refletidas de imediato.

Uma máquina conectada pode ser acessada de diferentes partes do mundo, de forma que é aconselhável definir o relógio do hardware para UTC (o fuso horário GMT+0) e deixar a escolha do fuso horário para cada caso particular. Os serviços em nuvem, por exemplo, costumam ser configurados para usar UTC, o que pode ajudar a mitigar eventuais inconsistências entre o horário local e o horário dos clientes ou de outros servidores. Por outro lado, os usuários que abrem uma sessão remota no servidor podem querer usar seu fuso horário local. Assim, caberá ao sistema operacional configurar o fuso horário correto de acordo com cada caso.

### Localização e Internacionalização - Idioma, Linguagem e Codificação

- `locale`: lista informações específicas de acordo com locais, países no mundo, tais como: sistema monetário, se usa vírgula ou ponto, formato de datas, etc, assim como o tipo de codificação de caracteres. (tudo isso são variáveis de ambiente - vide `env | grep "^LC"`, perceba que há uma chamada `LC_ALL`, que sobrescreve todas as demais).

É possível configurar pelo `.bashrc` ou `/etc/profile`, definindo diretamente as variáveis por sessão ou para todos os usuários, respectivamente.

Por exemplo, caso esteja utilizando o modelo brasileiro de representação dos números, em uma moeda, e queira mudar para o modelo dos Estados Unidos, use: `export  LC_AL=en_US.UTF-8`. Para remover, `unset LC_ALL`.

Ex. **en_US.UTF-8** ou **pt_BR.UTF-8** (codificação usada na instalação)

- `locale -a` (`--all-locales`): lista os modelos disponíveis para o uso.

### Conversão de codificação

O primeiro mais antigo é o ASCII (_American Standard Code for Information Interchange_), depois foi melhorado para ISO/IEC 8859-1, e UTF-8 é o mais recente/utilizado. Se escrever um arquivo com caracteres especiais no Windows, e abrir no Linux, vai haver divergência (lembrando que para verificar a codificação do arquivo, pode-se utilizar o comando `file nome_arquivo`)

- `iconv -f ISO-8859-1 -t UTF-8 nome_do_arquivo`: (`-f` ou `--from-code` e `-t` ou `--to-encode`) converte o arquivo, que antes estava na decodificação do Windows, para a codificação que o Linux entende. (para casos que um texto no Windows não leia no Linux)
Para listar todas as codificações suportadas pelo comando `iconv`, usamos o comando `iconv -l` ou `iconv --list`. Ao invés de usar o redirecionamento de saída, como no exemplo, a opção `-o converted.txt` ou `--output converted.txt` também faz o serviço.

#### Exercicio sobre iconv

Os caracteres dos arquivos de texto podem não ser exibidos corretamente em um sistema com uma codificação de caracteres diferente da usada na criação do documento de texto. Como o  `iconv`  pode ser usado para converter o arquivo  `old.txt`, codificado em WINDOWS-1252, no arquivo  `new.txt`, que usa a codificação UTF-8?

O comando  `iconv -f WINDOWS-1252 -t UTF-8 -o new.txt old.txt`  realizará a conversão desejada.


>[!TIP]
>
>O comando `localectl`, disponível em sistemas que empregam o _systemd_ como gerenciador de sistema, também pode ser usado para consultar e alterar a localidade do sistema. Por exemplo: `localectl set-locale LANG=en_US.UTF-8`.

Além da variável  `LANG`, outras variáveis de ambiente afetam aspectos específicos da localidade, como o símbolo monetário ou o separador de milhar correto para números:
- `LC_COLLATE`: define a ordem alfabética. Uma de suas finalidades é definir a ordem em que os arquivos e diretórios são listados.
- `LC_CTYPE`: define como o sistema tratará certos conjuntos de caracteres. Ele define, por exemplo, quais caracteres considerar como  _maiúsculas_  ou  _minúsculas_.
- `LC_MESSAGES`: define o idioma para exibir as mensagens de programas (principalmente programas do GNU).
- `LC_MONETARY`: define a unidade monetária e o formato da moeda.
- `LC_NUMERIC`: define o formato numérico para valores não-monetários. Sua finalidade principal é definir os separadores de milhar e decimais.
- `LC_TIME`: define o formato de hora e data.
- `LC_PAPER`: define o tamanho padrão do papel.
- `LC_ALL`: sobrepõe todas as outras variáveis, incluindo  `LANG`.

O comando  `locale`  mostra todas as variáveis definidas na configuração de localidade atual:

    $ **locale**
    LANG=pt_BR.UTF-8
    LC_CTYPE="pt_BR.UTF-8"
    LC_NUMERIC=pt_BR.UTF-8
    LC_TIME=pt_BR.UTF-8
    LC_COLLATE="pt_BR.UTF-8"
    LC_MONETARY=pt_BR.UTF-8
    LC_MESSAGES="pt_BR.UTF-8"
    LC_PAPER=pt_BR.UTF-8
    LC_NAME=pt_BR.UTF-8
    LC_ADDRESS=pt_BR.UTF-8
    LC_TELEPHONE=pt_BR.UTF-8
    LC_MEASUREMENT=pt_BR.UTF-8
    LC_IDENTIFICATION=pt_BR.UTF-8
    LC_ALL=

A única variável indefinida é  `LC_ALL`, que pode ser usada para substituir temporariamente todas as outras configurações locais. O exemplo a seguir mostra como o comando  `date` — sendo executado em um sistema configurado para a localidade  `pt_BR.UTF-8` — modifica sua saída de forma a cumprir a nova variável  `LC_ALL`:

    $ **date**
    seg out 21 10:45:21 -03 2019
    $ **env LC_ALL=en_US.UTF-8 date**
    Mon Oct 21 10:45:21 -03 2019

A modificação da variável `LC_ALL` fez com que ambas as abreviações de dia da semana e nome do mês fossem mostradas em inglês americano (`en_US`). Não é obrigatório, entretanto, definir a mesma localidade para todas as variáveis. É possível, por exemplo, ter a linguagem definida como `pt_BR` e o formato numérico (`LC_NUMERIC`) no padrão americano.

Algumas configurações de localização alteram a forma como os programas lidam com a ordem alfabética e formatos de numeração. Embora os programas convencionais geralmente sejam capazes de escolher corretamente uma localidade comum para essas situações, os scripts podem se comportar de forma inesperada ao tentar ordenar corretamente uma lista de itens em ordem alfabética, por exemplo. Por este motivo, recomenda-se definir a variável de ambiente `LANG` para a localidade comum `C`, como em `LANG=C`, para que o script produza resultados inequívocos, independentemente das definições de localização usadas no sistema onde é executado. A localidade C realiza apenas uma comparação simples de bytes e, portanto, também terá um desempenho melhor do que as outras.

## 108.1 Manutenção da data e hora do sistema

### Manutenção do Horário do Sistema - Relógios e os comandos date e hwclock

**hardware clock**: relógio da BIOS (aquela que usa bateria para armazenar data/hora)

**software clock**: relógio do Linux propriamente dito, depois que o SO sobe

Em linhas gerais, o hardware e software clock não são sincronizados pois são independentes. Isso fica nítido quando o computador está ligado por muito tempo.

- `date`: retorna a hora no sistema
- `date -u`: retorna data/hora UTC (GMT0)
- `date 12251200`: ajusta o relógio para 12 de dezembro às 12:00 (o ano é opcional). Opção com ano seria: `date 122512002024` (precisa ser como root).
- `date --set="11 Nov 2011 11:11:11"`: também redefine o horário. Neste caso, é necessário ter privilégios de root para definir a data. Também podemos optar por alterar a hora ou data independentemente:
```
    # date +%Y%m%d -s "20111125"
```
Aqui, devemos especificar as sequências para que nossa string seja analisada corretamente. Por exemplo,  `%Y`  refere-se ao ano e, portanto, os primeiros quatro dígitos  `2011`  serão interpretados como o ano de 2011. Da mesma forma,  `%T`  é a sequência de hora, como demonstrado aqui ao definirmos a hora (`-s` ou `--set`):
```
# date +%T -s "13:11:00"
```
Depois de alterar a hora do sistema, é recomendável também definir o relógio do hardware para que os relógios do sistema e do hardware estejam sincronizados:
```
# hwclock --systohc
```
Outras opções comumente usadas retornam a hora local em um formato RFC aceito:
- `-I`:  data/hora no formato ISO 8601. Anexar  `date`  (`-Idate`) limita a saída apenas à data. Outros formatos são  `hours`,  `minutes`,  `seconds`  e  `ns`  (para nanossegundos).
- `-R`:  retorna data e hora no formato RFC 5322.
- `--rfc-3339`:  retorna data e hora no formato RFC 3339.

O formato de  `date`  pode ser personalizado pelo usuário com as sequências especificadas na página de manual. Por exemplo, a hora atual pode ser formatada como tempo do Unix da seguinte maneira:

    $ date +%s
    1574014515

Na página de manual de  `date`, podemos ver que  `%s`  se refere ao tempo do Unix.

O tempo do Unix é usado internamente na maioria dos sistemas baseados em Unix. Ele armazena a hora UTC como o número de segundos desde a  _Época_, que foi definida como 1º de janeiro de 1970.

>[!NOTE]
>
>O número de bits necessários para armazenar a hora Unix no momento atual é de 32 bits. No futuro, 32 bits se tornarão insuficientes para conter a hora atual no formato Unix. Isso causará problemas sérios para qualquer sistema Linux de 32 bits. Felizmente, isso não ocorrerá até 19 de janeiro de 2038.

A opção  `--debug`  é muito útil para garantir que uma data possa ser analisada com sucesso. Observe o que acontece ao passarmos uma data válida para o comando:

    $ date --debug --date="Fri, 03 Jan 2020 14:00:17 -0500"
    date: parsed day part: Fri (day ordinal=0 number=5)
    date: parsed date part: (Y-M-D) 2020-01-03
    date: parsed time part: 14:00:17 UTC-05
    date: input timezone: parsed date/time string (-05)
    date: using specified time as starting value: '14:00:17'
    date: warning: day (Fri) ignored when explicit dates are given
    date: starting date/time: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05'
    date: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05' = 1578078017 epoch-seconds
    date: timezone: system default
    date: final: 1578078017.000000000 (epoch-seconds)
    date: final: (Y-M-D) 2020-01-03 19:00:17 (UTC)
    date: final: (Y-M-D) 2020-01-03 14:00:17 (UTC-05)

Essa é uma ferramenta útil para a resolução de problemas em um aplicativo que gera uma data.

- `hwclock` (`apt install util-linux-extra`): mostra o relógio do BIOS

O `hwclock` serve ainda para sincronizar o horário do sistema igual ao do horário do hardware, ou vice-versa.

- `hwclock -w` ou `--systohc` (**hc**=**hardware clock**): pega o horário do sistema e sincroniza com o relógio no BIOS: Sys->Bios
- `hwclock -s` ou `--hctosys`: faz o contrário, pega o horário do BIOS e sincroniza com o relógio do Linux: Bios->Sys

- `hwclock --set --date "12/25/2024 14:00"`: define o horário na BIOS<br>
**Na aula o comando acima retorna erro, formato inválido para a data. Procurando no man , o formato usado é: <br>
```
    sudo hwclock --set --date "YYYY-MM-DD HH:MM:SS"
```
- `hwclock  --verbose`: retorna mais resultados, que podem ser úteis para solucionar problemas. Observe o `Calculated Hardware Clock drift`. Esta saída informa se a hora do sistema e a hora do hardware estão divergindo uma da outra.

>[!NOTE]
>
>Para fins de logs, é utilizado o horário do sistema.

>[!NOTE]
>
>Alguns processos internos (principalmente em distros baseadas em Ubuntu), a hora é atualizada automaticamente.

- `timedatectl`  é um comando que pode ser usado para verificar o status geral de hora e data, incluindo se a hora da rede foi ou não sincronizada (na próxima lição, trataremos do Network Time Protocol).

Por padrão,  `timedatectl`  retorna informações semelhantes a  `date`, mas com a adição da hora RTC (hardware), bem como o status do serviço NTP:

    $ timedatectl
                   Local time: Thu 2019-12-05 11:08:05 EST
               Universal time: Thu 2019-12-05 16:08:05 UTC
                     RTC time: Thu 2019-12-05 16:08:05
                    Time zone: America/Toronto (EST, -0500)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Se o NTP não estiver disponível, recomenda-se usar  `timedatectl`  em vez de  `date`  ou  `hwclock`  para definir a hora:

    # **timedatectl set-time '2011-11-25 14:00:00'**

O processo é semelhante ao de  `date`. O usuário também pode definir a hora independentemente da data com o formato **HH:MM:SS**

### Definindo o fuso horário com timedatectl

`timedatectl`  é a melhor maneira de configurar o fuso horário local nos sistemas Linux baseados em  `systemd`  quando não existe GUI.  `timedatectl`  lista os fusos horários possíveis e, a partir daí, o fuso horário pode ser definido usando um deles como argumento.

Primeiro, listamos os fusos horários possíveis:

    $ **timedatectl list-timezones**
    Africa/Abidjan
    Africa/Accra
    Africa/Algiers
    Africa/Bissau
    Africa/Cairo
    ...

A lista de fusos horários possíveis é longa, por isso o uso do comando  `grep`  é recomendado neste caso.

Em seguida, podemos definir o fuso horário usando um dos elementos da lista retornada:

    $ timedatectl set-timezone Africa/Cairo
    $ timedatectl
                   Local time: Thu 2019-12-05 18:18:10 EET
               Universal time: Thu 2019-12-05 16:18:10 UTC
                     RTC time: Thu 2019-12-05 16:18:10
                    Time zone: Africa/Cairo (EET, +0200)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Lembre-se de que o nome do fuso horário deve ser exato.  `Africa/Cairo`, por exemplo, muda o fuso horário, mas  `cairo`  ou  `africa/cairo`  não.

### Desativando o NTP com timedatectl

Em alguns casos, pode ser necessário desativar o NTP. Podemos fazer isso com  `systemctl`, mas vamos demonstrar o procedimento com  `timedatectl`:

    # timedatectl set-ntp no
    $ timedatectl\
                 Local time: Thu 2019-12-05 18:19:04 EET Universal time: Thu 2019-12-05 16:19:04 UTC
                   RTC time: Thu 2019-12-05 16:19:04
                  Time zone: Africa/Cairo (EET, +0200)
                NTP enabled: no
           NTP synchronized: no
            RTC in local TZ: no
                 DST active: n/a

### Definindo o fuso horário sem timedatectl

A definição do fuso horário é uma etapa padrão ao se instalar o Linux em uma nova máquina. Se houver um processo de instalação gráfico, isso provavelmente será feito sem nenhuma ação adicional do usuário.

O diretório  `/usr/share/zoneinfo`  contém informações sobre os diferentes fusos horários possíveis. No diretório  `zoneinfo`, há subdiretórios com o nome dos continentes, bem como outros links simbólicos. Recomenda-se encontrar o  `zoneinfo`  da sua região começando por seu continente.

Os arquivos  `zoneinfo`  contêm as regras necessárias para calcular a diferença de horário local em relação a UTC e também são importantes se a sua região segue o horário de verão. O conteúdo de  `/etc/localtime`  será lido quando o Linux precisar determinar o fuso horário local. Para definir o fuso horário sem o uso de uma GUI, o usuário deve criar um link simbólico de  `/usr/share/zoneinfo`  para  `/etc/localtime`  informando sua localização. Por exemplo:

    $ **ln -s /usr/share/zoneinfo/Canada/Eastern /etc/localtime**

Depois de definir o fuso horário correto, recomenda-se executar:

    # **hwclock --systohc**

Isso configurará o  _relógio do hardware_  a partir do  _relógio do sistema_  (ou seja, o relógio em tempo real será configurado para a mesma hora que  `date`). Note que este comando é executado com privilégios de root; neste caso, você está logado como root.

`/etc/timezone`  é semelhante a  `/etc/localtime`. É uma representação de dados do fuso horário local e, como tal, pode ser lido usando  `cat`:

$ **cat /etc/timezone**
America/Toronto

Observe que este arquivo não é usado por todas as distribuições Linux.

### Configurando data e hora sem timedatectl

>[!NOTE]
>
>A maioria dos sistemas Linux modernos usa o  `systemd`  para sua configuração e serviços; assim, não é recomendado usar  `date`  ou  `hwclock`  para definir a hora. O  `systemd`  emprega para isso o  `timedatectl`. No entanto, é importante conhecer esses comandos legados no caso de você precisar administrar um sistema mais antigo.

**Exercício interessante Timezone**

Existe um local chamado  `eucla`. De que continente ele faz parte? Use o comando  `grep`  para descobrir.

`timedatectl list-timezones \| grep -i eucla`
ou
`grep -ri eucla /usr/share/zoneinfo`

Defina seu fuso horário atual para  `eucla`.

`timedatectl set-timezone 'Australia/Eucla'`
ou
`ln -s /usr/share/zoneinfo/Australia/Eucla /etc/localtime`

#### Protocolo NTP (Network Time Protocol)

Alguns desses termos aparecem nos comandos que usamos para rastrear o status do NTP em nossas máquinas:

- **Deslocamento (offset)**: Refere-se à diferença absoluta entre a hora do sistema e a hora NTP. Por exemplo, se o relógio do sistema marca 12:00:02 e o horário NTP é 11:59:58, o deslocamento entre os dois relógios é de quatro segundos.
- **Salto (step)**: Se o deslocamento de tempo entre o provedor NTP e um consumidor for maior que 128ms, o NTP executará uma única alteração significativa na hora do sistema, em vez de desacelerar ou acelerar o relógio do sistema. Isso é chamado de  _stepping_.
- **Ajuste gradativo (slew)**: Slew refere-se às alterações feitas na hora do sistema quando o deslocamento entre a hora do sistema e o NTP é menor que 128ms. Se esse for o caso, as alterações serão feitas gradualmente. Isso é conhecido como  _slewing_.
- **Relógio insano**: Se o deslocamento entre a hora do sistema e a hora NTP for maior que 17 minutos, o tempo do sistema é considerado  _insano_  e o daemon NTP não introduzirá nenhuma alteração no relógio do sistema. Será preciso tomar medidas especiais para trazer a hora do sistema até menos de 17 minutos da hora correta.
- **Escorregamento ou deslizamento (drift)**: O escorregamento se refere ao fenômeno em que dois relógios ficam fora de sincronia com o tempo. Essencialmente, se dois relógios são inicialmente sincronizados, mas vão ficando fora de sincronia com o passar do tempo, está ocorrendo um escorregamento do relógio.
- **Variação (jitter)**: A variação refere-se à quantidade de escorregamento desde a última vez em que um relógio foi consultado. Portanto, se a última sincronização com o NTP ocorreu há 17 minutos, e o deslocamento entre o provedor NTP e o consumidor é de 3 milissegundos, então 3 milissegundos é a variação.

Protocolo que usa a porta **123** via UDP (pode ser visto no arquivo `/etc/services`, que lista as portas)

Primeiro é preciso instalar os pacotes: `apt install ntp ntpdate`. Depois de instalador, pode verificar se o daemon do ntp está executando com o comando `ps axu | grep ntp`

O arquivo de configuração do NTP é `/etc/ntp.conf`. Dentro desse arquivo têm listado as pools com endereços NTP. Essas pools precedem da palavra reservada `pool` ou `server`.

- `ntpq -p`ou`--peers`: (é um utilitário para monitorar o status do NTP. Uma vez que o daemon NTP foi iniciado e configurado, usamos `ntpq` para verificar seu status) lista as pools (peers) com diversas estatísticas de cada pool ou server. Com `-n` não resolve os nomes, traz só os IPs. As colunas são:

- `remote`: nome do host do provedor NTP.
- `refid`:  ID de referência do provedor NTP.
- `st`: estrato do provedor.
- `when`: número de segundos desde a última consulta.
- `poll`: número de segundos entre as consultas.
- `reach`: ID de status para indicar se um servidor foi alcançado. As conexões bem-sucedidas aumentam este número em 1.
- `delay`: tempo em ms entre a consulta e a resposta do servidor.
- `offset`: tempo em ms entre a hora do sistema e a hora NTP.
- `jitter`: deslocamento em ms entre a hora do sistema e o NTP na última consulta.

`ntpq`  também inclui um modo interativo, que é acessado quando ele é executado sem opções ou argumentos. A opção  `?`  retorna uma lista de comandos reconhecidos pelo  `ntpq`.



- `ntpdate 3.pt.pool.ntp.org` (`apt install ntpsec-ntpdate -y`): vai até o NTP de Portugal e atualiza o horário (de acordo com NTP de Portugal)<br>
**O comando acima não altera para o horário de Portugal, na realidade vai pegar o horário de lá, e de acordo com as configurações de timezone do sistema, vai ajustar de acordo com o timezone.

- `ntpdate -q 3.pt.pool.ntp.org`: (`-q` ou `--query`): consulta se o servidor está funcionando.

Durante a configuração inicial, a hora do sistema e o NTP podem ser seriamente dessincronizados. Se o  _deslocamento_  entre o sistema e a hora NTP for maior que 17 minutos, o daemon NTP não fará alterações na hora do sistema. Neste caso, será necessária uma intervenção manual.

Primeiramente, se  `ntpd`  estiver rodando, será necessário  _interromper_  o serviço. Use  `systemctl stop ntpd`  para fazer isso.

Em seguida, use  `ntpdate pool.ntp.org`  para realizar uma sincronização inicial única, onde  `pool.ntp.org`  se refere ao endereço IP ou URL de um servidor NTP. Pode ser necessária mais de uma sincronização.

#### chrony e timedatect

- **chrony**: funciona melhor em ambientes instáveis. Precisa instalar: `apt install chrony`. Confirmar com `ps axu | grep chrony` e `systemctl status chrony`.

O arquivo de configuração ficam `/etc/chrony/chrony.conf`, podendo ainda usar igual ao ntp, com a palavra `pool` ou `server` para indicar o servidor a ser consultado

#### chronyc (é o cli do chrony)

- `chrony` é outra forma de implementar o NTP. Ele é instalado por padrão em alguns sistemas Linux, mas está disponível para download em todas as principais distribuições. 
- `chronyd` é o daemon chrony e `chronyc` é a interface de linha de comando
---
- `chronyc tracking`: fornece informações sobre o NTP e a hora do sistema que está configurado (vê um status geral)
Essa saída contém muitas informações, mais do que as que estão disponíveis em outras implementações.

- `Reference ID`: O ID de referência e o nome ao qual o computador está sincronizado no momento.
- `Stratum`: Número de passos até um computador com um relógio de referência anexado.
- `Ref time`: Esta é a hora UTC em que a última medição da fonte de referência foi feita.
- `System time`: Atraso do relógio do sistema do servidor sincronizado.
- `Last offset`: Deslocamento estimado da última atualização do relógio.
- `RMS offset`: Média de longo prazo do valor do deslocamento.
- `Frequency`: Esta é a taxa na qual o relógio do sistema estaria errado se o chronyd não o estivesse corrigindo. É fornecida em ppm (partes por milhão).
- `Residual freq`: Frequência residual indicando a diferença entre as medições da fonte de referência e a frequência atualmente sendo usada.
- `Skew`: Limite de erro estimado da frequência.
- `Root delay`: Total de atrasos do caminho de rede até o computador do estrato a partir do qual o computador está sendo sincronizado.
- `Leap status`: Este é o status de intercalação, que pode ter um dos seguintes valores: normal, inserir segundo, excluir segundo ou não sincronizado.
---

- `chronyc sources`: retorna informações sobre os servidores NTP usados para sincronizar a hora
- `chronyc sources -v`:  this command displays information about the current time sources that chronyd is accessing. Mostra se é um server (`^`), se é um peer (`=`) ou se se é o relógio local (`#`). Mostra também se está sincronizado (`*`), se está combinado (`+`) ou se está não está combinado (`-`)
- `chronyc activity`: mostra status das atividades, mostrando se está com status 200 OK, por exemplo<br>
*Se digitar só `chronyc`, entra no modo de cli, e os comandos anteriores podem ser digitados diretamente.
- `chrony ntpdate`: usado para ver informações detalhadas sobre a última atualização válida do NTP


A título de curiosidade, o **systemd** tem uma forma de sincronia por meio do serviço `systemd-timesyncd.service`, que pode conflitar com o ntp. Vide o comando `timedatectl`, que apresenta informações de `network time on` e `NTP synchronized`. Para evitar seria interessante usar o comando: `timedatectl set-ntp false`, assim, vai deixar como **no**, a opção `network time on`

O ntpd usa a porta **123** e o chrony usa a **323**.

NTP Pool recomendado: https://www.ntppool.org/en/

## 108.2 Sistema de Logs - Rsyslog

- **syslog**: derivado dos sistemas unix, bsd, e posteriormente nos sistemas linux.
- **rsyslog**: melhoramento do syslog (mais cobrado na LPI) e (mais veloz para processamento de log, e trouxe melhorias importantes como suporte a RELP - _Reliable Event Logging Protocol_: Protocolo confiável de registro de eventos em log, e estende a funcionalidade do protocolo syslog de maneira a assegurar a entrega de mensagens)
- **syslog-ng**: mesmo padrão do syslog, mas muda a implementação (ng = new generation)
- **systemd-journal**: recurso do systemd, para gerenciar logs (depois do rsyslog, é bem implementado)

>[!NOTE]
>
>Normalmente em `/var/log`. No entanto, alguns serviços cuidam de seus próprios logs (por exemplo, o servidor web Apache HTTPD ou o sistema de impressão CUPS). Da mesma forma, o kernel do Linux usa um buffer de anel na memória para armazenar suas mensagens de log.

O `rsyslog` usa um modelo cliente-servidor. O cliente e o servidor podem existir no mesmo host ou em máquinas diferentes. As mensagens são enviadas e recebidas em um formato específico e podem ser mantidas em servidores `rsyslog` centralizados em redes IP. O daemon do rsyslog —`rsyslogd`— trabalha junto com o `klogd` (que gerencia as mensagens do kernel). Nas próximas seções, discutiremos o `rsyslog` e sua infraestrutura de registro de eventos.

#### Tipos de log

Como os logs são dados  _variáveis_, costumam ser encontrados em  `/var/log`. Grosso modo, podem ser classificados em  _logs do sistema_  e  _logs de serviços ou programas_.

Vamos conhecer alguns logs do sistema e as informações que eles preservam:

- `/var/log/auth.log`: atividades relacionadas aos processos de autenticação: usuários registrados, informações de  `sudo`, cron jobs, tentativas de login malsucedidas etc.
- `/var/log/syslog`: um arquivo centralizado para praticamente todos os logs capturados pelo  `rsyslogd`. Por incluir muitas informações, os logs são distribuídos por outros arquivos de acordo com a configuração fornecida em  `/etc/rsyslog.conf`.
- `/var/log/debug`: informações de depuração dos programas.
- `/var/log/kern.log`: mensagens do kernel.
- `/var/log/messages`: mensagens informativas que não estão relacionadas ao kernel, mas a outros serviços. **É também o destino padrão do log do cliente remoto em uma implementação de servidor de log centralizado**.
- `/var/log/daemon.log`: informações relacionadas aos daemons ou serviços em execução em segundo plano.
- `/var/log/mail.log`: informações relacionadas ao servidor de email, por exemplo o postfix.
- `/var/log/Xorg.0.log`: informações relacionadas à placa de vídeo.
- `/var/run/utmp`  e  `/var/log/wtmp`:  Logins bem-sucedidos.
- `/var/log/btmp`: tentativas de login malsucedidas, por exemplo ataques de força bruta via ssh.
- `/var/log/faillog`: tentativas de autenticação malsucedidas.
- `/var/log/lastlog`: data e hora dos logins recentes do usuário.

Vejamos agora alguns exemplos de logs de serviço:

- `/var/log/cups/`: diretório para logs do  _Common Unix Printing System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `page_log`  e  `access_log`.
- `/var/log/apache2/`  or  `/var/log/httpd`: diretório para logs do  _Apache Web Server_. Geralmente inclui os seguintes arquivos de log padrão:  `access.log`,  `error_log`  e  `other_vhosts_access.log`.
- `/var/log/mysql`: diretório para logs do  _MySQL Relational Database Management System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `mysql.log`  e  `mysql-slow.log`.
- `/var/log/samba/`: diretório para logs do protocolo  _Session Message Block_  (SMB). Geralmente inclui os seguintes arquivos de log padrão:  `log.`,  `log.nmbd`  and  `log.smbd`.

>[!NOTE]
>
>O nome e o conteúdo exatos dos arquivos de log podem variar de acordo com as distribuições Linux. Existem também logs específicos para distribuições específicas como  `/var/log/dpkg.log`  (contendo informações relacionadas aos pacotes  `dpkg`) no Debian GNU/Linux e seus derivados.

- `/etc/rsyslog.conf`: arquivo principal de configuração do rsyslog. A primeira vista temos os módulos (`module(load="imuxsock")`), que nesse caso serve para comunicação do `rsyslog` com `systemd-journal`, eles se comunicam. (isso nos sistemas baseados em Debian, já em Redhat muito provável que o nome do módulo seja `imjournal` - ambos tem as mesmas funções)

As configurações serão obtidas em `/etc/rsyslog.d/*.conf`(informado na última linha de `/etc/rsyslog.conf`)

Conforme for instalando aplicações, muito provável que elas criarão uma entrada no arquivo `50-default.conf`:<br>
Nesse arquivo o padrão de entrada é: `facility.priority`(facility é quem está gerando o log, qual aplicação, e priority é o nível do log (em ordem ascendente/crescente):<br>
- `debug`: muitos registros, mas não tão importantes
- `info`
- `notice`
- `warn` ou `warning`
- `err` ou `error`
- `crit`: poucos registros, mas precisa ser olhado
- `alert`
- `emerg` ou `panic`
- `*`=todos, qualquer nível de debug<br>
Exemplo: `mail.err` (`mail` é a facility e `err` é a priority)<br>
Como é em ordem crescente, no caso do mail acima, tudo que vir acima de `err`, vai ser criado log (`crit`, `alert` e `emerg`)

Se quiser priorizar **apenas** `err`, use `mail.=err`

Depois da coluna de `facility.priority`, seria onde se destina o log, no caso pode ser um caminho (`/var/log/syslog`, por exemplo) ou pode ser para um determinado usuário (`lpi1,lpi2` - separado pode vírgula) ou ainda para todos os usuário, usando o asterisco (`*`). Há possibilidade de mandar remotamente para outro servidor, usando a notação `@10.0.0.1`, por exemplo (precisa ser um servidor de logs - útil quando tiver muitos servidores, e para descentralizar a geração de logs).

A segunda linha é bem interessante:<br>

    auth,authpriv.*				var/log/auth.log
    *.*;auth,authpriv.none		-/var/log/syslog

*O `-` em frente ao caminho, significa prioridade para performance, que nesse caso com o traço (evita gravações em disco excessivas), **não** precisa ser registrado imediatamente.

No caso, a 2ª linha indica que tudo (`*`), relacionado à facility e priority (`*.*` - qualquer facility e qualquer priority), exceto `;auth,authpriv.none`, irão gerar log em `/var/log/syslog` (em Redhat seria em `/var/log/messages`)

*Todas as configurações vistas serão as mesmas no **syslog**.

É possível criar sua própria configuração:<br>
Em `/etc/rsyslog.d` crie no final do arquivo `50-default.conf`<br>

    local0.warn			/var/log/teste-rsyslog.out

Reinicie o **rsyslog**: `systemctl restart rsyslogd`

Para gerar o log, pode-se utilizar a ferramenta `logger`, com o seguinte comando:<br>

    logger -p local0.err "Teste de Rsyslog"
    # -p = --priority

Depois de executar o comando, é para ter gerado o arquivo `teste-rsyslog.out` dentro de `/var/log`. Executando um `cat` no arquivo criado, é possível verificar a mensagem de log que acabou de ser realizada.

Lembrando que o `rsyslog` é a evolução do `syslog`, caso queira usar o `syslog`, instalar o pacote `inetutils-syslog`. O arquivo de configuração do syslog fica geralmente em `/etc/syslog.conf` (`syslog` não cai no exame, apenas `rsyslog`)

Para leitura do log, usar `less` ou `more`. Se tiver compactado, usar `zless` ou `zmore`. Pode usar também `tail` ou `head`. Para filtrar, usar o `grep`:<br>

       # grep "dhcpclient" /var/log/syslog
        Sep 13 11:58:48 debian dhclient[448]: DHCPREQUEST of 192.168.1.4 on enp0s3 to 192.168.1.1 port 67
    Sep 13 11:58:49 debian dhclient[448]: DHCPACK of 192.168.1.4 from 192.168.1.1
    Sep 13 11:58:49 debian dhclient[448]: bound to 192.168.1.4 -- renewal in 1368 seconds.

Como você deve ter notado, a saída é impressa no seguinte formato:

-   Carimbo de data/hora
-   Nome do host a partir do qual a mensagem se originou
-   Nome do programa/serviço que gerou a mensagem
-   O PID do programa que gerou a mensagem
-   Descrição da ação que ocorreu

Existem alguns exemplos em que os registros não são em forma de texto, mas arquivos binários e — conseqüentemente — você deverá usar comandos especiais para analisá-los:

`/var/log/wtmp`

Use  `who`  (ou  `w`):

    root@debian:~# **who**
    root    pts/0        2020-09-14 13:05 (192.168.1.75)
    root    pts/1        2020-09-14 13:43 (192.168.1.75)

`/var/log/btmp`

Use  `utmpdump`  ou  `last -f`:

    root@debian:~# **utmpdump /var/log/btmp**
    Utmp dump of /var/log/btmp
    [6] [01287] [    ] [dave     ] [ssh:notty   ] [192.168.1.75        ] [192.168.1.75   ] [2019-09-07T19:33:32,000000+0000]

`/var/log/faillog`

Use  `faillog`:

    root@debian:~# **faillog -a | less**
    Login       Failures Maximum Latest                   On
    
    root            0        0   01/01/70 01:00:00 +0100
    daemon          0        0   01/01/70 01:00:00 +0100
    bin             0        0   01/01/70 01:00:00 +0100
    sys             0        0   01/01/70 01:00:00 +0100
    sync            0        0   01/01/70 01:00:00 +0100
    games           0        0   01/01/70 01:00:00 +0100
    man             0        0   01/01/70 01:00:00 +0100
    lp              0        0   01/01/70 01:00:00 +0100
    mail            0        0   01/01/70 01:00:00 +0100
    (...)

`/var/log/lastlog`

Use  `lastlog`:

    root@debian:~# **lastlog | less**
    Username         Port     From             Latest
    root                                       **Never logged in**
    daemon                                     **Never logged in**
    bin                                        **Never logged in**
    sys                                        **Never logged in**
    (...)
    sync                                       **Never logged in**
    avahi                                      **Never logged in**
    colord                                     **Never logged in**
    saned                                      **Never logged in**
    hplip                                      **Never logged in**
    carol            pts/1    192.168.1.75     Sat Sep 14 13:43:06 +0200 2019
    dave             pts/3    192.168.1.75     Mon Sep  2 14:22:08 +0200 2019

>[!NOTE]
>
> Também existem ferramentas gráficas para ler arquivos de log, como  `gnome-logs`  e  `KSystemLog`.

#### Entradas manuais no log do sistema:  `logger`

O comando  `logger`  é prático para scripts do shell ou para testes. O  `logger`  anexa todas as as mensagens recebidas a  `/var/log/syslog`  (ou a  `/var/log/messages`  quando o registro for feito em um servidor de log remoto centralizado, como veremos mais adiante):

carol@debian:~$ **logger this comment goes into "/var/log/syslog"**

Para imprimir a última linha de  `/var/log/syslog`, use o comando  `tail`  com a opção  `-1`:

root@debian:~# **tail -1 /var/log/syslog**
Sep 17 17:55:33 debian carol: this comment goes into /var/log/syslog

#### Como as mensagens são transformadas em logs

O processo a seguir ilustra como uma mensagem é gravada em um arquivo de log:

1.  Aplicativos, serviços e o kernel gravam mensagens em arquivos especiais (sockets e buffers de memória), por exemplo,  `/dev/log`  ou  `/dev/kmsg`.
2.  O  `rsyslogd`  obtém as informações dos sockets ou buffers de memória.
3.  Dependendo das regras encontradas em  `/etc/rsyslog.conf`  e/ou dos arquivos em  `/etc/ryslog.d/`, o  `rsyslogd`  move as informações para o arquivo de log correspondente (normalmente encontrado em  `/var/log`).
    

>[!NOTE]
>
>Um socket é um arquivo especial usado para transferir informações entre diferentes processos. Para listar todos os sockets em seu sistema, você pode usar o comando  `systemctl list-sockets --all`.

### logrotate (rotacionamento de logs)

Imagine o cenário que os logs começam a crescer com o passar do tempo, ao ponto de encher o disco. Aí que entra o rotacionamento de logs.

Um exemplo é executar o comando: `# ls -ltr /var/log/syslog*`

    -rw-r----- 1 syslog adm  130685 Nov 10 00:00 /var/log/syslog.3.gz
    -rw-r----- 1 syslog adm   88855 Nov 17 00:00 /var/log/syslog.2.gz
    -rw-r----- 1 syslog adm 2870981 Nov 24 00:00 /var/log/syslog.1
    -rw-r----- 1 syslog adm 1246647 Nov 25 08:19 /var/log/syslog

É possível perceber que o log do `syslog` vai rotacionando, de `syslog` vira `syslog.1`, depois é compactado, e o último é excluído, tudo isso configurável no `logrotate`.

- `/etc/logrotate.conf`: arquivo de configuração do logrotate. Aqui é uma configuração mais geral e genérica, e que incluir o diretório `/etc/logrotate.d`, que possui as configurações separadamente.

O **logrotate** não é um **daemon** que fica rodando, na realidade é executado pelo crontab (geralmente em `/etc/cron.daily`).

Alguns valores do logrotate nos arquivos de configuração:
- `rotate 4`: Preserva 4 semanas de logs.
- `weekly`: Rotaciona arquivos de log semanalmente.
- `missingok`: Não emite uma mensagem de erro se o arquivo de log estiver ausente; simplesmente passa para o seguinte.
- `notifempty`: Não rotaciona o log se estiver vazio.
- `compress`: Compacta arquivos de log com o  `gzip`  (padrão).
- `delaycompress`: Adia a compactação do arquivo de log anterior para o próximo ciclo de rotação (válido apenas quando usado em combinação com compress). Útil quando um programa não pode ser instruído a fechar seu arquivo de log e, portanto, pode continuar gravando no arquivo de log anterior por algum tempo.
- `sharedscripts`: Relacionado aos scripts  _prerotate_  e  _postrotate_. Para evitar que um script seja executado várias vezes, esse comando executa os scripts apenas uma vez, independentemente de quantos arquivos de log correspondem a um determinado padrão (por exemplo,  `/var/log/mail/*`). Porém, os scripts não serão executados se nenhum dos logs no padrão requerir a rotação. Além disso, se os scripts forem encerrados com erros, as ações restantes não serão executadas em nenhum log.
- `postrotate`: Indica o início de um script  _postrotate_.
- `invoke-rc.d rsyslog rotate > /dev/null`: Usa  `/bin/sh`  para executar  `invoke-rc.d rsyslog rotate > /dev/null`  depois de rotacionar os logs.
- `endscript`: Indica o fim do script  _postrotate_.

>[!NOTE]
>
>Para uma lista completa de diretrizes e explicações, consulte a página de manual de `logrotate.conf`.

#### O buffer de anel do kernel

Uma vez que o kernel gera diversas mensagens antes de  `rsyslogd`  se tornar disponível na inicialização, torna-se necessário um mecanismo para registrar essas mensagens. É aqui que o  _buffer de anel do kernel_  entra em ação. Trata-se de uma estrutura de dados de tamanho fixo e — portanto — à medida que novas mensagens são gravadas, as mais antigas vão desaparecendo.

O comando  `dmesg`  imprime o buffer de anel do kernel. Devido ao tamanho do buffer, este comando é normalmente usado em combinação com o utilitário de filtragem de texto  `grep`. Por exemplo, para pesquisar mensagens relacionadas a dispositivos Universal Serial Bus:

    root@debian:~# dmesg | grep "usb"
    [    1.241182] usbcore: registered new interface driver usbfs
    [    1.241188] usbcore: registered new interface driver hub
    [    1.250968] usbcore: registered new device driver usb
    [    1.339754] usb usb1: New USB device found, idVendor=1d6b, idProduct=0001, bcdDevice= 4.19
    [    1.339756] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
    (...)

#### systemd-journal

Monitora as entradas do sistema, gerando registro de logs, em uma base de dados interna (trabalha diferente do **rsyslog**). Logo são 2 tipos de registros, uma pelo **rsyslog** e outra pelo **systemd-journal**.

- `/etc/systemd/journald.conf`: arquivo de configuração do systemd-journal

É muito recomendado olhar o `man journald.conf` para aprofundar nas opções que ele oferece.

Os logs ficam em `/var/log/journal`, no entanto é criado um arquivo de base de dados interna, que não é possível ler com `cat` ou `less`.

Para realizar a leitura, é preciso usar o comando `journalctl`. Ele sozinho sendo executado, mostra todos os dados que já foram para o log do **journal** (muitos dados, que precisam ser filtrados) imprimirá todo o diário em ordem cronológica (com as entradas mais antigas listadas primeiro - se usar `-r` imprime na ordem reversa). Olhar `journalctl --help` para ver os filtros

- `journalctl -n10`: mostra as 10 últimas linhas
- `journalctl -f`: igual ao `tail -f`
- `journalctl -b` ou `--boot`: mensagens de log relacionadas ao boot do sistema
- `journalctl _TRANSPORT=kernel`: mostra tudo que tiver origem do kernel
- `journalctl _UID=0`: tudo que for referente ao usuário root (id=0)
- `journalctl --since "today"` ( `-S` ou `--since` ): todos os logs que aconteceram hoje
- `journalctl --since "1 hour ago"`: todos os logs que aconteceram há 1 dia
- `journalctl --since "2024-11-20" --until "2024-11-21"` (`-U` ou `--until`): todos os logs que aconteceram entre os dias 20 e 21 de novembro e 2024.
- `journalctl --verify`: verifica os logs, se não há nada corrompido.
- `journalctl --sync`: grava em disco tudo que ainda está em memória.

Mais algumas opções de palavras-chave:
- `yesterday`: A partir de meia-noite do dia anterior ao dia atual.
- `today`: A partir de meia-noite do dia atual.
- `tomorrow`: A partir de meia-noite do dia seguinte ao dia atual.
- `now`: A hora atual.

Exemplo: Vamos ver todas as mensagens desde a meia-noite passada até hoje às 21:00:

    root@debian:~# journalctl --since "today" --until "21:00:00"

Para ver as mensagens do diário relacionadas a um **executável** específico, a seguinte sintaxe é usada:  `journalctl  _/path/to/executable_`:

    root@debian:~# **journalctl /usr/sbin/sshd**
    -- Logs begin at Sat 2019-10-12 20:45:29 CEST, end at Sat 2019-10-12 21:54:49 CEST. --
    Oct 12 21:16:28 debian sshd[1569]: Accepted password for carol from 192.168.1.65 port 34050 ssh2

Para ver da mesma forma, mas com **unidades** (units), usa o `-u`:

    root@debian:~# **journalctl -u ssh.service**
    -- Logs begin at Sun 2019-10-13 10:50:59 CEST, end at Sun 2019-10-13 12:22:59 CEST. --
    Oct 13 10:51:00 debian systemd[1]: Starting OpenBSD Secure Shell server...

>[!NOTE]
>
>Para imprimir todas as unidades carregadas e ativas, use `systemctl list-units`; para ver todos os arquivos de unidade instalados, use `systemctl list-unit-files`.


#### Para navegar pela saída do diário, usamos:

-   Teclas `PageUp`, `PageDown` e as setinhas para nos mover para cima, para baixo, a direita e a esquerda.
-   `>`  para ir ao final da saída.
-   `<`  para ir ao início da saída.
    
Você pode pesquisar strings para a frente e para trás a partir de sua posição atual:
-   **Busca para a frente**: Pressione  `/`  e insira a string a pesquisar, depois dê Enter.
-   **Busca para trás**: Pressione  `?`  e insira a string a pesquisar, depois dê Enter.
    
Para navegar pelas correspondências nas pesquisas, use  `N`  para ir para a próxima ocorrência e  `Shift+N`  para ir para a anterior.

#### ver o tamanho dos logs

Supõe que esteja em `/var/log/`, execute `du -sh .`

#### túnel de dados (socket)

Como já vimos em `/etc/rsyslog.conf`, tem o uso de módulos, no caso o `imuxsock`, que vai servir como um túnel de dados entre o **journalctl** e o **rsyslog**.

Em `systemctl status rsyslog`, podemos obter o arquivo que carrega o **rsyslog**, no caso `rsyslog.service`. E se executar um `cat` nele (`cat /lib/systemd/system/rsyslog.service`) é possível ver ele requer (no campo **Requires**) o socket `syslog.socket` (que é uma unit do systemd - podendo ser verificada com o comando `systemctl status syslog.socket` - aqui é possível ver onde ele foi carregado).

Dando um cat onde está o socket visto anteriormente, `cat /lib/systemd/system/syslog.socket`, no campo **ListenDatagram**, mostra o que o syslog está ouvindo, que no caso é `/run/systemd/journal/syslog`. Nesse caso o rsyslog usa esse socket, por conta do módulo `imuxsock` que ouve  o **systemd journal**.

Para confirmar o socket, liste os arquivos em `/run/systemd/journal` (os arquivos **socket** e **stdout**, que começam com s nas permissões)

    cd /run/systemd/journal/
    root@PC:/run/systemd/journal# ls -l
    total 8
    srw-rw-rw- 1 root root    0 Nov  8 16:41 dev-log
    -rw-r--r-- 1 root root    0 Nov  8 16:41 flushed
    srw------- 1 root root    0 Nov  8 16:41 io.systemd.journal
    -rw-r--r-- 1 root root    8 Nov  8 16:41 kernel-seqnum
    -rw-r--r-- 1 root root   24 Nov  8 16:41 seqnum
    srw-rw-rw- 1 root root    0 Nov  8 16:41 socket
    srw-rw-rw- 1 root root    0 Nov  8 16:41 stdout
    drwxr-xr-x 2 root root 1160 Nov 25 10:32 streams
    srw-rw-rw- 1 root root    0 Nov  8 16:41 syslog


#### systemd-cat (parecido com logger)

Execute o `journalctl -f` para ficar logando as entradas (igual ao `tail -f`) em um terminal, e em outro use o `systemd-cat`, que vai mandar o output do comando diretamente para o **journal**.

Ex. `systemd-cat ls -ls rsyslog.conf`: manda a saída do comando `ls` diretamente no journal (onde deixou rodando o comando `journalctl -f`)

Pode usar também dessa forma: `echo "Mensagem de teste" | systemd-cat`

#### ver o tamanho dos logs journal

Supõe que esteja em `/var/log/journal`, execute `journalctl --disk-usage`

#### limpar logs

- `journalctl --vacuum-size=200M`: limpa 200 MB os arquivos de logs (archived apenas, não os ativos). Pode usar `--vacuum-time` e `--vacuum-files`

Voltar depois nesse tópico e no de mail e impressoras


## 109.1 Fundamentos dos protocolos de internet

- **TCP/IP**: Conjunto de Protocolos de comunicação entre computadores
- Engloba os protocolos IP, TCP, UDP, ICMP, entre outras

- **IP**: é o protocolo responsável pelo endereçamento lógico. Cada dispositivo em uma rede deve possuir um endereço IP único

- O endereço IP (IPv4) é formado por 32 bits, separados em 4 grupos de 8 bits, representados de maneira decimal.
	- 192.168.10.20 = 10000000.10101000.00001010.00010100
	- 0.0.0.0 = 00000000.00000000.00000000.0000000
	- 255.255.255.255 = 11111111.11111111.11111111.11111111

#### Classes

| Classe | 1º Octeto | Range |
| -------- | ----- | ----------- |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 |

Exemplos:
- Classe A - 10.25.13.10 - 110.14.20.12
- Classe B - 141.150.200.1 / 172.168.1.1
- Classe C - 192.168.20.30 / 200.178.12.242

#### Endereços: Privado vs Público

| Classe | 1º Octeto | Range | IPs Privados |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 10.0.0.0 - 10.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 172.16.0.0 - 172.31.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 192.168.0.0 - 192.168.255.255 |

#### Máscara

- utilizada em conjunto com o endereço IP para determinar a segmentação de rede
- também composta de 32 bits em 4 grupos de 8:
	- 255.0.0.0 = 11111111.00000000.00000000.00000000 = /8
	- 255.255.0.0 = 11111111.11111111.00000000.00000000 = /16
	- 255.255.255.0 = 11111111.11111111.11111111.00000000 = /24
	- 255.255.255.255 = 11111111.11111111.11111111.11111111 = /32
- 1s identificam a rede
- 0s identificam os hosts

| Classe | 1º Octeto | Range | Máscara Padrão |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 255.0.0.0 /8 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 255.255.0.0 /16 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 255.255.255.0 /24 |

Exemplos:
- Classe A - `110`.14.20.12
- Classe B - `172.168`.1.1
- Classe C - `200.178.12`.242

#### sub-redes

| Máscara | CIDR | Hosts | Sub-rede |
| -------- | ----- | ---------- | ------------ |
| 255.255.255.0 | 24 | 254 | 1 |
| 255.255.255.128 | 25 | 126 | 2 |
| 255.255.255.192 | 26 | 62 | 4 |
| 255.255.255.224 | 27 | 30 | 8 |
| 255.255.255.240 | 28 | 14 | 16 |
| 255.255.255.248 | 29 | 6 | 32 |
| 255.255.255.252 | 30 | 2 | 64 |

#### Rota padrão (gateway)

Duas sub-redes distintas, caso precisem se comunicar, terá que ter um gateway para realizar o intermédio entre essas redes (precisa de uma rota padrão).

#### IPv6

- IPv6 é um novo padrão de endereçamento IP
- cada endereço possui 128 bits, divididos em 8 grupos de 16 bits, representados por 4 números hexadecimais
- Exemplo: `2001:0db8:85a3:08d3:1319:8a2e:0370:7344`

#### abreviações

- 2001:0db8:85a3`:0000:0000:0000:0000:`7344
- 2001:0db8:85a3`:0:0:0:0:`7344
- 2001:0db8:85a3`::`7344
<br>
- 2001:0db8:85a3`:0000:0000:`1319`:0000:`7344
- 2001:0db8:85a3`:0:0:`1319`:0:`7344
- 2001:0db8:85a3`::`1319`:0:`7344

<br>

- **Unicast**: identifica uma única interface
- **Multicast**: identifica um conjunto de interfaces. Um pacote é enviado para cada interface
- **Anycast**: identifica um conjunto de interfaces. Um pacote e enviado para'uma única interface, normalmente a mais próxima

#### Diferenças entre IPv4 e IPv6

Além do endereço, diversas outras diferenças podem ser apontadas entre as versões 4 e 6 do IP. Eis algumas delas:
-   As portas de serviço seguem os mesmos padrões e protocolos (TCP, UDP); a diferença está apenas na representação do IP e no conjunto de portas. No IPv6, o endereço IP deve ser protegido com  `[]`  (colchetes):
    
   - IPv4:  `200.216.10.15:443`
   - IPv6:  `[2001:0db8:85a3:08d3:1319:8a2e:0370:7344]:443`
    
-   O IPv6 não implementa o recurso de broadcast (transmissão) da mesma maneira que o IPv4. Porém, o mesmo resultado pode ser obtido enviando-se o pacote para o endereço  `ff02::1`, que alcança todos os hosts da rede local — semelhante a usar  `224.0.0.1`  no IPv4 para uma transmissão multicast.
-   Por meio do recurso SLAAC (_Stateless Address Autoconfiguration_), os hosts IPv6 podem se autoconfigurar.
-   O campo TTL (_Time to Live_) do IPv4 foi substituído pelo “Hop Limit” (limite de saltos) no cabeçalho do IPv6.
-   Todas as interfaces IPv6 têm um endereço local, denominado endereço de link local, prefixado com  `fe80::/10`.
-   O IPv6 implementa o  _Neighbor Discovery Protocol_  (NDP), semelhante ao ARP usado pelo IPv4, mas com muito mais funcionalidades.

Que tipo de informação o Neighbour Discovery Protocol (NDP) pode descobrir?

O NDP é capaz de obter diversas informações da rede, incluindo outros nós, endereços duplicados, rotas, servidores DNS, gateways, etc.

#### TCP

- **TCP**: Transmission Control Protocol: protocolo de transporte orientado a conexões. Garante a entrega dos pacotes na ordem correta. O pacote é retransmitido em caso de erros na rede. Usado por serviços como FTP, SMTP, HTTP, POP3, IMAP, SSH, etc

#### UDP

- **UDP**: User Datagram Protocol: protocolo de transporte não  orientado a conexões. Não oferece garantia de entrega dos pacotes, assim tem melhor performance na transmissão de dados. Usado por serviços como DHCP, DNS, NFS e NTP.

#### ICMP

- **ICMP**: Internet Control Message Protocol: utilizado para transmitir informações de controle entre os elementos de rede, por exemplo:
	- controle de volume de tráfego
	- detecção de destinos nao atingíveis
	- redirecionamento de rotas
	- verificação de status de hosts remotos
- utilizado em comandos como o `ping` e `traceroute`

#### Portas e Serviços

- cada serviço é provido por meio de uma porta
- portas possuem 16 bits, ou seja, um máximo de 65535
- as primeiras 1024 portas são reservadas a serviços conhecidos (_portas privilegiadas_, por ter acesso de root ao sistema)
- as demais são utilizadas para serviços específicos ou para a porta de socket (_portas não privilegiadas_ ou portas de socket) de uma conexão (quando um cliente se conecta a um servidor http, o servidor normalmente usa a porta 80, já no cliente é configurado um socket/porta aleatório, como 42222, por exemplo. Essa porta é chamada de socket)
- toda conexão é composta de IP de **destino** e **origem**, assim como a porta de **destino** e **origem** (socket)
- As portas usadas por cada tipo de serviço são padronizadas e controladas pela IANA (_Internet Assigned Numbers Authority_). Assim, em qualquer sistema, a porta 22 é usada pelo serviço SSH, a porta 80 pelo serviço HTTP e assim por diante.
- Em um sistema Linux, as portas de serviço padrão são listadas no arquivo `/etc/services`.

<br>

Exemplo:
- `200.20.125.60`:25 (serviço SMTP)
- `172.168.8.10`:80 (serviço HTTP)
- `[2001:0db8:85a3:0000:0000:1319:0000:7344]`:80

| Porta(s) | Serviço |
| -------- | ----- |
| 20 e 21 | FTP |
| 22 | SSH |
| 23 | Telnet |
| 25 e 465 | SMTP e SMTPs |
| 53 | DNS |
| 67 e 68 | DHCP |
| 80 e 443 | HTTP e HTTPS |
| 110 e 995 | POP3 e POP3S |
| 123 | NTP |
| 139 | Netbios |
| 143 e 993 | IMAP e IMAPS |
| 161 e 162 | SNMP |
| 389 e 636 | LDAP e LDAPS |


## 109.2 Configuração de rede persistente

- `/etc/hostname`: define o nome da máquina (assim como digitar `hostname` vai mostrar o nome da máquina)
- `hostnamectl`: mostra mais informações do host
- `hostnamectl set-hostname novo_nome`: altera o hostname da máquina (altera também lá no `/etc/hostname`)

Uma configuração funcional de TCP/IP é apenas o primeiro passo para a usabilidade total da rede. Além de ser capaz de distinguir os nós da rede por seus números IP, o sistema deve poder identificá-los com nomes mais facilmente compreensíveis por seres humanos.

O nome pelo qual o sistema se identifica é personalizável e é aconselhável fazê-lo, mesmo se a máquina não for destinada a se conectar a uma rede. O nome local geralmente corresponde ao nome da rede da máquina, mas nem sempre. Se o arquivo  `/etc/hostname`  existir, o sistema operacional usará o conteúdo da primeira linha como nome local, que a partir daí é chamado simplesmente de  _nome do host_  (hostname, em inglês). As linhas que começam com  `#`  dentro de  `/etc/hostname`  são ignoradas.

O arquivo  `/etc/hostname`  pode ser editado diretamente, mas o nome de host da máquina também pode ser definido com o comando  `hostnamectl`. Quando fornecido com o subcomando  `set-hostname`, o comando  `hostnamectl`  pega o nome dado como argumento e o escreve em  `/etc/hostname`:

    # hostnamectl set-hostname storage
    # cat /etc/hostname
    storage

O nome de host (ou “hospedeiro”) definido em  `/etc/hostname`  é o nome  _estático_, ou seja, o nome usado para inicializar o nome de host do sistema na inicialização. O nome de host estático pode ser uma string com até 64 caracteres de comprimento. No entanto, é recomendado que ele consista apenas em caracteres ASCII minúsculos e sem espaços ou pontos. Também é aconselhável limitá-lo ao formato permitido para rótulos de nomes de domínio DNS, embora esse não seja um requisito estrito.

O comando  `hostnamectl`  pode definir dois outros tipos de nomes de host além do nome de host estático:

- **Hostname pretty**: Ao contrário do nome de host estático, o nome de host pretty pode incluir todos os tipos de caracteres especiais. Ele pode ser usado para definir um nome mais descritivo para a máquina, por exemplo “Armazenamento compartilhado da LAN”:
```
    # hostnamectl --pretty set-hostname "LAN Shared Storage"
```
- **Hostname transiente**: Usado quando o nome de host estático não está definido ou quando ele é o nome  `localhost`  padrão. O nome de host transiente é normalmente definido junto com outras configurações automáticas, mas também pode ser modificado com o comando  `hostnamectl`, por exemplo:
```
# hostnamectl --transient set-hostname generic-host
```
Se nem a opção  `--pretty`  nem  `--transient`  forem usadas, os três tipos de nomes de host serão configurados com o nome fornecido. Para definir o nome de host estático, mas não os nomes pretty e transiente, usa-se a opção  `--static`. Em todos os casos, somente o nome de host estático é armazenado no arquivo  `/etc/hostname`.

- `/etc/hosts`: arquivo que cria uma relação do IP e nome da máquina (igual o que há no windows)
Ex. de entrada no `/etc/hosts`:
```
192.168.0.100		minhamaquina		minhamaquina.dominio.com.br
```
*O terceiro campo é opcional. Quando for no terminal e der um ping em `minhamaquina`, vai pingar no IP associado:

    $ ping minhamaquina
    PING minhamaquina (192.168.0.100) 56(84) bytes of data.
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=1 ttl=64 time=0.257 ms
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=2 ttl=64 time=0.381 ms

- `/etc/nsswitch.conf` (Name Service Switch): disponibiliza diversas informações, de onde buscar as informações de `passwd`, `group`, `shadow`, etc. Geralmente é indicado como `compat` (compatibilidade), mas poderia, por exemplo, indicar para buscar no `ldap`.

No entanto para LPI1, é importante saber a parte de `hosts` e `networks`:
- `hosts`: vai estar como `files`, o que indica para buscar primeiramente aos arquivos do sistema, como o `/etc/hosts` (o que faz relação IP e nome), e caso não encontre, vai buscar em algum DNS configurado (no arquivo vai estar o `mdns4_minimal`, que é um serviço de DNS interno - `multicast dns`).

Exercício interessante:<br>
Qual entrada de  `/etc/hosts`  associa os nomes  `firewall`  e  `router`  com o IP  `10.8.0.1`?<br>
Resposta: A linha  `10.8.0.1 firewall router`.

- `/etc/networks`: mesma relação com o /etc/hosts, mas esse seria para redes.
```
rede-local		192.168.1.0 #nomeia essa rede como rede-local
```

- `/etc/resolv.conf`: determinar qual servidor DNS será utilizado pelo sistema. Indica o `nameserver` (apenas um servidor de nomes é necessário, mas é possível informar até **três** deles - os suplementares serão usados como reserva - se nenhuma entrada de servidor de nomes estiver presente, o comportamento padrão é usar o servidor de nomes da máquina local), que é basicamente o servidor DNS que irá usar. (mais detalhes no tópico **109.3**)
Importante dizer que esse arquivo é dinamicamente gerenciado/escrito/gerado pelo `systemd-resolved(8)`, que basicamente é um link que vem do `/etc/resolv.conf`. Isso significa que poderia ter seu próprio arquivo parecido com `resolv.conf` apontando para o `resolv` do `systemd` (para ambiente de produção, por exemplo).
```
ls -l /etc/resolv.conf 
lrwxrwxrwx 1 root root 39 Nov  8 16:20 /etc/resolv.conf -> ../run/systemd/resolve/stub-resolv.conf
```

#### NetworkManager

De modo geral, a configuração costuma ser feita por arquivos, sendo eles:
- No padrão Debian, geralmente fica em `/etc/network/interfaces`.
- Já no Red Hat, fica em `/etc/sysconfig/network-scripts`

No entanto as distros mais novas tem tendenciado utilizar o **NetworkManager**(o que é exigido na LPI - em tese não é cobrado os scripts listados acima, apenas na LPI2)

Existem aplicativos cliente do NetworkManager para a linha de comando e para o ambiente gráfico. No caso deste último, o aplicativo cliente é incluído como um acessório do ambiente de desktop (com nomes como _nm-tray_, _network-manager-gnome_, _nm-applet_ ou _plasma-nm_) e geralmente fica acessível por meio de um ícone indicador no canto da barra da área de trabalho ou no utilitário de configuração do sistema

Os arquivos de configuração ficam em `/etc/NetworkManager`. Dentro há algumas pastas, sendo:
- `system-connections`: onde é salvo as redes conhecidas pelo NetworkManager, configuração de perfis, redes wifi, etc.

Para verificar se o serviço do NetworkManager está executando: `systemctl status NetworkManager`. O NetworkManager foi desenvolvido originalmente pela Red Hat, sendo atualmente um projeto GNOME.

É possível gerir o NetworkManager por CLI, utilizando o `nmcli`.

As categorias chamadas  _objetos_ são:
- `general`: Status e operações gerais do NetworkManager
- `networking`: Controle geral de rede.
- `radio`: Controles de rádio do NetworkManager.
- `connection`: Conexões do NetworkManager.
- `device`: Dispositivos gerenciados pelo NetworkManager.
- `agent`: Agente secreto ou agente polkit do NetworkManager.
- `monitor`: Monitora as mudanças do NetworkManager.


- `nmcli`: lista as interfaces detectadas pelo NetworkManager e os servidores DNS configurados no computador
- `nmcli device` (ou `nmcli d` ou `nmcli dev`): resumo das interfaces
- `nmcli device show`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS)
- `nmcli device show enp2s0`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS) da interface selecionada
- `nmcli --help`: mostra as diversas outras opções do `nmcli`
- `nmcli general status`: mostra as informações/status na conexão no momento
- `nmcli networking`: se a rede cabeada está habilitada/funcionando
- `nmcli radio`: se o wifi está habilitado/funcionando
- `nmcli connection`: enquanto device mostra informações referentes ao dispositivo em si, connections mostra informações da(s) conexão(ões), como o tipo (ethernet e wifi)

Supondo que a saída do comando `nmcli connection` seja (O comando `status` é usado por padrão se nenhum argumento de comando estiver presente, de modo que o comando `nmcli general` é interpretado, na verdade, como `nmcli general status`): 

    DEVICE		UUID		TYPE			STATE			CONNECTION
    enp0s2		779a5...	ethernet		connected		Wired connection 1	
    enp0s4		45f23...	ethernet		connected		Wired connection 2

Para baixar a `Wired connection 2`, use: `nmcli con down "Wired connection 2"`

- `nmcli connection add type ethernet con-name nome_conexao ifname enp2s0 ip4 192.168.0.20/24 gw4 192.168.0.1`: cria uma nova conexao chamada `nome_conexao`, na placa `enp2s0`, com IP `192.168.0.20` máscara `255.255.255.0` e gateway `192.168.0.1`.
- `nmcli connection up nome_conexao`: ativa a rede criada no comando acima.
- `nmcli connection del nome_conexao`: remove a rede `nome_conexao`

Se voltarmos em `/etc/NetworkManager`, em `system-connections`, foi criado um arquivo `nome_conexao`. Mais opções em `nmcli connection --help`

#### NetworkManager - redes sem fio

- `nmcli device wifi list`: mostra as redes disponíveis (SSIDs). A com asterisco (`*`) é a que está em uso.
- `nmcli device wifi rescan`: reescaeia e coloca uma flag se um novo Wi-Fi scan deve ser engatilhado. Depois rode o `list` novamente.
- `nmcli radio wifi on/off`: habilita/desabilita o rádio wifi. (se trocar `radio` por `networking`, habilita/desabilita rede cabeada)
- `nmcli device wifi connect NOME_SSID password 123456`: conecta na rede `NOME_SSID` com a senha `123456` (obviamente não usar essa senha em produção). Confirme se conector com o asterisco mostrado no `nmcli device wifi list`
- Se a rede wi-fi esconde seu nome SSID, o  `nmcli`  ainda assim pode se conectar a ela com os argumentos extras  `hidden yes`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword hidden yes
```
- Se o sistema tiver mais de um adaptador wi-fi, indicamos o que deve ser usado com  `ifname`. Por exemplo, para se conectar usando o adaptador de nome  `wlo1`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword ifname wlo1
```

>[!NOTE]
>
>`nmcli device wifi connect`, apenas o SSID é obrigatório, a senha pode ser omitida caso a conexão já tenha sido criada anteriormente. Se o comando for executado dentro de um emulador de terminal no ambiente gráfico, aparecerá uma caixa de diálogo solicitando a senha da rede. Quando executado em um console de texto, a senha pode ser fornecida junto com os outros argumentos, como no comando acima

- `nmcli device disconnect wlo1`: desconectar da rede conectada anteriormente (não chega a desligar a interface - tanto que `nmcli device list` funciona).

Se houver um adaptador sem fio disponível, mas ele não estiver sendo usado, ele pode ser desligado para economizar energia. Desta vez, o objeto  _radio_  deve ser passado para  `nmcli`:

    $ nmcli radio wifi off

Obviamente, o dispositivo sem fio pode ser ativado novamente com o comando  `nmcli radio wifi on`.

>[!NOTE]
>
>Uma vez que as conexões forem estabelecidas, nenhuma interação manual será necessária no futuro, pois o NetworkManager identifica as redes conhecidas disponíveis e se conecta a elas automaticamente. Se necessário, o NetworkManager possui plugins que podem estender suas funcionalidades, por exemplo para suportar conexões VPN.

>[!NOTE]
>
>o UUID da conexão muda a cada vez que a conexão é ativada e, portanto, é preferível usar o nome para manter a consistência

Redes que o PC já conectou (e conhece):  **/etc/NetworkManager/system-connections**  e se dar um  **ls -la**, vai listar todas as redes que já foram conectadas (tanto wireless como rede cabeada). Inclusive se der um cat (como root) **mostra até a senha da rede** em um dos arquivos de conexão sem fio.

>[!WARNING]
>
>Atenção para os **estados possíveis** na execução de “**nmcli networking connectivity**” (pelo man):
-   **none**: O host não está conectado em nenhuma rede.
-   **portal**: O host está atrás de um “captive portal” e ainda não possui total acesso à Internet. “Captive portal” é a tela de login à qual você é redirecionado ao se conectar em uma rede de hotel ou aeroporto por exemplo.
-   **limited**: O host está conectado à rede, mas não tem acesso à Internet.
-   **full**: O host está conectado à rede e tem total acesso à Internet.
-   **unknown**: O status da conectividade não pode ser encontrado.

##### uma breve apresentação de ifupdown

Primeiramente precisa verificar se o pacote `ifupdown` está instalado: `dpkg -l | grep ifupdown`, caso não tenha, instalar: `apt install ifupdown -y` (nas distros mais recentes esse pacote foi retirado devido a entenderem que o que deve ser utilizado é o `NetworkManager`).

No man `ifup`, fala claramente que tanto `ifup` (para subir interfaces) como `ifdown` (para baixar interfaces) são usados baseados no arquivo `/etc/network/interfaces` (para caso deseje não utilizar o NetworkManager, e usar por arquivo de configuração)

Se tentarmos dar um `ifdown` na interface `enp2s0`, vai retornar que a interface em questão é desconhecida, pois `enp2s0` não está listado no arquivo `/etc/network/interfaces`.

#### systemd-networkd

O `systemd` também tem um gerenciador de rede (`systemctl status systemd-networkd` - provavelmente vai estar desabilitado) muito parecido com o modo de administração do NetworkManager.

No entanto é possível mudar o gerenciamento para o **systemd-networkd**. Basta parar o NetworkManager (`systemctl stop NetworkManager`) e iniciar o systemd-networkd (`systemctl start systemd-networkd`)

Se tentar rodar `nmcli device`, vai dar erro, pois o NetworkManager foi parado anteriormente.

Os arquivos de configuração podem estar em:
- `/lib/systemd/network` (com arquivos `.link` e `.network`) é onde. Aqui seria o diretório de rede do sistema.
- `/etc/systemd/network` : diretório local de administração da rede.
- `/run/systemd/netif` ou `/run/systemd/network`: diretório volátil de tempo de execução da rede.

Os arquivos são processados em ordem lexicográfica, por isso é recomendável iniciar seus nomes com números para facilitar o ordenamento e a leitura.

Os arquivos em  `/etc`  têm a prioridade mais alta, ao passo que os arquivos em  `/run`  têm precedência sobre os arquivos com o mesmo nome em  `/lib`. Ou seja, se dois ou mais arquivos de configuração em diretórios diferentes tiverem o mesmo nome, o systemd-networkd ignora os que tiverem menor prioridade. Essa maneira de separar os arquivos permite mudar as configurações da interface sem que seja necessário modificar os arquivos originais: as modificações podem ser postas em  `/etc/systemd/network`  para sobrescrever as existentes em  `/lib/systemd/network`.

A finalidade de cada arquivo de configuração depende de seu sufixo. Os nomes de arquivos que terminam em  `.netdev`  são usados pelo systemd-networkd para criar dispositivos de rede virtuais, como dispositivos  _bridge_  ou  _tun_. Os arquivos que terminam em  `.link`  definem configurações de baixo nível para a interface de rede correspondente. O systemd-networkd detecta e configura os dispositivos de rede automaticamente conforme eles aparecem — além de ignorar dispositivos já configurados por outros meios — e, portanto, há pouca necessidade de adicionar esses arquivos na maioria das situações.

O sufixo mais importante é  `.network`. Os arquivos que empregam esse sufixo podem ser usados para configurar endereços de rede e rotas. Tal como acontece com os outros tipos de arquivos de configuração, o nome do arquivo define a ordem em que ele será processado. A interface de rede à qual o arquivo de configuração se refere é definida na seção  ``[Match]` ``  dentro do arquivo.

Por exemplo, a interface de rede ethernet  `enp3s5`  pode ser selecionada dentro do arquivo  `/etc/systemd/network/30-lan.network`  graças à entrada  `Name=enp3s5`  na seção  `[Match]`:
```
[Match]
Name=enp3s5
```
Também é possível usar uma lista de nomes separados por espaços em branco para selecionar diversas interfaces de rede de uma vez neste mesmo arquivo. Os nomes podem conter globs no estilo do shell, como  `en*`. Outras entradas permitem usar regras diferentes, como por exemplo selecionar um dispositivo de rede por seu endereço MAC:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b
```
As configurações do dispositivo estão na seção  `[Network]`  do arquivo. Uma configuração de rede estática simples requer apenas as entradas  `Address`  e  `Gateway`:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
Address=192.168.0.100/24
Gateway=192.168.0.1
```
Para usar o protocolo DHCP em vez de endereços IP estáticos, a entrada  `DHCP`  deve ser usada:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
DHCP=yes
```
O serviço systemd-networkd tenta buscar os endereços IPv4 e IPv6 para a interface de rede. Para usar apenas IPv4, empregamos  `DHCP=ipv4`. Da mesma forma,  `DHCP=ipv6`  ignora as configurações IPv4 e usa apenas o endereço IPv6 fornecido.

As redes sem fio protegidas por senha também podem ser configuradas pelo systemd-networkd, mas o adaptador de rede já deve estar autenticado na rede antes que o systemd-networkd possa configurá-lo. A autenticação é realizada pelo  _WPA supplicant_, um programa dedicado a configurar adaptadores de rede para redes protegidas por senha.

O primeiro passo é criar o arquivo de credenciais com o comando  `wpa_passphrase`:
```
# wpa_passphrase MyWifi > /etc/wpa_supplicant/wpa_supplicant-wlo1.conf
```
Este comando pega a frase-senha para a rede sem fio  `MyWifi`  da entrada padrão e armazena seu hash em  `/etc/wpa_supplicant/wpa_supplicant-wlo1.conf`. Note que o nome do arquivo deve conter o nome apropriado da interface sem fio, por isso o  `wlo1`  no nome do arquivo.

O gerenciador do systemd lê os arquivos de frase-senha do WPA em  `/etc/wpa_supplicant/`  e cria o serviço correspondente para executar o WPA supplicant e abrir a interface. O arquivo de frase secreta criado no exemplo terá uma unidade de serviço correspondente chamada  `wpa_supplicant@wlo1.service`. O comando  `systemctl start wpa_supplicant@wlo1.service`  associará o adaptador sem fio ao ponto de acesso remoto. O comando  `systemctl enable wpa_supplicant@wlo1.service`  tornará essa associação automática durante a inicialização.

Finalmente, um arquivo  `.network`  correspondente à interface  `wlo1`  deve estar presente em  `/etc/systemd/network/`, já que o systemd-networkd vai usá-lo para configurar a interface assim que o WPA supplicant encerrar a associação com o ponto de acesso.

Lembrando que a LPI apenas cobra que saiba (awareness) que existe o `systemd-networkd`

#### nomenclaturas das placas de rede

As distribuições Linux mais antigas atribuíam às interfaces de rede ethernet nomes como  `eth0`,  `eth1`, etc., numeradas de acordo com a ordem em que o kernel identificava os dispositivos. As interfaces wireless eram nomeadas  `wlan0`,  `wlan1`, etc. Esta convenção de nomenclatura, no entanto, não esclarece qual porta Ethernet específica corresponde à interface  `eth0`, por exemplo. Dependendo de como o hardware fosse detectado, era possível inclusive que duas interfaces de rede trocassem de nome após uma reinicialização.

Para evitar essa ambiguidade, os sistemas Linux mais recentes empregam uma convenção de nomenclatura previsível para as interfaces de rede, criando uma aproximação maior entre o nome da interface e a conexão de hardware subjacente.

Nas distribuições Linux que usam o esquema de nomenclatura do systemd, todos os nomes de interfaces começam com um prefixo de dois caracteres que indica o tipo de interface:
- `en`: Ethernet
- `ib`: InfiniBand
- `sl`: Serial line IP (slip)
- `wl`: Rede de área local sem fio (WLAN)
- `ww`: Rede de longa distância sem fio (WWAN)

De prioridade mais alta para mais baixa, as seguintes regras são usadas pelo sistema operacional para nomear e numerar as interfaces de rede:

1.  Nomear a interface de acordo com o índice fornecido pela BIOS ou pelo firmware dos dispositivos incorporados, por exemplo,  `eno1`.
2.  Nomear a interface de acordo com o índice do slot PCI Express, conforme fornecido pela BIOS ou firmware, por exemplo,  `ens1`.
3.  Nomear a interface de acordo com seu endereço no barramento correspondente, por exemplo,  `enp3s5`.
4.  Nomear a interface de acordo com o endereço MAC da interface, por exemplo,  `enx78e7d1ea46da`.
5.  Nomear a interface usando a convenção legada, por exemplo,  `eth0`.

É correto pressupor, por exemplo, que a interface de rede  `enp3s5`  recebeu esse nome porque não se encaixava nos dois primeiros métodos de nomenclatura, de forma que seu endereço no barramento e no slot correspondentes foi usado. O endereço do dispositivo  `03:05.0`, encontrado na saída do comando  `lspci`, revela o dispositivo associado:

    $ lspci | fgrep Ethernet
    03:05.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8110SC/8169SC Gigabit Ethernet (rev 10)

As interfaces de rede são criadas pelo próprio kernel do Linux, mas existem muitos comandos que podem ser usados para interagir com elas. Normalmente, a configuração ocorre automaticamente e não há necessidade de se alterar as configurações manualmente. Ainda assim, com o nome da interface, é possível informar ao kernel como proceder para configurá-la se necessário.

## 109.3 Resolução de problemas básicos de rede

Na LPI-1 versão 5, foi adicionado o uso do pacote `iproute2` (`dpkg -l | grep iproute2`), sendo o principal pacote abordado, tendo os principais comandos o `ip` e `ss`.

Quem trabalha com linux a mais tempo, muito provável está mais acostumado a trabalhar com os comandos `ifconfig`, `route` e `netstat`, que são comandos do pacote `net-tools` (para administrar interfaces de rede e rotas no sistema).

O `iproute2` é uma implementação mais moderna, e a tendencia é utilizá-lo no lugar dos comandos do pacote `net-tools`. O pacote `net-tools`, no ponto de vista do exame, exige apenas conhecimento (awareness)

Com o comando IP é possível configurar interfaces e criar rotas. Na lição 109.2, quando foi visto NetworkManager, era ele quem fazia as alterações e configurações diretamente nas interfaces, já com `ip`, é o administrador que faz esse contato direto com as interfaces e todas do computador.

- `ip link show`: mostra as interfaces em uso e se estão funcionando. Não mostra IP. `link` é referente às interfaces (mostra também se está UP/DOWN).
- `ip address show` (pode usar `addr`): mostra com informações do IP
-  `ip route show` ou `ip route list`: mostra as rotas, como a default (pc que não está navegando, pode ser que está sem rota default)

Pressupondo que o sistema de arquivos  `sys`  esteja montado, também podemos listar o conteúdo de  `/sys/class/net`

    $ ls /sys/class/net
    enp0s3  enp0s8  lo

#### manipular endereços na interface

- `ip addr add 192.168.1.50/24 dev enp0s2`: configura o IP `192.168.1.50` na interface `enp0s2` (uma interface de rede pode receber mais de 1 IP)
- `ip addr del 192.168.1.50/24 dev enp0s2`: remove o IP 192.168.1.50 da interface enp0s2
- `ip addr flush dev enp0s2` remove todos os IPs configurados na interface `enp0s2`
- `ip addr add 2001:db8::10/64 dev enp0s8`: define u IPv6 para interface `enp0s8`

*Lembrando que essas alterações são em memória, ao reiniciar o PC, ele pegará as configurações do NetworkManager ou outro programa que esteja configurado para gerenciar a rede.

#### manipular a interface em si

O comando `ip link` é usado para configurar a interface de baixo nível ou para configurações de protocolos, como `VLANs`, `ARP` ou `MTUs`, ou ainda para desabilitar uma interface.

Às vezes é necessário ajustar o MTU de uma interface. Da mesma forma que é possível habilitar/desabilitar interfaces, esse ajuste também pode ser feito com  `ifconfig`  ou  `ip link`:

    # ip link set enp0s8 mtu 2000
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **2000** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff
    # ifconfig enp0s3 mtu 1500
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **1500** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff

- `ip link set enp0s2 down` (para subir usa `up`): baixa a interface `enp0s2` (retira o UP quando `ip link show`). Caso tenha mudado o IP antes de dar down e up, acaba perdendo essa configuração e busca novamente no gerenciador padrão de rede (normalmente NetworkManager).


#### rotas

Se adicionar um IP qualquer em alguma interface, será criado uma rota para a placa de rede escolhida. Se pode exemplo, `ip addr add 10.0.0.10/24 dev enp0s2` for executado, nas rotas (`ip route show`) será adicionado uma entrada dessa forma:
```
10.0.0.0/24 dev enp0s2 proto kernel scope link scr ...
```
Isso indica que tudo que estiver na rede `10.0.0.0/24` vá para interface `enp0s2`

- `ip route del default`: remove a rota default
- `ip route add default via 192.168.1.1`: adiciona uma rota default (nesse caso vai anexar à interface que a rede `192.168.1.0` pertence)
- `ip route add defaul via 192.168.1.1 dev enp0s2`: nesse caso adiciona a rota default à interface desejada, que no caso é `enp0s2`.
- `ip route add 172.16.30.0/24 via 10.0.0.1 dev enp0s2` : todo tráfego que for para a rede `172.16.30.0` vai para a rede `10.0.0.1` (`dev enp0s2` é opcional, pois aqui também detecta pela rede),
- - `ip route del 172.16.30.0/24 via 10.0.0.1 dev enp0s2`: remove a rota criada anteriormente
- 
No comando ip, a  opção `-s` ou `--stats` ou `-statistics` também pode ser usada para obtenção de estatísticas, como pacotes enviados, recebidos e etc, por exemplo:
-   `ip -s address` 
-   `ip -s address show wlp3s0`
-   `ip -s link`
-   `ip -s link show wlp3s0`

#### net-tools (ifconfig e route)

-`ifconfig enp0s8 down`: baixa a interface (se der `ifconfig`, não mostrartá mais, para mostrar precisar usar `ifconfig -a` - display all interfaces which are currently available, even if `down`)
- `ifconfig enp0s8 up`: sobe a interface (vai voltar o que estiver no padrão do NetworkManager)
- `ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0` (pode fazer por CIDR também: `10.0.0.100/24`): coloca o IP 10.0.0.100 na interface `enp0s8`.
- `ifconfig enp0s8 add 2001:db8::10/64`: configura IPv6 na interface.

*Note como, no IPv6, a palavra-chave  `add`  foi usada. Se um endereço IPv6 não for precedido por  `add`, será exibida uma mensagem de erro.

Se um interface já estiver down, e queira subir com IP, acrescente up no final do comando anterior, ficando:
```
ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0 up
```
Adicionar mais de um IP na mesma interface: 

    ifconfig enp0s8:0 10.0.0.100 netmask 255.255.255.0
    ifconfig enp0s8:1 10.0.0.102 netmask 255.255.255.0
    etc

- `route`: mostra a tabela de roteamento (similar ao `ip route`). Rota `default` = `0.0.0.0`
- `route del default`: remove a rota default
- route add default gw 192.168.1.1: adiciona a rota default para o gateway 192.168.1.1
- `route add -net 172.16.30.0/24 gw 192.168.1.50`: tudo que chegar para a rede `172.16.30.0/24` mande para `192.168.1.50`.


#### Comandos Debug

- `hostname -d` (ou `--domain`): mostra o domínio
- `hostname -f` (ou `--fqdn` ou `--long`): mostra o full qualified domain name (nome completo - hostname + domínio). Nome de domínio pega do `/etc/hosts`. Pega informações do NIS domain name (ou do DNS). **NIS (Network Information Service)**, também conhecido como **YP (Yellow Pages)**, é um serviço de diretório usado em sistemas Unix e Linux para compartilhar informações administrativas de forma centralizada em uma rede. Ele é projetado para distribuir dados como usuários, senhas, grupos, informações de hosts, entre outros, para facilitar a administração de sistemas em redes locais.

O **YP domain name** (nome do domínio NIS) é o identificador que agrupa os servidores e clientes NIS que compartilham o mesmo conjunto de informações. Ele é essencial para que os clientes saibam de qual servidor NIS obter dados.

- `ping -c5 192.168.0.1`: dispara 5 `ECHO_REQUEST` para o host/IP, que por sua vez, se acessível, faz 5 `ECHO_REPLY`.
- `ping -c5 -i2 192.168.0.1`: dispara a cada 2 segundos (-i = interval)
- `ping www.google.com`: primeiro vai resolver o domínio, buscando em `/etc/hosts/` e depois no `DNS`. Lembrando que se não está resolvendo o domain name, pode ser que a conexão esteja tudo certo, mas algum problema no `DNS`. Caso esteja resolvendo o domain name e obtendo o IP, mas mesmo não retorna o ping, pode ter algum problema da rota padrão. Uma última opção de falha, seria algum firewall no caminho ou no próprio domínio, que as vezes pode estar configurado para não receber ICMP (por exemplo o domínio `www.lpi.org` não responde a pacotes ICMP)

O `ping` em linhas gerais, trabalha tanto em IPv4 como em IPv6, mas caso queira especificar:
- `ping -4`: especifica que é um endereço IPv4
- `ping -6`: especifica que é um endereço IPv6

Para testar o IPv6, rode `host ipv6.google.com`, para obter o endereço IPv6
- `ping6 2800:3f0:4001:804::200e`: faz o ping no domínio IPv6 do google (O PC assim como o roteador e sua ISP precisam estar preparados para IPv6 para conclusão do comando acima)

- `traceroute www.google.com`: imprime a rota que o pacote faz até chegar ao host  de destino (**NÃO** faz por **ICMP**, e sim por **UDP**)
- `traceroute -I www.google.com` (ou `--icmp`): imprime a rota que o pacote faz até chegar ao host  de destino **USANDO ICMP** (com `-I`, precisa ser **root**).
- `traceroute6 ipv6.google.com`: imprime a rota usando IPv6 (específico para `IPv6`)

Semelhante ao `traceroute` é o `tracepath`. O `tracepath` não precisa ser root para excutar, como acontece com algumas opções do `traceroute`. O tracepath também trabalha com pacotes `UDP`.

Veja a descrição do man do `tracepath`:<br>

*It traces the network path to destination discovering MTU along this path. It uses UDP port port or some random port. It is similar to traceroute. However, it does not require superuser privileges and has no fancy options. tracepath -6 is a good replacement for traceroute6 and classic example of application of Linux error queues. The situation with IPv4 is worse, because commercial IP routers do not return enough information in ICMP error messages. Probably, it will change, when they are updated. For now it uses Van Jacobson's trick, sweeping a range of UDP ports to maintain trace history.*

Entretanto `tracepath` é mais simples do que o `tracepath`. Para IPv6, tem o `tracepath6`

Exercícios interessantes
1. Qual subcomando de  `ip`  pode ser usado para configurar a marcação de vlan?<br>
`ip link`  tem uma opção  `vlan`  que pode ser empregada. Veja abaixo um exemplo de marcação de uma sub-interface com vlan 20.

    # ip link add link enp0s9 name enp0s9.20 type vlan id 20

2. Como fazer backup da tabela de roteamento? Como restaurar esse backup?
    
    O exemplo abaixo demonstra o backup e a restauração de uma tabela de roteamento:
  ```  
    # ip route save > /root/routes/route_backup
    # ip route restore < /root/routes/route_backup
```

3. Qual subcomando de  `ip`  pode ser usado para configurar opções de spanning tree?

Como no caso do gerenciamento de configurações de vlan, o  `ip link`  pode configurar o spanning tree usando o tipo  `bridge`. O exemplo mostra a adição de uma interface virtual com uma prioridade STP de 50:

    # ip link add link enp0s9 name enp0s9.50 type bridge priority 50

#### comando ss e netstat

O `ss` é um comando do pacote `ip route` (mais moderno). O `netstat` pertence ao pacote `net-tools` (mais antigo). Ambos são utilizados para ver as conexões ativas no computador.

    $ whatis ss
    ss (8)               - another utility to investigate sockets
    $ whatis netstat
    netstat (8)          - Print network connections, routing tables, interface statistics, masquerade connections, and multicast...

Eis algumas opções disponíveis para ambos os programas (`ss` e `netstat`):
- `-a`: Mostra todos os sockets.
- `-l`: Mostra os sockets de escuta.
- `-p`: Mostra o processo associado à conexão.
- `-n`: Impede pesquisas de nome para portas e endereços.
- `-t`: Mostra as conexões TCP.
- `-u`: Mostra as conexões UDP.

- `ss`: mostra todas as conexões (e sockets) da máquina (inclusive para abertura de arquivos - que também usam socket)
- `ss -tu` (`-t` ou `--tcp` e `-u` ou `--udp`): lista conexões dos pacotes TCP e UDP estabelecidas no momento (mostra apenas conexões estabelecidas).
- `ss -a` (`--all`): mostra ambas `listening` e `non-listening` sockets
- `ss -l (--listening)`: mostra sockets que estão somente em `listening`(normalmente esses já são omitidos por padrão)

As formas vistas até agora, o comando ss resolve o nome das portas, em vez de colocar o número delas, assim como os hosts, para não resolver, use `-n`:
- `ss -tuln`: mostra sockets somente em `listening`, que sejam TCP e UDP e não resolve os nomes (mostrando o número da porta em si, e não a sua descrição - a descrição é obtida em `/etc/services`)

Com o `netstat`, vai funcionar normalmente, mudando apenas um pouco o formato: `netstat -tuln`

- `netstat ou ss -tanp`: mostra as conexões da porta TCP e UDP, com estado de `listening`, não resolvendo nomes e portas e relacionando o serviço com seu respectivo `PID` (`-p`).

Os exemplos abaixo mostram a saída de um conjunto de opções comumente usado em ambos os programas:

    # netstat -tulnp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      892/sshd
    tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1141/master
    tcp6       0      0 :::22                   :::*                    LISTEN      892/sshd
    tcp6       0      0 ::1:25                  :::*                    LISTEN      1141/master
    udp        0      0 0.0.0.0:68              0.0.0.0:*                           692/dhclient
    # ss -tulnp
    # ss -tulnp
    Netid  State      Recv-Q Send-Q      Local Address:Port                     Peer Address:Port
    udp    UNCONN     0      0                       **:68                                  *:**                   users:(("dhclient",pid=693,fd=6))
    tcp    LISTEN     0      128                     **:22                                  *:**                   users:(("sshd",pid=892,fd=3))
    tcp    LISTEN     0      100             127.0.0.1:25                                  **:**                   users:(("master",pid=1099,fd=13))
    tcp    LISTEN     0      128                  [::]:22                               [::]:*                   users:(("sshd",pid=892,fd=4))
    tcp    LISTEN     0      100                 [::1]:25                               [::]:*                   users:(("master",pid=1099,fd=14))

A coluna  `Recv-Q`  é o número de pacotes que um socket recebeu, mas não passou para seu programa. A coluna  `Send-Q`  é o número de pacotes que um socket enviou e que não foram confirmados pelo receptor. As colunas restantes são autoexplicativas.

Alguns exercícios interessantes

1. Qual comando poderia mostrar se há processos escutando na porta TCP 80?

Com  `ss`:

    $ ss -ln | grep ":80"

Com  `netstat`:

    $ netstat -ln | grep ":80"

Embora este não seja um requisito para o exame, você também poderia usar  `lsof`:

    # lsof -Pi:80

2. Como forçar o  `traceroute`  a usar uma interface diferente?

Usando a opção  `-i`:

    $ traceroute -i eth2 learning.lpi.org
    traceroute -i eth2 learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 60 byte packets

3. O  `traceroute`  é capaz de relatar MTUs?

Sim, com a opção  `--mtu`:

    # traceroute -I --mtu  learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 65000 byte packets
     1  047-132-144-001.res.spectrum.com (47.132.144.1)  9.974 ms **F=1500**  10.476 ms  4.743 ms
     2  096-034-094-106.biz.spectrum.com (96.34.94.106)  8.697 ms  9.963 ms  10.321 ms
    ...

#### netcat

Usado para teste de conexão no computador ou para abrir conexões locais. (arbitrary TCP and UDP connections and listens)

- `netcat 127.0.0.1 22`: teste localmente se é possível conectar na porta 22 (funciona parecido com `telnet`).

>[!NOTE]
>
>`netcat` e `nc` são o mesmo comando.

- `nc -l -p 1234`: abre a porta `1234` para ficar em `listening`. (`-l` = Listen for an incoming connection rather than initiating a connection to a remote host) e (`-p` = source_port: specify the source port `nc` should use, subject to privilege restrictions and availability)
- `nc 192.168.0.20 1234`: conecta na conexão aberta anteriormente (se digitar algo, aparece na outra ponta que está abrindo a conexão)
- `nc -vz 192.168.0.20 1234`: mostra uma mensagem se a conexão foi com sucesso. (`-v` Produce more verbose output) e (`-z` Only scan for listening daemons, without sending any data to them.  Cannot be used together with `-l`.)
- `nc -k -l -p 1234`: mantém a conexão para testes (`-k` When a connection is completed, listen for another one.  Requires `-l`.  When used together with the `-u` option, the server socket is not  connected and it can receive UDP datagrams from multiple hosts.)
- `nc -vz 192.168.0.20 1230-1240`: teste o range de portas definido entre `1230` e `1240`

O netcat funciona com endereços IPv4 e IPv6. Ele funciona com TCP e UDP. Pode inclusive ser usado para configurar um **shell remoto rudimentar**.
```
    $ hostname
    net2
    $ nc -u -e /bin/bash -l 1234
```
A opção  `-u`  significa UDP.  `-e`  instrui o netcat a enviar tudo o que recebe para a entrada padrão do executável que vem em seguida. Neste exemplo,  `/bin/bash`.

    $ hostname
    net1
    $ **nc -u net2.example.net 1234
    hostname
    net2
    pwd
    /home/emma

Percebeu como a saída do comando  `hostname`  corresponde à do host ouvinte e a saída do comando  `pwd`  é um diretório?

>[!WARNING]
>
>Nem toda instalação de  `nc`  suporta a opção  `-e`. Consulte as páginas de manual de sua instalação para obter informações de segurança sobre esta opção, bem como métodos alternativos para executar comandos em um sistema remoto.


## 109.4 Configurar o DNS do lado do cliente

- `/etc/hosts`: referências fixas entre IP e Nomes
- `/etc/nsswitch.conf`: determinar se a primeira consulta vai ser nos arquivos internos (padrão, como `hosts`)
- `/etc/resolv.conf`: arquivo principal onde é adicionado os servidores DNS (indicado por `nameserver`). Aqui que pode ter configuração de domínio: `domain dominio.com.br`
- `/etc/resolv.conf` está sendo gerado por  `/run/systemd/resolve/stub-resolv.conf` (resolvedor interno, pelo serviço `systemd.resolvd`)
- comando `resolvectl status` para ver os DNS configurados propriamente dito
- comando `resolvectl statistics` mostra estatísticas do servidor DNS, com cache, total de transações, etc.

A opção  `search` (em `/etc/resolv.conf`)  é usada para permitir pesquisas curtas. No exemplo, configuramos um único domínio para pesquisa,  `lpi.org`. Isso significa que qualquer tentativa de resolver um nome de host sem uma parte de domínio terá  `.lpi.org`  incluído antes da pesquisa. Por exemplo, se pesquisarmos por um host chamado  `learning`, o resolvedor buscará por  `learning.lpi.org`. É possível configurar até seis domínios de pesquisa.

Outra opção comum é  `domain`. Ela é usada para definir o nome de domínio local. Se esta opção estiver ausente, o padrão é usar tudo após o primeiro  `.`  no nome de host da máquina. Se o nome do host não contiver um  `.`, presume-se que a máquina faça parte do domínio raiz. Como no caso de  `search`,  `domain`  pode ser usado para pesquisas curtas de nomes.

Lembre-se de que  `domain`  e  `search`  são mutuamente exclusivos. Se ambos estiverem presentes, será usada a última instância no arquivo.

Muitas opções podem ser definidas de forma a afetar o comportamento do resolvedor. Para configurá-las, use a palavra-chave  `option`, seguida pelo nome da opção a ser configurada e, se for o caso, um  `:`  seguido pelo valor. Veja abaixo um exemplo de configuração da opção de tempo limite (timeout), ou seja, o período de tempo em segundos que o resolvedor espera por um servidor de nome antes de desistir:

    option timeout:3

O systemd inclui um serviço chamado `systemd-resolved`. Ele fornece mDNS, DNS e LLMNR. Quando está em execução, ele escuta as solicitações de DNS em `127.0.0.53`. Ele _não_ fornece um servidor DNS completo. Quaisquer solicitações de DNS que recebe são pesquisadas nos servidores configurados em `/etc/systemd/resolv.conf` ou `/etc/resolv.conf`. Se você deseja empregar o serviço, use `resolve` para `hosts` em `/etc/nsswitch.conf`. Lembre-se de que o pacote do sistema operacional que possui a biblioteca `systemd-resolution` pode não estar instalado por padrão

- `getent`, é útil para ver como as solicitações do mundo real serão resolvidas.
- `host`, é ótimo para consultas de DNS simples. 
- `dig` é prático para operações de DNS complexas que podem ajudar na resolução de problemas do servidor DNS.

- `host www.debian.org`: usa o servidor DNS para resolver o endereço www.debian.org. Se retirar o `www`, mostra todos os IPs relacionados ao domínio.
- `host www.debian.org 1.1.1.1`: consulta usando o server `1.1.1.1`
- `host -t mx debian.org`: mostra quais são os servidores que recebem query relacionadas aos emails no domínio. (`-t type`: This option specifies the query type. The type argument can be any recognized query type: `CNAME`, `NS`, `SOA`, `TXT`, `DNSKEY`, `AXFR`, etc)

- `dig` (antigamente usava `nslookup`): parecido com `host`, mas tem mais opções (internamente consulta o `systemd-resolve`).
- `dig www.debian.org @1.1.1.1`: consulta usando o server `1.1.1.1`
- `dig www.debian.org +short`: mostra só o IP (retira outros cabeçalhos)
- `dig -x 200.45.31.18`: resolve reverse lookups (mostra o nome associado ao IP)

- `getent`: pela entradas do Name Service Switch libraries (`/etc/nsswitch.conf`)
- `getent passwd`: mostra informações do `/etc/passwd`
- `getent passwd rodrigo`: mostra informações do usuário rodrigo
- `getent hosts www.debian.org`: resolve o domínio (tende resolver IPv6 - diferentemente de `host www.debian.org`, que traz IPv4 e IPv6)
- `getent ahostsv4 www.debian.org`: resolve em IPv4

Databases suportadas:
`ahosts` `ahostsv4` `ahostsv6` `aliases` `ethers` `group` `gshadow` `hosts` `initgroups` `netgroup` `networks` `passwd` `protocols` `rpc` `services` `shadow` (lembrar que `/etc/nsswitch.conf` que aponta por meio de `db files`)

Exercicios interessantes

1. Qual das opções a seguir é uma entrada correta de  `/etc/hosts`  entry?

| | |
|---|---|
|  ::1 localhost | certo |
| **localhost 127.0.0.1** | errado  |

`::1 localhost`  é a linha correta. A coluna da esquerda é sempre um endereço IPv4 ou IPv6.

2. O que significa a seguinte linha em  `/etc/nsswitch.conf`?
```
    hosts: files [SUCCESS=continue] dns
```
As pesquisas por nomes de host verificarão primeiro os arquivos de  `/etc/hosts`  e em seguida o DNS. Se uma entrada for encontrada nos arquivos e no DNS, a entrada no DNS será preferida.

3. O que faz o comando  `dig +noall +answer +question lpi.org`?

Ele pesquisa o registro A de  `lpi.org`  e exibe apenas a consulta e a resposta.

4. Como passar por cima dos padrões de  `dig`  sem especificá-los na linha de comando?

Criando um arquivo  `.digrc`  em seu diretório inicial

## 110.1 Executar tarefas administrativas de segurança

#### su e sudo
- `su`: muda de usuário para outro (loga como `root`: precisa digitar a senha do `root`)
- `sudo su`: loga como root usando a senha do usuário normal.

- `su lpi2`: loga com usuário `lpi2` (apenas muda o usuário - não executa o `.profile`, não cai no `home` do usuário propriamente dito)
- `su - lpi2`: loga com usuário `lpi2` (faz um novo login, como usuário `lpi2`, executando o `.profile` e caindo no home do usuário `lpi2`)
- `su -`: o mesmo que o explicado anteriormente. (aqui é feito um login propriamente dito, carrega as informações de `.profile`). Só `su` não faz efetivamente login.

Há alguns comandos que exigem que seja executado somente pro user root, como o `fdisk`, por exemplo.

Para executar uma vez, estando com usuário lpi1: `su -c "fdisk -l` (vai pedir senha do usuário root - `-c` = `--command`). Depois de executar volta ao usuário comum.

O `sudo` serve para situações que você não tenha a senha do usuário root (comum em ambientes de produção), e que precisa executar algo com privilégios de root.
- `sudo su -`: se estiver logado como `lpi1`, vai pedir a senha de `lpi1`, e loga como `root`. (isso porque `lpi1` tem permissões de logar como `root`)

Agora caso seja um usuário que não tenha permissão, e tente se logar, teremos a seguinte mensagem de erro:
```
$ sudo su -
[sudo] password for lpi2:    
Sorry, user lpi2 is not allowed to execute '/usr/bin/su -' as root on computer-name.

ou

lpi2 is not in the sudoers file. This incident will be reported.
```

Caso possua as permissões, pode simplesmente executar comandos como root usando: `sudo fdisk -l`

- `/etc/sudoers`: arquivo de configuração que vai dizer o que quais usuário podem fazer as alterações no sistema. A `%`no sufixo dos nomes `admin` e `sudo` indica que tanto `%admin` como `%sudo` são grupos.
- `%admin = ALL=(ALL) ALL`: membros do grupo `admin`, podem a partir de qualquer terminal (primeiro `ALL`), utilizando qualquer usuário (segundo `ALL`), podem executar qualquer comando (terceiro `ALL`)
- `%sudo ALL=(ALL:ALL) ALL`: mesmo raciocínio, agora para o grupo `sudo`. O usuário criado na instalação, muito provavelmente estará nesse grupo. Confirme com o comando `grep sudo /etc/group`. Para adicionar um usuário ao grupo `sudo`, digite: `sudo usermod -aG sudo usuario`. Para remover use: `sudo usermod -rG sudo usuario`

Se quiser personalizar uma regra, por exemplo para determinar que usuário `lpi2` possa desligar o computador, inclua o seguinte no arquivo `/etc/sudoers`

    lpi2 ALL=/sbin/poweroff

Caso queira listar os comandos que deseja liberar (lembrando vai pedir a senha do usuário, o que vai acontecer é como se estivesse no grupo `sudo`):

    Cmnd_Alias TESTE = /sbin/fdisk, /sbin/parted
    lpi2  ALL=TESTE

- `visudo`: vai direto para edição do `/etc/sudoers` (usando o editor padrão - para alterar o editor padrão: `update-alternatives --config editor`)

**Observações**: O  `sudo`  permite executar comandos simples com privilégios elevados em vez de lançar um novo subshell para root, como faria  `su`.
    
O uso básico de  `sudo`  é  `sudo -u  _target-username_  _command_`. Porém, para executar um comando como usuário root, a opção  `-u  _target-username_`  não é necessária:

    carol@debian:~$ sudo -u mimi whoami
    mimi
    carol@debian:~$ sudo whoami
    root

>[!NOTE]
>
>O  `sudoers`  usa uma marca temporal por usuário (e por terminal) para ocultar as credenciais, sendo assim possível usar o  `sudo`  sem uma senha por um período padrão de quinze minutos. Esse valor padrão pode ser modificado adicionando-se a opção  `timestamp_timeout`  como configuração de  `Defaults`  em  `/etc/sudoers`  (p. ex.:  `Defaults timestamp_timeout=1`  define o tempo limite do cache de credenciais como um minuto).

#### O arquivo  `/etc/sudoers`

O arquivo de configuração principal do  `sudo`  é  `/etc/sudoers`  (também existe o diretório  `/etc/sudoers.d`). É ali que os privilégios de  `sudo`  dos usuários são determinados. Em outras palavras, aqui você especifica quem pode executar quais comandos, sob quais nomes de usuário e em quais máquinas — bem como outras configurações. A sintaxe usada é a seguinte:

    carol@debian:~$ sudo less /etc/sudoers
    (...)
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    (...)

A especificação de privilégio para o usuário root é  `ALL=(ALL:ALL) ALL`. Isso se traduz assim: o usuário root (`root`) pode se logar com todos os hosts (`ALL`), em nome de todos os usuários e todos os grupos (`(ALL:ALL)`), além de executar todos os comandos (`ALL`). O mesmo vale para os membros do grupo  `sudo` — note como os nomes de grupos são identificados com um símbolo de porcentagem (`%`).

Assim, para que a usuária  `carol`  seja capaz de verificar o status de  `apache2`  de qualquer host em nome de qualquer usuário ou grupo, adicionaríamos a seguinte linha ao arquivo  `sudoers`:

    carol   ALL=(ALL:ALL) /usr/bin/systemctl status apache2

Para evitar a  `carol`  o incômodo de precisar fornecer sua senha para executar o comando  `systemctl status apache2`, modificamos a linha desta maneira:

    carol   ALL=(ALL:ALL) NOPASSWD: /usr/bin/systemctl status apache2

Digamos que agora você queira restringir seus hosts a 192.168.1.7 e permitir que  `carol`  execute  `systemctl status apache2`  no nome da usuária  `mimi`. A linha teria de ser modificada desta forma:

    carol   192.168.1.7=(mimi) /usr/bin/systemctl status apache2

Vamos então verificar o status do servidor web Apache como a usuária  `mimi`:

    carol@debian:~$ sudo -u mimi systemctl status apache2
    ● apache2.service - The Apache HTTP Server
       Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
       Active: active (running) since Tue 2020-06-09 13:12:19 CEST; 29min ago
    (...)

Se  `carol`  fosse promovida a sysadmin e você quisesse conceder a ela todos os privilégios, a maneira mais fácil seria incluí-la no grupo especial  `sudo`  com  `usermod`  e a opção  `-G`  (e talvez também a opção  `-a`, que garante que o usuário não seja removido de nenhum outro grupo ao qual possa pertencer):

    root@debian:~# sudo useradd -aG sudo carol

>[!NOTE]
>
>Na família de distribuições Red Hat , o grupo  `wheel`  é equivalente ao grupo especial de administradores  `sudo`  dos sistemas Debian.

Além dos usuários e grupos, também podemos utilizar aliases em  `/etc/sudoers`. É possível definir três categorias principais de aliases:  _aliases de host_  (`Host_Alias`),  _aliases de usuário_  (`User_Alias`) e  _aliases de comando_  (`Cmnd_Alias`). Eis um exemplo:

    # Host alias specification
    
    Host_Alias SERVERS = 192.168.1.7, server1, server2
    
    # User alias specification
    
    User_Alias REGULAR_USERS = john, mary, alex
    
    User_Alias PRIVILEGED_USERS = mimi
    
    User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
    
    # Cmnd alias specification
    
    Cmnd_Alias SERVICES = /usr/bin/systemctl *
    
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    ADMINS  SERVERS=SERVICES
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL

A partir deste arquivo  `sudoers`  de amostra, vamos explicar os três tipos de aliases com um pouco mais de detalhes:

- **Aliases de host**: Incluem uma lista separada por vírgulas de nomes de host, endereços IP, redes e grupos de rede (precedidos por  `+`). Máscaras de rede também podem estar especificadas. O alias de host  `SERVERS`  inclui um endereço IP e dois nomes de host:
```
Host_Alias SERVERS = 192.168.1.7, server1, server2
```
- **Aliases de usuário**: Incluem uma lista separada por vírgulas de usuários especificados como nomes de usuários, grupos (precedidos por  `%`) e grupos de rede (precedidos por  `+`). Para excluir usuários específicos, usamos  `!`. O alias de usuário  `ADMINS` — por exemplo — inclui a usuária  `carol`, os membros do grupo  `sudo`  e os membros do alias de usuário  `PRIVILEGE_USERS`  que não pertencem ao alias de usuário  `REGULAR_USERS`:
```
User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
```
- **Aliases de comando**: Incluem uma lista separada por vírgulas de comandos e diretórios. Se um diretório for especificado, qualquer arquivo que esteja nesse diretório será incluído — mas os subdiretórios serão ignorados. O alias do comando  `SERVICES`  inclui um único comando com todos os seus subcomandos — conforme especificado pelo asterisco (`*`):
```
Cmnd_Alias SERVICES = /usr/bin/systemctl *
```
Como resultado das especificações de alias, a linha  `ADMINS SERVERS=SERVICES`  na seção  `User privilege specification`  é traduzida como: todos os usuários pertencentes a  `ADMINS`  podem usar  `sudo`  para executar qualquer comando em  `SERVICES`  em qualquer servidor em  `SERVERS`.

>[!NOTE]
>
>Existe um quarto tipo de alias que pode ser incluído em  `/etc/sudoers`:  _aliases de execução_  (`Runas_Alias`). São muito semelhantes aos aliases de usuário, mas permitem especificar usuários por seu  _ID de usuário_  (UID). Esse recurso pode ser conveniente em certos casos.

#### who, w, last, lastb, lastlog

- `who`: mostra quem está logado no sistema, mostrando usuário, o terminal (`tty7` = terminal gráfico) e horário que logou. Se apertar `Ctrl+Alt+F2` (vai para o `tty2`), e se logar por lá, voltar para o `tty` e digita novamente `who`, vai mostrar a sessão de `tty2`
- `who -aH` (`-a` = `--all` e `-H` = `--heading`, colocar um header): mostra mais detalhes, assim como os terminais que não estão em uso, mostra também o `pid`.

O `who` aceita uma série de opções, dentre as quais podemos destacar as seguintes:
- `-b`,`--boot`: Exibe a hora da última inicialização do sistema.
- `-r`,`--runlevel`: Mostra o nível de execução atual.
- `-H`,`--heading`: Imprime o cabeçalho das colunas.

- `w`: mostra quem está logado e o que está fazendo (Show who is logged on and what they are doing.). Se voltar lá no `tty2` e executar o `top`, voltar para `tty7` e digitar `w`, mostra todas as informações do que o usuário que logou no `tty2` está fazendo, quanto está consumindo, etc. **JCPU** = uso de CPU no geral, **PCPU** = quanto o processo que está sendo executado (`top`) está consumindo. Ideal para monitorar sessões que estão consumindo muito recurso do computador.

>[!NOTE]
>
>Comparado ao  `who`, o  `w`  fornece uma saída um pouco mais detalhada:

Como no caso do  `who`, podemos passar nomes de usuários ao  `w`: `root@debian:~# w lpi2`

- `last`: histórico de logins no computador. Mostra o usuário que logou, o terminal que usou, quando foi feito o login, e quanto tempo ficou logado.
- `last lpi2`: mostra os últimos logins do usuário `lpi2`
- `lastb`: histórico de usuários que tentaram se logar, mas erraram a senha, ou usuário não existia. Esses dados (do `last`) são consultados de `/var/log/wtmp` (arquivo binário). Para ler usar last -f `/var/log/wtmp` (`-f` ou `--file`). O `lastb` é lido em `/var/log/btmp`. Para ler faz igual ao last: `last -f /var/log/btmp`

- `lastlog`: mostra quando os usuários do sistema fizeram login (login mesmo, não conta `su -`). `Observação`: usuários de sistema normalmente não devem ter feito login (precisa mostrar como `Never logged in`.
- `lastlog -u rodrigo` (`-u` ou `--user`): mostra o último login do usuário `lpi2`

#### passwd, usermod e chage

- `chage`: muda as definições de tempo para a senha expirar, conta inativa. Olhar novamente no item 107.1 parte 4. Similar ao `passwd`

- `passwd -S lpi2` (`-S` ou `--status`): mostra o status do usuário `lpi2`
```
lpi1@debian:~$ passwd -S
lpi1 P 12/07/2019 0 99999 7 -1
```
Eis uma análise dos sete campos obtidos na saída:
- `lpi1`: Nome de login do usuário.
- `P`: Indica que o usuário possui uma senha válida (`P`); outros valores possíveis são  `L`  para uma senha bloqueada e  `NP`  para nenhuma senha.
- `12/07/2019`: Data da última alteração da senha.
- `0`: Idade mínima em dias (o número mínimo de dias entre mudanças de senha). Um valor de  `0`  significa que a senha pode ser alterada a qualquer momento.
- `99999`: Idade máxima em dias (o número máximo de dias em que a senha é válida). Um valor de  `99999`  desabilita a expiração da senha.
- `7`: Período de aviso em dias (o número de dias antes da expiração da senha em que um usuário será avisado).
- `-1`: Período de inatividade da senha em dias (o número de dias inativos após a expiração da senha até que a conta seja bloqueada). Um valor de  `-1`  remove a inatividade de uma conta.

- `passwd -x30 lpi2` (`-x` ou `--maxday`): define para a senha expirar daqui `30` dias. (consulte com `chage -l lpi2`) (similar ao `chage -M` ou `--maxdays`)
```
chage -l lpi2
Last password change					: Nov 13, 2024
Password expires					: Dec 13, 2024
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 30 #definiu aqui
Number of days of warning before password expires	: 7
```
- `passwd -n2 lpi2` (ou `--mindays`): define o mínimo de dias que o usuário pode trocar a senha. Similar ao `chage -m` ou `--mindays`.

- `passwd -w4 lpi2` ( ou`--warndays`): número de dias que vai alertar que a senha vai expirar (Number of days of warning before password expires). No `chage`, seria `chage -W` ou `--warndays`
- `passwd -i10 lpi2` (ou `--inactive`): depois de 10 dias que a conta expirar, a conta vai ficar inativa. O `chage` seria `chage -I` ou `--inactive`
- `passwd -l lpi2` (ou `--lock`): trava (lock) o usuário `lpi2` (colocar `!` no primeiro caractere do campo de senha do `/etc/shadow`) - usando quando precisa investigar o usuário. Para destravar `passwd -u lpi1` (ou `--unlock`): retira a exclamação `/etc/shadow`. Quando estiver lock, no `passwd -S lpi2` vai mostrar um `L` de `Locked`. Se estiver `unlocked`, vai mostrar um `P` de `Password`. No `chage` seria `chage -E` ou `--expiredate` para fazer lock do usuário e `chage -1` para deixar `unlocked`

- `usermod -L lpi2` (ou `--lock`): trava (lock) o usuário
- `usernod -U lpi2` (ou `--unlock`): remove lock da conta.
- `usermod -e lpi2` (ou `--expiredate`): colocar uma data de expiração.
- `usermod -f lpi2` (ou `--inactive`): quantidade de dias que vai ficar inativo quando expirar a senha

#### find, ulimit, limits.conf

Partindo do cenário que `/usr/bin/passwd` tem o bit **SUID** ligado (`rwsr-xr-x`) e que qualquer usuário pode executá-lo como `root` e, diferentemente de `/bin/rm`, que por segurança não possui bit **SUID** ligado (pois qualquer usuário poderia excluir pastas críticas), é interessante monitorar por arquivos com **SUID** ligado, com o comando find.

- `find / -perm -4000 -ls` (ou `-2000`): `4000` procura por **SUID** e `2000` pelo **SGID** (o `-ls` no final é apenas para listar).
- `find / \( -perm -2000 -o -perm -4000 \) -ls
`: procura tanto por **SUID** como por **GUID** (precisa proteger com parênteses e escapá-los - o `-o` = or/ou).
- `find / -perm /6000`: busca tanto **SUID** como **GUID**

>[!NOTE]
>
>Pode usar com a notação simbólica: `find / -perm -u+s` para 4000 ou `find / -perm -g+s` para 2000.

Situação ideal seria criar um script que guarde essa informação diariamente, e compare, e caso haja mudança emita um alerta ao Administrador.

Outra medida de segurança é buscar por arquivos que não tenham usuários associados, novamente com o `find`:
- `find / -path /proc -prune -nouser -ls`: mostra todos

Alguns exercícios interessantes dessa seção:

1. O `chage` permite alterar as informações de expiração de senha de um usuário. Como root, complete a seguinte tabela, fornecendo os comandos corretos para o usuário `mary`:
2. 
| Significado           | Comandos `chage`                  |
|---------------------------|--------------------------------------|
| Faça a senha ser válida por 365 dias.                                       | `chage -M 365 mary`, `chage --maxdays 365 mary`                             |
| Faça o usuário alterar a senha no próximo login.                           | `chage -d 0 mary`, `chage --lastday 0 mary`                                 |
| Defina o número mínimo de dias entre as alterações de senha para 1.         | `chage -m 1 mary`, `chage --mindays 1 mary`                                 |
| Desative a expiração da senha.                                              | `chage -M 99999 mary`, `chage --maxdays 99999 mary`                         |
| Permita que o usuário altere sua senha a qualquer momento.                  | `chage -m 0 mary`, `chage --mindays 0 mary`                                 |
| Defina o período de aviso para 7 dias e a data de expiração da conta para 20 de agosto de 2050. | `chage -W 7 -E 2050-08-20 mary`, `chage --warndays 7 --expiredate 2050-08-20 mary` |
| Imprima as informações de validade da senha atual do usuário.               | `chage -l mary`, `chage --list mary`                                        |

2. Considere a seguinte linha de saída de comando  `last`  e responda às perguntas:
```
carol    pts/0        192.168.1.4      Sun May 31 14:16 - 14:22  (00:06)
```
-   `carol`  estava conectada a partir de um host remoto? Por quê?
    Sim, o endereço IP do host remoto está na terceira coluna.
    
-   Quanto tempo durou a sessão de  `carol`?
    Seis minutos (como mostrado na última coluna).
    
-   `carol`  estava conectada através de um terminal de texto clássico? Por quê?
    Não,  `pts/0`  na segunda coluna indica que a conexão foi feita por meio de um emulador de terminal gráfico (ou  _Pseudo Terminal Slave_).

3. Além de  `SUID`  e  `SGID`, existe uma terceira permissão especial: o  _sticky bit_. No momento, ele é usado principalmente em diretórios como  `/tmp`  para evitar que usuários regulares excluam ou movam arquivos que não sejam seus. Realize as seguintes tarefas:

-   Defina o  _sticky bit_  em  `~/temporal`:
    ```
    `chmod +t temporal`,  `chmod 1755 temporal`
    ```
-   Encontre diretórios com o  _sticky bit_  (e quaisquer outras permissões) definidas em seu diretório inicial:
    ```
    `find ~ -perm -1000`,  `find ~ -perm /1000`
    ```
-   Remova o  _sticky bit_  de  `~/temporal`:
    ```
    `chmod -t temporal`,  `chmod 0755 temporal`
    ```
## 110.2 Configurar a segurança do host



## 110.3 Proteção de dados com criptografia

#### O que é criptografia

Uma maneira de garantir que dados sejam enviados de um ponto a outro de maneira segura, tendo os objetivos principais:
	- Autenticidade (do remetente)
	- Confidencialidade (da mensagem)
	- Integridade (da mensagem)
	- Irretratabilidade (do remetente)

#### SSH - Secure Shell

- protocolo de criptográfica de rede
- cria um canal seguro de comunicação entre 2 hosts, um cliente

# LPIC-1 Exam 101
#### Version: 5.0
LPIC-1 é a primeira certificação no programa de certificação profissional Linux multinível da LPI. O LPIC-1 validará a capacidade do candidato de realizar tarefas de manutenção na linha de comando, instalar e configurar um computador executando Linux e configurar a rede básica.

# Parte 2

## 102-500

### 105.1 Personalizar e trabalhar no ambiente shell

Relembrando:
- `env` ou `printenv`: imprime uma lista de todas as variáveis de ambiente

- `printenv` ainda pode ser usado de forma semelhante ao comando `echo`:<br>

    $ echo $PWD
    /home/user2
    $ printenv PWD
    /home/user2
Note, entretanto, que com `printenv` o nome da variável não é precedido por `$`.

- `echo $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

>[!NOTE]
>
>Para remover variáveis definidas (locais ou globais), usamos o comando  `unset`:

    $ echo $reptile
    tortoise
    $ unset reptile
    $ echo $reptile
    $

>[!NOTE]
>
>`unset` deve ser seguido somente pelo nome da variável (não precedido pelo símbolo `$`)

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Para criarmos variáveis imutáveis, basta a deixarmos como **readonly** (somente leitura).<br>
Ex. `readonly reptile=tortoise`<br>
Ou transformá-las depois de criá-las:<br>

    reptile=tortoise
    readonly reptile

Agora, se tentarmos alterar o valor de  `reptile`, o Bash se recusará:

    $ reptile=lizard
    -bash: distro: readonly variable

>[!NOTE]
>
>Para listar todas as variáveis somente leitura da sessão atual, digite `readonly` ou `readonly -p` no terminal

Para que uma variável local do shell se torne uma variável de ambiente, usamos o comando  `export`:

    $ export reptile

Com  `export reptile`, transformamos nossa variável local em uma variável de ambiente para que os shells filhos possam reconhecê-la e usá-la:

    $ bash
    $ echo $reptile
    tortoise

Da mesma maneira,  `export`  pode ser usado para definir e exportar uma variável de uma só vez:

    $ export amphibian=frog

Agora podemos abrir uma nova instância do Bash e referenciar com sucesso a nova variável:

    $ bash
    $ echo $amphibian
    frog

>[!NOTE]
>
>Com `export -n <VARIABLE-NAME>`, a variável será novamente transformada em variável local do shell.

- `export` ou `export -p`: lista todas as variáveis de ambiente existentes. (`declare -x` é equivalente a `export`)

Comando `alias`: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente `alias`, é mostrado os alias cadastrados no bash atual.

- `unalias alias_criado`: remove o alias criado

Podemos escapar um alias com  `\`:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ \where?
    -bash: where?: command not found

O escape de um alias é útil quando um alias tem o mesmo nome de um comando regular. Nesse caso, o alias tem precedência sobre o comando original, que, no entanto, ainda pode ser acessado escapando-se o alias.

Da mesma forma, podemos colocar um alias dentro de outro alias:

    $ where?
    /home/user2
    $ alias my_home=where?
    $ my_home
    /home/user2

Além disso, também é possível colocar uma função dentro de um alias, como será demonstrado mais adiante.

#### Expansão e avaliação de aspas em aliases

Ao se usar aspas com variáveis de ambiente, as aspas simples tornam a **expansão dinâmica**:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2/Music

No entanto, com aspas duplas, a expansão é feita **estaticamente**:

    $ alias where?="echo $PWD"
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2

#### Persistência de aliases: scripts de inicialização

Como no caso das variáveis, para que nossos aliases se tornem persistentes devemos colocá-los em scripts de inicialização que são originados quando o sistema é iniciado. Como já sabemos, um bom arquivo para os usuários colocarem seus aliases pessoais é  `~/.bashrc`. Já deve haver alguns aliases por lá (a maioria deles comentados e prontos para uso, bastando remover o  `#`  inicial):

    $ grep alias .bashrc
    # enable color support of ls and also add handy aliases
        alias ls='ls --color=auto'
        #alias dir='dir --color=
        #alias vdir='vdir --color=
        #alias grep='grep --color=
        #alias fgrep='fgrep --color'
        #alias egrep='egrep --color=
    # some more ls aliases
    #ll='ls -al'
    #alias la='ls -A'
    #alias l='ls -CF'
    # ~/.bash_aliases, instead of adding them here directly.
    if [ -f ~/.bash_aliases ]; then
       . ~/.bash_aliases

Como podemos ver nas últimas três linhas, é possível ter nosso próprio arquivo dedicado aos aliases — `~/.bash_aliases` — para o  `.bashrc`  abrir e executar a cada inicialização do sistema. Ao escolher essa opção, criamos e preenchemos esse arquivo:

    ###########
    # .bash_aliases:
    # a file to be populated by the user's personal aliases (and sourced by ~/.bashrc).
    ###########
    alias git_info='which git;git --version'
    alias greet='echo Hello world!'
    alias ll='ls -al'
    alias where?='echo $PWD

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Como no caso das variáveis e aliases, se quisermos que as funções sejam persistentes durante as reinicializações do sistema, temos de colocá-las em scripts de inicialização do shell, como  `/etc/bash.bashrc`  (global) ou  `~/.bashrc`  (local).

>[!WARNING]
>
>Depois de adicionar aliases ou funções para qualquer arquivo de script de inicialização, é preciso executar  `.`  ou  `source`  nesses arquivos para que as alterações tenham efeito (caso você não queira fazer logout e login novamente ou reinicializar o sistema).

#### Variáveis integradas especiais do Bash

O  _Bourne Again Shell_  vem com um conjunto de variáveis especiais que são particularmente úteis para funções e scripts. Elas são especiais porque só podem ser referenciadas — e não atribuídas. Eis uma lista das mais relevantes:

- `$?`: a referência desta variável se expande para o resultado do último comando executado. Um valor de  `0`  significa sucesso:

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $?
    0

Um valor diferente de  `0`  significa erro:

    user1@debian:~$ ps aux |rep bash
    -bash: rep: command not found
    user1@debian:~$ echo $?
    127

- `$$`: expande-se para o PID do shell (ID do processo):

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $$
    420

- `$!`: expande-se para o PID do último trabalho em segundo plano:

    $ ps aux | grep bash &
    [1] 663
    $ user2      420  0.0  0.4  21156  5012 pts/0    Ss+  17:10   0:00 -bash
    user2      663  0.0  0.0  12784   972 pts/0    S    18:08   0:00 grep bash
    ^C
    [1]+  Done                   ps aux | grep bash
    $ echo $!
    663

>[NOTE]
>
>Lembre-se, o e comercial (`&`) é usado para iniciar processos em segundo plano.

#### Parâmetros posicionais  `$0`  a  `$9`

Expandem-se para os parâmetros ou argumentos que estão sendo passados para a função (alias ou script) — `$0`  se expande para o nome do script ou shell.

Um _parâmetro posicional_ é um parâmetro denotado por um ou mais dígitos diferentes do dígito único `0`. Por exemplo, a variável `$1` corresponde ao primeiro argumento dado ao script (parâmetro posicional um), `$2` corresponde ao segundo argumento e assim por diante. Se a posição de um parâmetro for maior que nove, ele deve ser referenciado com chaves, como em `${10}`, `${11}` etc.

Vamos criar uma função para demonstrar os parâmetros posicionais — note  `PS2`  (`>`) indicando novas linhas após as quebras de linha:

    $ special_vars() {
    > echo $0
    > echo $1
    > echo $2
    > echo $3
    }

Agora, vamos invocar a função (`special_vars`) passando três parâmetros para ela (`debian`,  `ubuntu`,  `zorin`):

    $ special_vars debian ubuntu zorin
    -bash
    debian
    ubuntu
    zorin

Tudo funcionou como esperado.

>[!WARNING]
>
>Embora seja tecnicamente possível passar parâmetros posicionais para aliases, não é lá muito prático, já que — com aliases — os parâmetros posicionais são sempre passados no final:

    $ alias great_editor='echo $1 is a great text editor'
    $ great_editor emacs
    is a great text editor emacs

#### Outras variáveis integradas especiais do Bash incluem:

- `$#`: expande-se para o número de argumentos passados para o comando.
- `$@`,  `$*`: expandem-se para os argumentos passados para o comando.
-`$_`:  expande-se para o último parâmetro ou o nome do script (dentre outras coisas; consulte  `man bash`  para saber mais!):

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada E**TCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

#### Variáveis

Pode conter letras (`a-z, A-Z`), números (`0-9`) e sublinhados (`_`). E não deve começar com um número para não confundir o Bash. Não deve conter espaços (nem mesmo entre aspas), por convenção, os sublinhados são usados no lugar dos espaços.

No que diz respeito à referência ou valor das variáveis, também é importante considerar uma série de regras. As variáveis podem conter quaisquer caracteres alfanuméricos (`a-z`,`A-Z`,`0-9`), além da maioria dos outros caracteres (`?`,`!`,`*`,`.`,`/`, etc.). Os valores das variáveis devem ser postos entre aspas se contiverem espaços simples.

Os valores das variáveis também devem ser postos entre aspas se contiverem caracteres como os usados para redirecionamento (`<`,`>`) ou o símbolo de barra vertical (`|`). A única coisa que o comando a seguir faz é criar um arquivo vazio chamado  `zorin`:

    $ distro=>zorin
    $ echo $distro
    
    $ ls zorin
    zorin

Mas quando usamos as aspas, a coisa funciona:

    $ distro=">zorin"
    $ echo $distro
    >zorin

No entanto, aspas simples e duplas nem sempre são intercambiáveis. Dependendo do que estamos fazendo com uma variável (atribuindo ou referenciando), o uso de uma ou de outra tem implicações e produzirá resultados diferentes. No contexto da atribuição de variáveis, as **aspas simples** consideram  _literalmente_  todos os caracteres do valor da variável, enquanto as **aspas duplas** permitem a substituição de variáveis:

    $ lizard=uromastyx
    $ animal='My $lizard'
    $ echo $animal
    My $lizard
    $ animal="My $lizard"
    $ echo $animal
    My uromastyx

Por outro lado, ao referenciar uma variável cujo valor inclui alguns espaços iniciais (ou extras) — às vezes combinados com asteriscos — é obrigatório usar aspas duplas após o comando  `echo`  para evitar  _divisão de campos_  e  _expansão de nome de caminho_:

    $ lizard="   genus   |   uromastyx"
    $ echo $lizard
    genus | uromastyx
    $ echo "$lizard"
       genus   |   uromastyx

Se a referência da variável contiver um ponto de exclamação no final, este deve ser o último caractere da string (caso contrário, o Bash pensará que estamos nos referindo a um evento de  `history`):

    $ distro=zorin.?/!os
    -bash: !os: event not found
    $ distro=zorin.?/!
    $ echo $distro
    zorin.?/!

Todas as barras invertidas devem ser escapadas com outra barra invertida. Aliás, se uma barra invertida for o último caractere na string e não o escaparmos, o Bash interpretará que queremos uma quebra de linha e criará uma nova linha:

    $ distro=zorinos\
    >
    $ distro=zorinos\\
    $ echo $distro
    zorinos\

- `env -i bash`: inicia um bash removendo a maioria das variáveis (além de funções e aliases)

    $ env -i bash

Agora, a maioria das nossas variáveis de ambiente se foi:

    $ echo $USER
    $

Restam apenas algumas:

    $ env
    LS_COLORS=
    PWD=/home/user2
    SHLVL=1
    _=/usr/bin/printenv

`PS1`

Essa variável armazena o valor do prompt do Bash. No trecho de código a seguir (igualmente de  `/etc/profile`), a declaração  `if`  testa a identidade do usuário e lhe atribui um prompt bastante personalizado (  `#`  para  `root`  ou  `$`  para usuários regulares):

    if [ "`id -u`" -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi

>[!NOTE]
>
>O  `id`  de  `root`  é  `0`. Entre como  `root`  e teste você mesmo com  `id -u`.

Eis algumas outras variáveis de prompt:
- `PS2`: normalmente definido como  `>`  e usado como prompt de continuação para comandos longos de muitas linhas.
- `PS3`: usado como prompt para o comando  `select`.
- `PS4`: normalmente definido como  `+`  e usado para depuração.
- `SHELL`: esta variável armazena o caminho absoluto do shell atual:

    $ echo $SHELL
    /bin/bash

- `USER`: armazena o nome do usuário atual:

    $ echo $USER
    carol

- `echo $DISPLAY` retorna `reptilium:0:2`, que quer dizer: a máquina **reptilium** tem um servidor X rodando e estamos usando a **segunda** tela do sistema

### 105.2 Editar e escrever scripts simples

Ao criar um `script.sh` (script = sequencia de comandos) comum, como por exemplo:

    clear
    echo "===== Primeiro Script======"
    echo ""
    uptime
    free -m
    echo ""
    echo "Fim Script"

Podemos executá-lo usando apenas o comando source ou ponto (.)<br>
Quando um script é executado, os comandos nele contidos não são executados diretamente na sessão atual, mas sim por um novo processo do Bash, chamado _sub-shell_. Isso evita que o script sobrescreva as variáveis de ambiente da sessão atual e faça modificações indesejadas nela. Se o objetivo é executar o conteúdo do script na sessão atual do shell, ele deve ser executado com `source script.sh` ou `. script.sh` (note que há um espaço entre o ponto e o nome do script).

    $ source script.sh
    $ . script.sh

Isso inclusive faz com que seja executado no bash atual, sem mudar para um processo filho.

Se tentar executar usando `./script.sh` ou o caminho absoluto dele, vai dar erro de permissão, pois o arquivo não tem permissão de execução. Precisaria executar `chmod u+x script`, para dar permissão de execução para o arquivo (nesse caso, permissão para o usuário dono do arquivo).

- `exec script.sh`: executa o script e fecha a sessão atual (nem dá pra ver o resultado, pois já fecha em seguida)
- `bash script.sh`: também executa o script sem o bit de execução.

>[!WARNING]
>
>Um script que executa ações restritas pode ter sua permissão SUID ativada e, portanto, os usuários comuns também podem executar o script com privilégios de root. Nesse caso, é muito importante garantir que nenhum usuário além do root tenha permissão para escrever no arquivo. Caso contrário, um usuário comum poderá modificar o arquivo para realizar operações arbitrárias e potencialmente prejudiciais.

Caso queira direcionar algum outro interpretador, usa-se o she-bang, que no caso é indicar no começo do arquivo: `#!/bin/bash`

>[!TIP]
>
>O Bash chama qualquer comando indicado após o `#!` como interpretador do arquivo de script. Pode ser útil, por exemplo, empregar o shebang para outras linguagens de script, como _Python_ (`#!/usr/bin/python`), _Perl_ (`#!/usr/bin/perl`) ou _awk_ (`#!/usr/bin/awk`).

#### Parâmetro em shell script

- `$*`: imprime todos os argumentos passados para o script.
- `$@`: todos os argumentos passados para o script. Se usado com aspas duplas, como em  `"$@"`, todos os argumentos serão colocados entre aspas duplas.
- `$0`: imprime o nome do arquivo que está sendo executado
- `$#`: imprime a quantidade de parâmetros utilizados
- `$1`, `$2`, etc: imprime os parâmetros sequencialmente conforme entrada
- `$!`: PID do último programa executado.
- `$$`: PID do shell atual.
- `$?`: código de status de saída numérico do último comando concluído. Para processos POSIX padrão, um valor numérico de  `0`  indica que o último comando foi executado com sucesso, o que também se aplica a scripts do shell.
```
echo "O meu script se chama $0"
echo ""
echo "Esse script recebeu $# parâmetros, que são, $1 e $2"
```

#### Receber uma variável com read

É possível, ao usuário digitar, receber um valor de variável durante a execução de um script, usando o read:

```
echo -n "Digite um valor: "
read VAR1
echo "O valor digitado foi $VAR1"
```
- `echo -n`: não quebra linha

echo "Do you want to continue (y/n)?"
read ANSWER

O valor retornado será armazenado na variável  `ANSWER`. Se o nome da variável não for fornecido, o nome da variável  `REPLY`  será usado por padrão. Também é possível usar o comando  `read`  para ler mais de uma variável simultaneamente:

    echo "Type your first name and last name:"
    read NAME SURNAME

Neste caso, cada termo separado por espaços será atribuído às variáveis  `NAME`  e  `SURNAME`  respectivamente. Se o número de termos dados for maior que o número de variáveis, os termos excedentes serão armazenados na última variável. O próprio  `read`  pode exibir a mensagem para o usuário com a opção  `-p`, tornando o comando  `echo`  redundante nesse caso:

    read -p "Type your first name and last name:" NAME SURNAME

#### Declarando variáveis

A declaração de variáveis **NÃO** usa cifrão (`$`), já no uso da variável, **TEM QUE USAR**. Exemplo:<br>

    echo ""
    VAR1=`cat /etc/passwd|wc -l`
    VAR2=$(date +%H)
    echo ""
    echo "O arquivo /etc/passwd possui $VAR1 linhas. A hora atual é $VAR2."

*Podemos colocar execução de comandos utilizando crase (\`) ou com a sitaxe `$()`
**A notação de crase é conhecida como **backtick**

##### Comprimento de uma variável
O comprimento de uma variável, ou seja, a quantidade de caracteres que ela contém, é retornado acrescentando-se um hash  `#`  antes do nome da variável. Esse recurso, no entanto, requer o uso da sintaxe das chaves para indicar a variável:

    $ OS=$(uname -o)
    $ echo $OS
    GNU/Linux
    $ echo ${#OS}
    9

##### Arrays (matriz unidimensionais)

O Bash também apresenta variáveis de matriz (array) unidimensionais, de forma que um conjunto de elementos relacionados pode ser armazenado com um único nome de variável. Cada elemento de uma matriz possui um índice numérico, que deve ser usado para escrever e ler valores no elemento correspondente. Ao contrário das variáveis comuns, as matrizes devem ser declaradas com o comando interno do Bash  `declare`. Por exemplo, para declarar uma variável chamada  `SIZES`  como uma matriz:

    $ declare -a SIZES

As matrizes também podem ser declaradas implicitamente quando preenchidas a partir de uma lista predefinida de itens, usando a notação de parênteses:

    $ SIZES=( 1048576 1073741824 )
    $ set | grep SIZES
    SIZES=([0]="1048576"   [1]="1073741824")

No exemplo, os dois grandes valores inteiros foram armazenados na matriz  `SIZES`. Os elementos da matriz devem ser referenciados usando chaves e colchetes, caso contrário o Bash não alterará nem exibirá o elemento corretamente. Como os índices da matriz começam em 0, o conteúdo do primeiro elemento está em  `${SIZES[0]}`, o segundo em  `${SIZES[1]}`  e assim por diante:

    $ echo ${SIZES[0]}
    1048576
    $ echo ${SIZES[1]}
    1073741824

Diferente da leitura, a alteração do conteúdo de um elemento da matriz é realizada sem as chaves (por exemplo,  `SIZES[0]=1048576`). Como no caso das variáveis comuns, o comprimento de um elemento em uma matriz é retornado com o caractere hash (por exemplo,  `${#SIZES[0]}`  para o comprimento do primeiro elemento da matriz  `SIZES`). O número total de elementos em uma matriz é retornado se  `@`  ou  `*`  forem usados como o índice:

    $ echo ${#SIZES[@]}
    2
    $ echo ${#SIZES[*]}
    2

As matrizes também podem ser declaradas usando-se, como elementos iniciais, a saída de um comando, por meio da substituição de comando. O exemplo a seguir mostra como criar uma matriz do Bash cujos elementos são os sistemas de arquivos suportados pelo sistema atual:

    $ FS=( $(cut -f 2 < /proc/filesystems) )

O comando  `cut -f 2 < /proc/filesystems`  exibe todos os sistemas de arquivos atualmente suportados pelo kernel em execução (listados na segunda coluna do arquivo  `/proc/filesystems`), de forma que a matriz  `FS`  agora contém um elemento para cada sistema de arquivos suportado. Qualquer conteúdo de texto pode ser usado para inicializar uma matriz, já que, por padrão, quaisquer termos delimitados por caracteres de  _espaço_,  _tabulação_  ou  _nova linha_  **se tornarão um elemento de matriz**.

>[!TIP]
>
>O Bash trata cada caractere do  `$IFS`  (_Input Field Separator_  ou separador de campos) de uma variável de ambiente como um delimitador. Para alterar o delimitador de campo apenas para caracteres de nova linha, por exemplo, a variável IFS deve ser redefinida com o comando  `IFS=$'\n'`.

#### Instruções condicionais (if e case)

Vejamos um exemplo:

    if [ -f /etc/bash.bashrc ]; then
	    .	/etc/bash.bashrc
	fi
ou

    if test -f /etc/bash.bashrc ; then
	    .	/etc/bash.bashrc
	fi
Ambas as instruções produzem o mesmo efeito. Para que a instrução aninhada no `if` execute, ela deve ser **verdadeira**, no caso o que estiver entre os colchetes, ou após a instrução `test`. <br>Nesse exemplo é testado se o arquivo `/etc/bash.bashrc` existe e é um arquivo regular.

- `-f`: testa se arquivo existe e é um arquivo regular;
- `-e`: testa apenas se arquivo existe;
- `-s`: verifica se o tamanho do arquivo é maior que 0 (zero)
- `-z`: verifica se o tamanho da string é zero (usado com variáveis)
- `-n`: verifica se o tamanho da string é diferente de zero (nonzero)

Vejamos outro exemplo

    if [ "`id -u`" -eq 0]; then
	    PS1='# '
	else
		PS1='$ '
	fi

Nesse caso verificar, por meio do comando `id -u`, se o retorno é igual a 0 (zero), caso seja, retorna `#`, senão `$`. No caso testa se o usuário é root. Lembrando que id 0 é do root. Lembrando também que podemos executar comandos com a crase e por meio do cifrão abrindo e fechando parênteses `$()`

O comando  `test`  avalia as expressões usando duas sintaxes diferentes: as expressões de teste podem ser dadas como um argumento para o comando  `test`  ou podem ser postas entre colchetes, caso em que o comando  `test`  é dado implicitamente. Assim, o teste para avaliar se  `/etc`  é um diretório válido pode ser escrito como  `test -d /etc`  ou como  `[ -d /etc]`:

    $ test -d /etc
    $ echo $?
    0
    $ [ -d /etc ]
    $ echo $?
    0

O comando `test` pode ser executado no terminal diretamente. Vejamos alguns exemplos:

- `test LPI1 = LPI1`: precisamo ver no **return code**. Basta executar `echo $?` (**0** é igual sucesso, **1** ou outro número informa que não é verdadeiro)
- `test LPI1 = LPI2`: return code será **1**
- `test -f /etc/profile`: testa se o arquivo `/etc/profile` existe. (**0** = existe, **1** = não existe)
- `test 10 -gt 20`: se 10 é maior que (**greater than**) 20 (retorna **1**, pois 10 não é maior que 20)

Supõe que a variável $VAR guarde um caminho para um arquivo ou diretório. Podemos ter as seguintes opções:

- `-a "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos e é um arquivo.
- `-b "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de bloco especial.
- `-c "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de caractere especial.
- `-d "$VAR"`: avalia se o caminho em  `VAR`  é um diretório.
- `-e "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos.
- `-f "$VAR"`: avalia se o caminho em  `VAR`  existe e é um arquivo regular.
- `-g "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SGID.
- `-h "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico.
- `-L "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico (como  `-h`).
- `-k "$VAR"`: avalia se o caminho em  `VAR`  tem a permissão  _sticky bit_.
- `-p "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo  _pipe_.
- `-r "$VAR"`: avalia se o caminho em  `VAR`  é legível pelo usuário atual.
- `-s "$VAR"`: avalia se o caminho em  `VAR`  existe e não está vazio.
- `-S "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de socket.
- `-t "$VAR"`: avalia se o caminho em  `VAR`  está aberto em um terminal.
- `-u "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SUID.
- `-w "$VAR"`: avalia se o caminho em  `VAR`  é gravável pelo usuário atual.
- `-x "$VAR"`: avalia se o caminho em  `VAR`  é executável pelo usuário atual.
- `-O "$VAR"`: avalia se o caminho em  `VAR`  é de propriedade do usuário atual.
- `-G "$VAR"`: avalia se o caminho em  `VAR`  pertence ao grupo efetivo do usuário atual.
- `-N "$VAR"`: avalia se o caminho em  `VAR`  foi modificado desde o último acesso.
- `"$VAR1" -nt "$VAR2"`: avalia se o caminho em  `VAR1`  é mais recente que o caminho em  `VAR2`, de acordo com as datas de modificação respectivas.
- `"$VAR1" -ot "$VAR2"`: avalia se o caminho em  `VAR1`  é mais antigo que  `VAR2`.
- `"$VAR1" -ef "$VAR2"`: esta expressão avalia como True (Verdadeiro) se o caminho em  `VAR1`  é um link físico para  `VAR2`.

##### Também existem testes para variáveis de texto arbitrárias, descritos a seguir:

- `-z "$TXT"`: avalia se a variável  `TXT`  está vazia (tamanho zero).
- `-n "$TXT"`  ou  `test "$TXT"`: avalia se a variável  `TXT`  não está vazia.
- `"$TXT1" = "$TXT2"`  ou  `"$TXT1" == "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  são iguais.
- `"$TXT1" != "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  não são iguais.
- `"$TXT1" < "$TXT2"`: avalia se  `TXT1`  vem antes de  `TXT2`, em ordem alfabética.
- `"$TXT1" > "$TXT2"`: avalia se  `TXT1`  vem depois de  `TXT2`, em ordem alfabética.

- `$NUM1 -lt $NUM2`: avalia se  `NUM1`  é menor que  `NUM2`.
- `$NUM1 -gt $NUM2`: avalia se  `NUM1`  é maior que  `NUM2`.
- `$NUM1 -le $NUM2`: avalia se  `NUM1`  é menor ou igual a  `NUM2`.
- `$NUM1 -ge $NUM2`: avalia se  `NUM1`  é maior ou igual a  `NUM2`.
- `$NUM1 -eq $NUM2`: avalia se  `NUM1`  é igual a  `NUM2`.
- `$NUM1 -ne $NUM2`: avalia se  `NUM1`  não é igual a  `NUM2`.

Todos os testes podem receber os seguintes modificadores:

`! EXPR`

Avalia se a expressão  `EXPR`  é falsa.

`EXPR1 -a EXPR2`

Avalia se tanto  `EXPR1`  quanto  `EXPR2`  são verdadeiras.

`EXPR1 -o EXPR2`

Avalia se ao menos uma das duas expressões é verdadeira.



Outro exemplo interessante:<br>

    if [ "$BASH" ] && [ "$BASH" != "/bin/sh" ]; then
	    #executa rotina
	fi
No caso acima, verifica se a variável `$BASH` está declarada **e** se a variável `$BASH` é diferente de `/bin/sh`, então vai para a rotina.

Vejamos um exemplo que verifica se o diretório `/etc/profile.d` existe:<br>

    if [ -d /etc/profile.d ]; then
	    # executa rotina
	fi

Abaixo, outro exemplo um pouco mais complexo:

    if [ -z "${debian_chroot:-}"] && [ -r /etc/debian_chroot ]; then
	    debian_chroot=$(cat /etc/debian_chroot)
	fi
O `-z` significa se o tamanho (length) da string é zero e o `-r` quer dizer se o arquivo existe e se está com permissão de somente leitura.

##### Case
Exemplo1:<br>

    read VAR1
    case $VAR1 in
	    0)
		    echo "O valor digitado foi 0"
	    ;;
	    1|2|3|4|5)
		    echo "O valor digitado foi entre 1 e 5"
		    sleep 3
	    ;;
	    *)
		    echo "O valor digitado foi maior que 5"
	esac

Exemplo 2:<br>

    #!/bin/bash
    
    DISTRO=$1
    
    echo -n "Distribution $DISTRO uses "
    case "$DISTRO" in
    	debian | ubuntu | mint)
        echo -n "the DEB"
      ;;
    	centos | fedora | opensuse )
        echo -n "the RPM"
      ;;
    	*)
        echo -n "an unknown"
      ;;
    esac
    echo " package format."

Cada lista de padrões e comandos associados deve terminar com  `;;`,  `;&`, ou  `;;&`. O último padrão, um asterisco, será usado se não for encontrada uma correspondência para nenhum outro padrão anterior. A instrução  `esac`  (_case_  de trás pra frente) conclui a construção  `case`. Supondo que o script de amostra anterior se chame  `script.sh`  e seja executado com  `opensuse`  como primeiro argumento, a seguinte saída será gerada:

    $ ./script.sh opensuse
    Distribution opensuse uses the RPM package format.
>[!TIP]
>
>
> O Bash tem uma opção chamada `nocasematch` que ativa a correspondência de padrões sem distinção entre maiúsculas e minúsculas para a construção `case` e outros comandos condicionais. O comando interno `shopt` alterna os valores das configurações que controlam comportamentos opcionais do shell: `shopt -s` habilita (_set_) a opção fornecida e `shopt -u` desabilita (_unset_) a opção fornecida. Portanto, colocar `shopt -s nocasematch` antes da construção case permite encontrar padrões sem diferenciar maiúsculas de minúsculas. As opções modificadas por `shopt` afetarão apenas a sessão atual, de forma que as opções modificadas dentro de scripts em execução em um sub-shell — o que é a maneira padrão de executar um script — não afetarão as opções da sessão pai.

#### Loops

- `seq`: faz uma sequencia de acordo com o número que coloque.<br>
Ex.<br>
    $ seq 5
    1
    2
    3
    4
    5

- `expr`: faz conta aritmética<br>
Ex.<br>

    $ expr 1 + 2
    3

    $ expr 1 - 2
    -1

##### for

	read VAR1
    for i in 1 2 3 4 5
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
	done

>[!TIP]
>
>O comando `expr` pode ser substituído por `$(())`, de forma que o exemplo anterior no laço `for` poderia ser reescrito como `j=$(( $i + $VAR1 ))`

>[!TIP]
>
>É possível escrever potenciação com o operador duplo asterisco (`**`). Ex.<br>

    $ echo $( (5**2 ) )
    25

Exemplo1:<br>

Usando o `seq`:

    read VAR1
    for i in `seq $1` # $1 = parâmetro 1
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
		sleep 1
	done

Exemplo2:<br>

    #!/bin/bash
    
    SEQ=( 1 1 2 3 5 8 13 )
    
    for (( IDX = 0; IDX < ${#SEQ[*]}; IDX++ ))
    do
    	echo -n "${SEQ[$IDX]} is "
    	if [ $(( ${SEQ[$IDX]} % 2 )) -ne 0 ]
    	then
    		echo "odd."
    	else
    		echo "even."
      fi
    done

Este script gera exatamente a mesma saída do exemplo anterior. No entanto, em vez de usar a variável  `NUM`  para armazenar um item por vez, a variável  `IDX`  é empregada para rastrear o índice da matriz atual em ordem crescente, começando de 0 e continuando a adicionar enquanto esse número permanecer abaixo do número de itens na matriz  `SEQ`. O item em si é recuperado de sua posição na matriz com  `${SEQ[$IDX]}`.



##### while

    while [ $VAR1 -le $1 ] #enquanto o teste = Verdadeiro, faça...
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 + 1`
	    sleep 1
	done

##### until

    until [ $VAR1 = 0 ] #até que isso seja verdadeiro, faça...chegando no 0, não executa o looping
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 - 1`
	    sleep 1
	done

#### Execução sequencial de comandos

Ex. `cat teste | wc -l`: executa o primeiro comando e a saída do mesmo serve de entrada para o próximo comando, no caso `wc`.

Ex. `date ; ls -l ; teste2 ; echo Exemplo`: executa todos, mesmo que dê erro

Ex. `ls -ls teste && echo Exemplo`: só executa o segundo comando, se o primeiro der sucesso (caso exista o arquivo teste, senão seria erro, caso ele não exista - ou seja, o status de saída igual a `0`)

Ex. `ls -ls teste || echo Exemplo`: só executa o segundo comando, se o primeiro falhar. Executando o primeiro já encerra a execução.

Ex. `ls -ls teste || echo Exemplo || date`: é sequencial, na hora que chegar em um que executou com sucesso, ele para.

Exemplo de uso de `||`
Imagine uma checagem de um arquivo muito importante, caso ele desaparece, tenha qualquer problema, mudança de permissão, etc, avise o usuário administrador ou root sobre isso:

    ls -l arquivo_importante || mail -s "arquivo não existe mais" root < .
Se executar o comando acima e der sucesso, não faz nada. Mas se der erro, executa o segundo comando, no caso, enviar um email avisando que o arquivo não existe mais.

###$$ Saída do script (echo e printf)

Mesmo quando a finalidade de um script envolve apenas operações orientadas a arquivos, é importante exibir mensagens relacionadas ao progresso na saída padrão, para que o usuário seja informado sobre quaisquer problemas e possa, eventualmente, usar essas mensagens para gerar logs de operação.

O comando interno do Bash  `echo`  é comumente usado para exibir strings de texto simples, mas ele também oferece alguns recursos estendidos. Com a opção  `-e`, o comando  `echo`  é capaz de exibir caracteres especiais usando sequências de escape (uma sequência de barra invertida designando um caractere especial). Por exemplo:

    #!/bin/bash
    
    # Get the operating system's generic name
    OS=$(uname -o)
    
    # Get the amount of free memory in bytes
    FREE=$(( 1000 * `sed -nre '2s/[^[:digit:]]//gp' < /proc/meminfo` ))
    
    echo -e "Operating system:\t$OS"
    echo -e "Unallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora o uso de aspas seja opcional ao se usar  `echo`  sem opções, é necessário adicioná-las ao incluir a opção  `-e`; caso contrário, os caracteres especiais podem não ser lidos corretamente. No script anterior, ambos os comandos  `echo`  usam o caractere de tabulação  `\t`  para alinhar o texto, resultando na seguinte saída:

    Operating system:       GNU/Linux
    Unallocated RAM:        1491 MB

O caractere de nova linha  `\n`  pode ser usado para separar as linhas da saída, de forma que exatamente a mesma saída é obtida combinando-se os dois comandos  `echo`  em um só:

    echo -e "Operating system:\t$OS\nUnallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora adequado para exibir a maioria das mensagens de texto, o comando  `echo`  pode não ser o melhor para padrões de texto mais específicos. O comando interno do Bash  `printf`  oferece mais controle sobre a exibição das variáveis. O comando  `printf`  usa o primeiro argumento como formato da saída, onde os marcadores serão substituídos pelos argumentos seguintes na ordem em que aparecem na linha de comando. Assim, a mensagem do exemplo anterior poderia ser gerada com o seguinte comando  `printf`:

    printf "Operating system:\t%s\nUnallocated RAM:\t%d MB\n" $OS $(( $FREE / 1024**2 ))

O espaço reservado  `%s`  destina-se ao conteúdo de texto (será substituído pela variável  `$OS`) e o espaço reservado  `%d`  destina-se a números inteiros (será substituído pelo número resultante de megabytes livres na RAM). O  `printf`  não acrescenta um caractere de nova linha no final do texto, então o caractere de nova linha  `\n`  deve ser posto ao fim do padrão, se necessário. Todo o padrão deve ser interpretado como um único argumento e, portanto, deve ser posto entre aspas.

>[!TIP]
>
> O formato de substituição do espaço reservado realizada por  `printf`  pode ser personalizado com o mesmo formato usado pela função  `printf`  da linguagem de programação C. A referência completa para a função  `printf`  pode ser encontrada em sua página de manual, acessada com o comando  `man 3 printf`.

Com  `printf`, as variáveis são postas fora do padrão de texto, o que torna possível armazenar o padrão de texto em uma variável separada:

    MSG='Operating system:\t%s\nUnallocated RAM:\t%d MB\n'
    printf "$MSG" $OS $(( $FREE / 1024**2 ))

Este método é particularmente útil para exibir formatos de saída distintos, dependendo dos requisitos do usuário. Fica mais fácil, por exemplo, produzir um script que use um padrão de texto distinto se o usuário precisar de uma lista CSV (valores separados por vírgula) em vez de uma mensagem de saída padrão.
cho $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Comando alias: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente **alias**, é mostrado os alias cadastrados no bash atual.

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada E**TCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

### 106.1 Instalar e configurar o X11

Em cima do X ou X11, que roda os gerenciadores de janela, como gnome, kde, xfce, etc.
Display Manager: aquela tela de login inicial.<br>
O servidor X funciona como um modelo cliente-servidor. Os apps que são executados são clientes do servidor X, que provê as disponibilidades gráficas. Assim como a calculadora, que também é um cliente do servidor X.

Normalmente as configurações ficam em `/etc/X11/xorg.conf` (por padrão já nem vem mais com as distros, tendo em vista que tudo já vem muito bem configurado.). No entanto, para explorar, teria que criar o arquivo `xorg.conf` manualmente.

Trecho LPI: [Tradicionalmente, o principal arquivo de configuração usado para configurar um servidor X é o arquivo `/etc/X11/xorg.conf`. Nas distribuições Linux modernas, o servidor X configura a si mesmo em tempo de execução quando é iniciado e, portanto, nenhum arquivo `xorg.conf` pode existir.]

O arquivo  `xorg.conf`  é dividido em estrofes separadas chamadas  _seções_. Cada seção começa com o termo  `Section`  e, após este termo está o  _nome da seção_, que se refere à configuração de um componente. Cada  `Section`  é encerrada por uma  `EndSection`  correspondente. Um arquivo  `xorg.conf`  típico contém as seguintes seções:

- `InputDevice`: usada para configurar um modelo específico de teclado ou mouse.
- `InputClass`: InputClass Nas distribuições Linux modernas, esta seção é tipicamente encontrada em um arquivo de configuração à parte, localizado em  `/etc/X11/xorg.conf.d/`.  `InputClass`  é usada para configurar uma classe de dispositivos de hardware como teclados e mouses, e não um componente específico de hardware. Veja abaixo um exemplo de arquivo  `/etc/X11/xorg.conf.d/00- keyboard.conf`:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "us"
            Option "XkbModel" "pc105"
    EndSection

A opção de  `XkbLayout`  determina a disposição das teclas de um teclado, como Dvorak, canhoto ou destro, QWERTY e idioma. A opção de  `XkbModel`  é usada para definir o tipo de teclado utilizado. Há uma tabela de modelos, layouts e suas descrições em  `xkeyboard-config(7)`. Os arquivos associados aos layouts de teclado podem ser encontrados em  `/usr/share/X11/xkb`. Um layout de teclado grego politônico em um computador Chromebook apareceria desta maneira:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "gr(polytonic)"
            Option "XkbModel" "chromebook"
    EndSection

Alternativamente, o layout de um teclado pode ser modificado durante uma sessão X em execução com o comando  `setxkbmap`. Eis um exemplo desse comando para configurar o layout grego politônico em um computador Chromebook:

    $ setxkbmap -model chromebook -layout "gr(polytonic)"

Essa configuração só permanecerá ativa enquanto a sessão X estiver em uso. Para que essas alterações se tornem permanentes, modifique o arquivo  `/etc/X11/xorg.conf.d/00-keyboard.conf`  de forma a incluir as configurações necessárias.

>[!NOTE]
>
>O comando  `setxkbmap`  utiliza a X Keyboard Extension (XKB). Este é um exemplo da funcionalidade aditiva do X Window System por meio do uso de extensões.

As distribuições Linux modernas fornecem o comando  `localectl`  através do  `systemd`, que também pode ser usado para modificar um layout de teclado e cria automaticamente o arquivo de configuração  `/etc/X11/xorg.conf.d/00-keyboard.conf`. Novamente, eis um exemplo de configuração de um teclado grego politônico em um Chromebook, desta vez com o comando  `localectl`:

    $ localectl --no-convert set-x11-keymap "gr(polytonic)" chromebook

A opção  `--no-convert`  é usada aqui para impedir que o  `localectl`  modifique o mapa do teclado no console do hospedeiro.

- `Monitor`: a seção  `Monitor`  descreve o monitor físico utilizado e onde está conectado. Eis um exemplo de configuração que mostra um monitor de hardware conectado à segunda porta de vídeo e usado como monitor principal.

    Section "Monitor"
            Identifier  "DP2"
            Option      "Primary" "true"
    EndSection

- `Device`: a seção  `Device`  descreve a placa de vídeo física utilizada. A seção também contém o módulo do kernel usado como driver para a placa de vídeo, junto com sua localização física na placa-mãe.

    Section "Device"
            Identifier  "Device0"
            Driver      "i915"
            BusID       "PCI:0:2:0"
    EndSection

- `Screen`: a seção  `Screen`  reúne as seções  `Monitor`  e  `Device`. Um exemplo de seção  `Screen`  seria semelhante ao seguinte:

    Section "Screen"
            Identifier "Screen0"
            Device     "Device0"
            Monitor    "DP2"
    EndSection

-`ServerLayout`: a seção  `ServerLayout`  agrupa todas as seções como mouse, teclado e telas em uma única interface do X Window System.

    Section "ServerLayout"
    	Identifier   "Layout-1"
    	Screen       "Screen0" 0 0
    	InputDevice  "mouse1"  "CorePointer"
    	InputDevice  "system-keyboard"  "CoreKeyboard"
    EndSection

>[!NOTE]
>
>Nem todas as seções estão presentes em um arquivo de configuração. Nos casos em que uma seção está ausente, os valores padrão são fornecidos pela instância do servidor X em execução.

Os arquivos de configuração específicos ao usuário também residem em `/etc/X11/xorg.conf.d/`. Os arquivos de configuração fornecidos pela distribuição localizam-se em `/usr/share/X11/xorg.conf.d/`. Os arquivos de configuração localizados em `/etc/X11/xorg.conf.d/` são analisados antes do arquivo `/etc/X11/xorg.conf` se ele existir no sistema.

O comando  `xdpyinfo`  é usado em um computador para exibir informações sobre uma instância do servidor X em execução. Veja abaixo um exemplo de saída do comando (determinar quais extensões Xorg estão disponíveis em um sistema):

    $ xdpyinfo
    name of display:    :0
    version number:    11.0
    vendor string:    The X.Org Foundation
    vendor release number:    12004000
    X.Org version: 1.20.4
    maximum request size:  16777212 bytes
    motion buffer size:  256
    bitmap unit, bit order, padding:    32, LSBFirst, 32
    image byte order:    LSBFirst
    number of supported pixmap formats:    7
    supported pixmap formats:
        depth 1, bits_per_pixel 1, scanline_pad 32
        depth 4, bits_per_pixel 8, scanline_pad 32
        depth 8, bits_per_pixel 8, scanline_pad 32
        depth 15, bits_per_pixel 16, scanline_pad 32
        depth 16, bits_per_pixel 16, scanline_pad 32
        depth 24, bits_per_pixel 32, scanline_pad 32
        depth 32, bits_per_pixel 32, scanline_pad 32
    keycode range:    minimum 8, maximum 255
    focus:  None
    **number of extensions:    25
        BIG-REQUESTS
        Composite
        DAMAGE
        DOUBLE-BUFFER
        DRI3
        GLX
        Generic Event Extension
        MIT-SCREEN-SAVER
        MIT-SHM
        Present
        RANDR
        RECORD
        RENDER
        SECURITY
        SHAPE
        SYNC
        X-Resource
        XC-MISC
        XFIXES
        XFree86-VidModeExtension
        XINERAMA
        XInputExtension
        XKEYBOARD
        XTEST
        XVideo
    default screen number:    0
    number of screens:    1
    
    screen #0:
      dimensions:    3840x1080 pixels (1016x286 millimeters)
      resolution:    96x96 dots per inch
      depths (7):    24, 1, 4, 8, 15, 16, 32**
      root window id:    0x39e
      depth of root window:    24 planes
      number of colormaps:    minimum 1, maximum 1
      default colormap:    0x25
      default number of colormap cells:    256
      preallocated pixels:    black 0, white 16777215
      options:    backing-store WHEN MAPPED, save-unders NO
      largest cursor:    3840x1080
      current input event mask:    0xda0033
        KeyPressMask             KeyReleaseMask           EnterWindowMask
        LeaveWindowMask          StructureNotifyMask      SubstructureNotifyMask
        SubstructureRedirectMask PropertyChangeMask       ColormapChangeMask
      number of visuals:    270
    ...

As partes mais relevantes da saída estão em negrito, como o nome da tela (que é idêntico ao conteúdo da variável de ambiente  `DISPLAY`), as informações de versão do servidor X em uso, o número e a listagem das extensões do Xorg em uso e mais informações sobre a tela em si.

Com `ps axu | grep X`, podemos ver o processo `/usr/lib/xorg/Xorg`, que roda no terminal **tty7**. E para gerar o `xorg.conf`, é necessário parar esse processo, logo terá que mudar para o **tty1** (`Ctrl+Alt+F1`), acessar como root e parar o processo **Xorg**.

É necessário mudar para o modo de multiusuários, mas sem interface gráfica, por meio do comando: `# systemctl isolate multi-user.target`. Confirme com `ps axu | grep X`, e verá que o servidor X não está mais rodando.

Agora resta executar o comando `Xorg -configure` (ubuntu 16.04) que irá gerar um arquivo `xorg.conf` em `/root`. Copie esse arquivo para `/etc/x11/xorg.conf`. Rode `startx` para subir o servidor X (mas sem a tela de login), para sair basta fazer um logout. Volte para a interface gráfica padrão executando o comando `systemctl default`. O `xorg.conf` é separado por seções, com identificadores e opções, para mouse, teclado, telas, fontes (que podem ser remotas inclusive), etc.

Vejamos algumas:

- **Module**: carregamento dinâmico de módulos.

Exemplo:  

    _Section "Module"  
    Load "glx"  
    Load "dbe"  
    Load "extmod"  
    EndSection  

_ **Files**: caminhos para alguns arquivos e diretórios utilizados pelo servidor X, como módulos mas principalmente as  **fontes**.

Exemplos:

    _Section "Files"  
    ModulePath "/usr/lib/xorg/modules"  
    FontPath "/usr/share/fonts/X11/misc"  
    FontPath "/usr/share/fonts/X11/Type1"  
    FontPath "/usr/share/fonts/X11/100dpi"  
    FontPath "/usr/share/fonts/X11/75dpi"  
    FontPath "built-ins"  
    FontPath "unix:/7100"  
    FontPath "tcp/fonts.server.com:7100"  
    EndSection_
  
- **InputDevice**: contêm configurações referentes aos dispositivos de entrada, principalmente  **mouse** e  **teclado**.  _Identifier_ e  _Driver_  são parâmetros obrigatórios utilizados para especificar o dispositivo. Além disso parâmetros  _Option_ podem ser adicionados para implementar configurações específicas

Exemplo:

    _Section "InputDevice"  
    Identifier "Keyboard0"  
    Driver "kbd"  
    Option "XkbModel" "pc105"  
    Option "XkbLayout" "us"  
    Option "AutoRepeat" "500 200"  
    EndSection_

      _Section "InputDevice"  
    Identifier "Mouse0"  
    Driver "mouse"  
    Option "Protocol" "auto"  
    Option "Device" "/dev/input/mice"  
    Option "Emulate3Buttons" "no"  
    Option "ZAxisMapping" "4 5"  
    EndSection_

  
- **Device**: seção utilizada principalmente para configuração da  **placa de vídeo**. Semelhante ao InputDevice, tem os parâmetros  _Identifier_ e  _Driver_ como obrigatórios.

Exemplo:

    _Section "Device"  
    Identifier "VideoCard0"  
    Driver "nv"  
    VendorName "nVidia"  
    BoardName "GeForce 6100"  
    VideoRam 131072  
    EndSection_

  
- **Monitor**: configurações específicas do monitor utilizado, como  _HorizSync_ e  _VertRefresh_.

Exemplo:

    _Section "Monitor"  
    Identifier "Monitor0"  
    VendorName "Monitor Vendor"  
    ModelName "Monitor Model"  
    HorizSync 30.0 - 83.0  
    VertRefresh 55.0 - 75.0  
    EndSection_

  
- **Screen**: a seção screen é uma combinação entre o monitor e a placa de vídeo, dizendo ao X quais os modos que ele pode trabalhar. Na sub-seção  **Display**, são informados por exemplo as  **resoluções** suportadas,  **color depth** (bits por pixel), e etc.

    _Section "Screen"  
    Identifier "Screen0"  
    Device "Card0"  
    Monitor "Monitor0"  
    SubSection "Display"  
    Viewport 0 0  
    Depth 1  
    EndSubSection  
    SubSection "Display"  
    Viewport 0 0  
    Depth 4  
    EndSubSection  
    SubSection "Display"  
    Depth 24  
    Modes "1920x1080" "1280x1024" "1024x768"  
    EndSubSection  
    SubSection "Display"  
    Depth 8  
    Modes "1024x768" "800x600" "640x480"  
    EndSubSection  
    EndSection_

  
- **ServerLayout**: esta seção agrega as outras definições da configuração do X, associando principalmente as informações do Screen e InputDevices.

Exemplo:

    _Section "ServerLayout"  
    Identifier "X.org Configured"  
    Screen 0 "Screen0" 0 0  
    InputDevice "Mouse0" "CorePointer"  
    InputDevice "Keyboard0" "CoreKeyboard"  
    EndSection_

#### Uso da variável $DISPLAY

`$Display` mostra, normalmente, a seguinte informação:<br>

    :0.0

    hostname:displaynumber.screennumber

O nome de exibição também informa a um aplicativo gráfico onde ele deve ser renderizado e em qual hospedeiro (no caso de uma conexão X remota).

O  `hostname`  refere-se ao nome do sistema que exibirá o aplicativo. Se o nome de exibição não contiver o nome do hospedeiro, o host local será pressuposto.

O  `displaynumber`  faz referência à coleção de “telas” que estão em uso, seja uma única tela de laptop ou diversas telas em uma estação de trabalho. Cada sessão do servidor X em execução recebe um número de exibição começando em  `0`.

O  `screennumber`  padrão é  `0`. Esse pode ser o caso se apenas uma tela física ou diversas telas físicas estiverem configuradas para funcionar como uma só tela. Quando todas as telas de uma configuração de múltiplos monitores são combinadas em uma única tela lógica, as janelas do aplicativo podem ser movidas livremente entre as telas. Em situações em que cada tela é configurada para funcionar independentemente uma da outra, cada tela abrigará as janelas dos aplicativos que forem abertos dentro delas e as janelas não podem ser movidas de uma tela para outra. A cada tela independente será atribuído seu próprio número. Se houver apenas uma tela lógica em uso, o ponto e o número da tela serão omitidos.

Para iniciar um aplicativo em uma tela específica, atribua o número da tela à variável de ambiente  `DISPLAY`  antes de iniciar o aplicativo: $

    $ DISPLAY=:0.1 firefox &

Esse comando iniciaria o navegador Firefox na tela à direita do diagrama acima. Alguns kits de ferramentas também oferecem opções de linha de comando para instruir um aplicativo a ser executado em uma tela especificada. Procure por  `--screen`  end  `--display`  na página do manual de  `gtk-options(7)`  para ver um exemplo..

O nome de exibição de uma sessão X em execução é armazenado na variável de ambiente  `DISPLAY`:

    $ echo $DISPLAY
    :0

A saída detalha o seguinte:

1.  O servidor X em uso está no sistema local, portanto não há nada impresso à esquerda dos dois pontos.
    
2.  A sessão atual do servidor X é a primeira indicada por  `0`  imediatamente após os dois pontos.
    
3.  Há apenas uma tela lógica em uso, portanto um número de tela não é visível.

Quando não há nada antes dos dois pontos (`:`), considera-se que o valor é `localhost`. Para executar algum app em outro computador, precisa-se mudar o valor da variável de ambiente DISPLAY:<br>

    export DISPLAY="192.168.0.100:0.0"

No host que irá receber a abertura do programa escolhido, é preciso liberá-lo para essa conexão. Por meio do comando `xhost` é possível verificar quem que está autorizado a permitir essa conexão. Para liberar o acesso, digite o comando:<br>

    xhost +192.168.0.99

Digite `xhost` novamente para confirmar que realmente foi liberado. Para liberar completamente o controle de acesso, digite `xhost +` (comando para restringir novamente é: `xhost -`)

Ainda assim não será possível realizar a tarefa, pois o **Display Manager** está bloqueando. No caso, seria o **lightdm**. Se olhar no processo Xorg (`ps axu | grep X`), é possível notar que **lightdm** está rodando com a opção `-nolisten tcp`, e é necessário mudar essa opção (isso para distros baseadas no Debian/Ubuntu).

Vá até `/usr/share/lightdm/lightdm.conf.d`, e edite o arquivo `50-xserver-command.conf`e adicione `xserver-allow-tcp=true` no final do arquivo. Reinicie o `lightdm: systemctl restart lightdm`. Se olhar no processo Xorg **NÃO** terá mais o `-nolisten tcp`

Agora do computador que irá executar o comando para abertura de algum app, execute **xcalc** ou qualquer outro aplicativo para abrir no outro computador.<br>
*O processamento todo está sendo feito pelo PC que abriu a aplicação, no caso o PC de origem. O de destino apenas está gerando a parte gráfica.

#### X11 e o Desktop Environment

Desktop Environment: é um **conjunto de aplicações**, com a finalidade de prover uma interface gráfica amigável ao usuário.<br>
Exemplos: KDE, GNOME, MATE, Cinnamon, LXDE, Xfce

##### Gerenciador de Janelas (Window Manager)

- Controla a criação e fechamento das janelas no ambiente, além do posicionamento e aparência
- São clientes X
- Podem ser parte integrada de um DE ou independentes
- Exemplos: mutter (GNOME), KWin (DKE), Muffin (Cinnamon), Xfwm (XFCE), enligntenment, window maker, Openbox, etc
*É requisito ter um **Window Manager** dentro do **Desktop Environment**

- `update-alternatives --display x-window-manager`: verifica qual é o gerenciador de janelas, ou com o comando:
- `ls -l /etc/alternatives/ | grep window`

##### Interface Gráfica (GUI)

Quando falamos qual interface gráfica você usa? E respondemos KDE, GNOME, etc. Na realidade tecnicamente estamos falando de **Desktop Environment (DE)**.

Já a Interface Gráfica em que o usuário interage, que é o que é usado pelo usuário, é chamado de, por exemplo, do KDE é o KDE Plasma. Do GNOME, é o GNOME Shell, etc

Portanto, a interface gráfica é um dos muitos componentes dentro do DE.

Se estiver usando o GNOME, faça o teste:

- `ps axu | grep gnome`: lista diversas aplicações, como gnome-settings, gnome-software, etc. Essas são aplicações que fazem parte do DE. Uma delas vai ser o `gnome-shell`, que no caso é a interface gráfica.
 
##### Display Managers (DM)

- Interface para realização do login
- Exemplos: GDM (GNOME), LightDM (XFCE), XDM, LXDM
*Geralmente termina em DM (Display Manager)

##### Wayland

É uma alternativa ao X11, criado pelo xorg.

- Protocolo que especifica a comunicação entre o servidor gráfico (Compositor Wayland) e os clientes
- Criado com a intenção de substituir o X, com uma arquitetura diferente visado melhor performance geral
- Atualmente utilizando por padrão no Fedora com GNOME, mas é uma opção em todos os DE
- Projeto em Desenvolvimento

#### Comandos e Arquivos

Em `/usr/share/X11/xorg.conf.d` ficam alguns arquivos de configuração de aplicativos ligados ao hardware, como GPUs, com padrão Section e EndSection

Todos os usuário terão em seu diretório padrão o arquivo `.xsession-errors`, que é um arquivo de log para guardar os erros que ocorrem relacionados à interface gráfica

O acesso remoto que foi feito usando **xhost**, pode ser feito usando o `xauth list`, pegando o magic cookie do computador que quer executar os aplicativos, e adicionando esse magic coockie no computador que irá realizar o acesso, usando o comando:

- `xauth add 192.168.0.100 MIT-MAGIC-COOKIE-1 hash_gerada`

### 106.2 Desktops gráficos

Desktops Environments: GNOME, KDE, MATE, Cinnamon, XFCE, LXDE

- **GNOME**: forte associação ao Projeto GNU, usa biblioteca gráfica **GTK**, Window Manager: mutter.
- **KDE**: pode ser usado em Linux, FreeBSD, Solaris, Windows e Mac OS X, usa biblioteca gráfica **Qt**, Window Manager: KWin
- **MATE**: derivado do GNOME 2, utiliza biblioteca GTK, Window Manager: marco
- **Xfce**: pretende ser rápido e leve, utiliza biblioteca GTK, Window Manager: xfwm

*O **LXDE** é um ambiente de desktop adaptado para baixo consumo de recursos, sendo assim uma boa escolha para instalação em equipamentos mais antigos ou computadores de placa única. Embora não ofereça todas as capabilidades dos ambientes de trabalho mais pesados, o LXDE inclui todos os recursos básicos esperados de uma interface gráfica de usuário moderna

#### Protocolos para acesso remoto a Desktops

- **XDMCP** (X Display Manager Control Protocol)
	- Protocolo nativo do X
	- Implementado pelo Display Manager
	- Não implementa segurança/criptografia
	- Não faz compressão (ocupa bastante banda  )

Para conexão remota utilizando XDMCP, configure o arquivo `/etc/lightdm/lightdm.conf` de maneira que habilite o XDMCPServer:<br>

    [XDMCPServer]
    enable=true

Em outro terminal, execute: `Xorg -terminate -query 192.168.0.100 :1`

- **VNC** (Virtual Networking Computing)
	- utiliza o protocolo RFB (Remote Framebuffer Protocol)
	- Não é totalmente seguro, mas as senhas são criptografadas
	- É possível executar muitos servidores VNC na mesma máquina, mas cada servidor VNC precisa de uma porta TCP exclusiva na interface de rede que aceite solicitações de sessão de entrada. Por convenção, o primeiro servidor VNC deve usar a porta TCP 5900, o segundo deve usar 5901 e assim por diante

- **SPICE** (Simple Protocol for Independent Computing Environment)
	- solução open source completa para acesso remoto
	- solução mais segura

- **RDP** (Remote Desktop Protocol): é usado sobretudo para acessar remotamente a área de trabalho de um sistema operacional _Microsoft Windows_ por meio da porta de rede TCP 3389
	- utilizado para o Microsoft Terminal Service

### 106.3 Acessibilidade

Acessibilidade também é chamada de **AccessX**. Pode ser alterado com a linha de comando: `xkbset`

Locais para acesso: O módulo de configurações de acessibilidade é chamado de _Acesso universal_ na área de trabalho do Gnome, enquanto que no KDE ele está em _Configurações do sistema_, _Personalização_, _Acessibilidade_. Outros ambientes de desktop, como o _Xfce_, também o chamam de _Acessibilidade_ em seu gerenciador de configurações gráficas. Porém, de maneira geral eles oferecem um conjunto reduzido de funcionalidades em comparação com o Gnome e o KDE.

- `sticky keys` (teclas de aderência): é para quem não consegue apertar mais de uma tecla ao mesmo tempo (Ex. shift + A ou S, etc). Se habilitar, basta apertar a tecla do atalho e a outra sequencial (sem necessidade de segurar) - (O KDE também oferece a opção de _Teclas de bloqueio_: se habilitada, as teclas Alt, Ctrl e Shift permanecerão “apertadas” se o usuário as pressionar duas vezes, semelhante ao comportamento da tecla Caps lock) - (o recurso de teclas de aderência será ativado pressionando-se a tecla Shift cinco vezes consecutivas. Para ativar o recurso de teclas lentas, a tecla Shift deve ser mantida pressionada por oito segundos consecutivos)
- `slow keys`(teclas lentas): usado por quem tem problema motor, as teclas lentas exigem que o usuário mantenha a tecla pressionada por um período de tempo especificado antes de ela ser aceita
- `bouce keys`(teclas de repercussão): serve para inibir pressionamentos de tecla não intencionais adicionando um tempo de latência entre eles (se precisar digitar a mesma tecla, precisa aguardar o delay)
- `mouse emulation`: para usar o mouse com o teclado numérico da direita. (Ex. 8=cima, 2=baixo, 6=direita e 4=esquerda, 5=pressionar - clique esquerdo)
- `Preferências do mouse  na janela de configuração do sistema`: se o usuário não conseguir pressionar um ou mais botões do mouse, os cliques podem ser simulados usando diferentes técnicas. Na seção  _Assistência de clique_  do  _Acesso Universal_  do Gnome, a opção  _Clique secundário simulado_  simula um clique com o botão direito se o usuário pressionar e segurar o botão esquerdo do mouse. Com a opção  _Clique flutuante_  habilitada, um evento de clique será disparado quando o usuário segurar o mouse sem movê-lo. No KDE, o aplicativo  _KMouseTool_  fornece esses mesmos recursos para facilitar as ações com o mouse.
- `GOK (Gnome On-board Keyboard)`: teclado virtual On-board
- `KMag`: screen magnifier (ampliador de tela - LUPA)
- `Orca e emacspeak`: leitor de tela, sendo o Orca o principal
- `BRLTTY`: app do Linux para entender e usar o [Braille Display](https://www.google.com/search?q=braille+display&oq=brai&gs_lcrp=EgZjaHJvbWUqBggAEEUYOzIGCAAQRRg7MgYIARBFGDkyBggCEEUYPDIGCAMQRRg8MgYIBBBFGEEyBggFEEUYQTIGCAYQRRhBMgYIBxAuGEDSAQgzODQ5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8)]

#### Reconhecimento de voz

Software capaz de executar comandos através do reconhecimento de voz. Diversos projetos Open Source em desenvolvimento (além dos principais para dispositivos móveis, como Siri, Cortana, etc.
- CMUSphinx
- Simon (KDE)
- Julius

Pergunta interessante na [lpi.org](https://learning.lpi.org/pt/learning-materials/102-500/106/106.3/106.3_01/) citando o Orca<br>
De que forma o aplicativo  _Orca_  pode ajudar usuários com deficiência visual a interagir com o ambiente de trabalho?
O Orca é um leitor de tela que gera uma voz sintetizada que descreve os eventos na tela e lê o texto sob o cursor do mouse. Ele também funciona com dispositivos chamados de  _visores braille atualizáveis_, permitindo ao usuário identificar o texto com padrões táteis.

### 107.1 Administrar contas de usuário, grupos e arquivos de sistema relacionados

Cada usuário tem, obrigatoriamente, seu grupo padrão. E pode estar em vários grupos, ou seja, o mesmo usuário pode estar em vários grupos, facilitando para o administrador de sistemas.

- `/etc/passwd`: principal arquivo que contém todos os usuários do sistema
	- `id` e `gid`: id e id do grupo padrão do usuário (**root SEMPRE será id igual a 0 zero, assim como seu gid**)

Se observar há diversos usuários de sistema, como por exemplo o **daemon**. No Linux, para poder criar um processo ou gerar um arquivo, é preciso ter um usuário, no mínimo. Por isso a necessidade de aplicações terem seu usuário

Normalmente (varia de distro para distro), ids a partir de 1000 são os de usuário, abaixo de 1000 são os de sistema. Lembrando que isso é mais comum, mas pode variar, pois é totalmente configurável.

Por convenção, em `/etc/passwd`, é recomendado sempre utilizar caracteres minúsculos, pois haveria distinção de um usuário chamado rodrigo e Rodrigo, pois é case sensitive. Portanto, é recomendado seguir o padrão.

#### Entendendo cada campo do /etc/passwd
Ordem dos campos:<br>
1. nome do usuário
2. senha do usuário: que armazena em `/etc/shadow`. Antigamente armazenava aqui mesmo
3. id do usuário
4. grupo padrão do usuário: que por padrão usa o mesmo nome do usuário, mas também é configurável e possível alterar
5. descrição: normalmente o nome do usuário, mas isso não é regra.
6. home do usuário: local onde usuário poderá gravar sem restrições, e onde também o usuário cai ao fazer login
7. shell padrão do usuário, que é aberto após login. Quando tem `/bin/false`, significa que **NÃO** é um usuário que irá se logar. Assim como quando tiver `/usr/sbin/nologin`.<br>
*Internamente o Linux sempre trabalha com o `id`.<br>
**Pode-se ter dois usuários com o mesmo id, no entanto o Linux tratará os dois como se fosse um só.<br>
***Pode-se alterar o arquivo `/etc/passwd` diretamente, mas não é recomendado, pois há comandos para isso (e pense que o `/etc/passwd` é ligado com o `/etc/shadow`, e mudar uma coisa em um, geraria inconsistência no outro). Ex. Poderia alterar o id de qualquer usuário para o `id = 0`, e esse usuário se comportaria como root. No entanto não é recomendado.

#### Entendendo cada campo do /etc/shadow

Contém as senhas dos usuário<br>
Ordem dos campos:<br>
1. usuário propriamente dito
2. hash da senha (**quando não** tem senha definida, fica um ponto de exclamação - `!`)

#### Entendendo cada campo do /etc/group

Contém os grupos dos usuário<br>
Ordem dos campos:<br>
1. nome do grupo
2. senha (sim, grupo também pode ter senha, que fica em `/etc/gshadow`)
3. ids do grupo
4. usuários que fazem parte do grupo

#### Entendendo cada campo do /etc/login.defs

Contém as definições de login de cada usuário. No caso, aqui também tem as definições de ids dos usuários (fica próximo da linha 172). Por exemplo:<br>

    # Min/max values for automatic uid selection in useradd
    171 #
    172 UID_MIN                  1000
    173 UID_MAX                 60000

Lembrando que é uma convenção, o Linux, por exemplo, pode ter mais que 60k usuários.

É nesse arquivo também que podemos alterar a variável `DEFAULT_HOME` para `yes` para criar o `/home` dos usuários.

Mais algumas diretivas importantes:<br>

- `UID_MIN`  e  `UID_MAX`: O intervalo de IDs de usuário que podem ser atribuídos a novos usuários comuns.
- `GID_MIN`  e  `GID_MAX`: O intervalo de IDs de grupo que podem ser atribuídos a novos grupos comuns.

- `CREATE_HOME`: Especifica se um diretório pessoal deve ser criado por padrão para novos usuários.
- `USERGROUPS_ENAB`: Especifica se o sistema deve, por padrão, criar um novo grupo para cada nova conta de usuário com o mesmo nome do usuário, e se, ao deletar a conta do usuário, o grupo primário do usuário também deve ser removido, caso não contenha mais membros.

- `MAIL_DIR`: O diretório de spool de email.
- `PASS_MAX_DAYS`: O número máximo de dias que uma senha pode ser usada.
- `PASS_MIN_DAYS`: O número mínimo de dias permitido entre mudanças de senha.
- `PASS_MIN_LEN`: O comprimento mínimo aceitável da senha.
- `PASS_WARN_AGE`: O número de dias de aviso antes que uma senha expire.

>[!TIP]
>
>Ao gerenciar usuários e grupos, sempre verifique este arquivo para visualizar e, eventualmente, alterar o comportamento padrão do sistema, se necessário.

#### 107.1 Gerenciamento de Usuários e Grupos - useradd, userdel, usermod, passwd

Basicamente são:<br>
- `useradd`: adiciona usuário
- `userdel`: exclui usuário
- `usermod`: altera configurações usuário

##### useradd
- `useradd usuário1`: cria o **usuário1**, e em `/etc/passwd`, cria uma linha referente a esse usuário. Algumas distros antigas tinham um bug que não informava o shell a ser utilizado, ficando em branco, e tendo que alterar manualmente (é possível mudar com o comando `chsh`)

Exemplo com várias opções:<br>

    useradd -c "Nome do Usuario" -s /bin/bash -g 1001 -G 1010

- `-c`(`--comment`):  string de texto com o comentário do usuário (geralmente nome completo do usuário
- `-s`(--shell): shell padrão desejado pelo novo usuário
- `-g`(`--gid`): grupo primário (padrão) do novo usuário
- `-G` (`--group`): grupo(s) secundários do novo usuário (outros grupos que o usuário vai pertencer)
- `-e` (`--expiredate`) (YYYY-MM-DD): define um tempo que a conta será desabilitada
- `-f`: cria uma nova conta de usuário definindo o número de dias após a expiração de uma senha durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-k`: cria uma nova conta de usuário copiando os arquivos de esqueleto de um diretório personalizado específico (esta opção só é válida se a opção  `-m`  ou  `--create-home`  for especificada).

Outras opções importantes:
- `-d` (`--home-dir`): definir um `/home` para usuário (não precisa ser o padrão)
- `-m` (`--create-home`): caso no `/etc/user.defs` esteja para não criar `/home` por padrão, pode-se usar essa opção para "forçar" criar o `/home` do usuário (conforme definido no skeleton directory) 
- `-M` (`--no-create-home`): não cria o `/home`
- `-p` (`--password`): define a senha. Mas precisa ser em hash, que pode ser criado por outro comando.
- `-u` (`--uid`): id deseja que o usuário tenha

##### userdel

Supõe que **usuario1** tenha entrada referente a ele em `/etc/passwd`, `/etc/shadow`, `/etc/group` e ele possua um diretório em `/home`, sendo `/home/usuario1`. Se executar:<br>

    userdel usuario1

Será apagado as entradas nos três arquivos, mas **não apagará** a pasta `/home/usuario1`. Para apagar, tem que usar a opção `-r`:
- `-r` (`--remove`): remove o /home do usuário

##### usermod

Basicamente muda o que poderia ser definido com o `useradd`. Supõe que usuario1 não tem comentário, podemos adicionar um comentário com o comando:<br>

    usermod -c "Nome usuario 1" usuario1

Mudar o shell do usuário1:<br>

    usermod -s /sbin/ksh usuario1

`usermod -g suporte usuario1`: muda para **suporte** o grupo padrão do **usuario1** (originalmente, quando criado, o grupo padrão (`-g`) do **usuario1** era **usuario1**. Confirme com um `cat /etc/passwd` para ver o id do grupo do **usuario1**.

Repare na similaridade dos dois comandos a seguir:<br>


`usermod -G devops usuario1`: define o grupo **devops** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **devosp**.

`usermod -G qateams usuario1`: define o grupo **qateams** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **qateams**. NO ENTANTO, o usuario1 não faz mais parte do grupo suporte (imagine que o limite de grupos secundários seja 1 grupo por vez), mas podemos podemos manter o grupo secundário com o argumento `-a`, que no caso vai adicionando os grupos. Ficando o comando:<br>

    usermod -G -a qateams usuario1

ou

    usermod -aG qateams usuario1
- `-a` ou `--append`

- `-l` ou `--login`: altera o nome de login da conta de usuário especificada.
- `-L`ou `--lock`:  bloqueia a conta de usuário especificada. Um ponto de exclamação é posto na frente da senha criptografada dentro do arquivo  `/etc/shadow`, desabilitando assim o acesso com senha para esse usuário. (Note: if you wish to lock the account (not only access with a password), you should also set the EXPIRE_DATE to 1).
- `-U`ou `--unlock`: desbloqueia a conta de usuário especificada. Remove o ponto de exclamação na frente da senha criptografada no arquivo  `/etc/shadow`.

>[!TIP]
>
>Lembre que, ao alterar o nome de login de uma conta de usuário, você provavelmente deve renomear o diretório pessoal desse usuário e outros itens relacionados a ele, como arquivos de spool de email. Lembre também que, ao alterar o UID de uma conta de usuário, provavelmente será preciso corrigir a propriedade dos arquivos e diretórios que estejam fora do diretório inicial do usuário (o ID do usuário é alterado automaticamente na caixa de email do usuário e em todos os arquivos pertencentes ao usuário e localizados no diretório inicial do usuário).

##### passwd

Usado para alterar/criar senha para usuários (precisa ser root)

    passwd usuario1 #troca a senha do usuario1
    passwd #troca a senha do usuario root

Lembre-se que ao criar um usuário, no campo referente à senha lá no arquivo `/etc/shadow`, vai ficar com um ponto de exclamação (`!`), indicando que não foi definido uma senha. Após criar uma senha com o comando `passwd`, uma hash entrará no lugar do ponto de exclamação.

    su usuario1 #troca para o usuario1

Mais algumas opções para o uso de `passwd`:<br>

- `-d`: apaga a senha de uma conta de usuário (desabilitando o usuário).
- `-e`:  força a conta de usuário a alterar a senha.
- `-i`:  define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-l`: bloqueia a conta de usuário (a senha criptografada é prefixada com um ponto de exclamação no arquivo  `/etc/shadow`).
- `-n`: define o tempo de vida mínimo da senha.
- `-S`: exibe informações sobre o status da senha de uma conta de usuário específica.
- `-u`: desbloqueia a conta do usuário (o ponto de exclamação é removido do campo de senha no arquivo  `/etc/shadow`).
- `-x`: define o tempo de vida máximo da senha.
- `-w`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>Os grupos também podem ter uma senha, que pode ser definida usando o comando  `gpasswd`. Os usuários que não são membros de um grupo mas conhecem a senha podem ingressar nele temporariamente usando o comando  `newgrp`.  `gpasswd`  também é usado para adicionar e remover usuários de um grupo e para definir a lista de administradores e membros comuns do grupo.

> [!IMPORTANT] 
>
>Há o comando `adduser`, que na realidade é um script que vai interagindo para criação do usuário. A nível de LPI, focar no `useradd`.

#### 107.1 Gerenciamento de Usuários e Grupos - groupadd, groupdel, groupmod

- `groupadd`: adiciona grupo
- `groupdel`: exclui grupo
- `groupmod`: altera configurações do grupo

##### groupadd

- `groupadd suporte`: cria o grupo **suporte**
- `groupadd -g 2000 dev`: cria o grupo **dev** com id 2000

##### groupdel

- `groupdel suporte`: exclui o grupo suporte

##### groupmod

É possível mudar o id e o nome do grupo. No exemplo abaixo está mudando o nome do grupo de **suporte** para **devops**:

- `groupmod -n devops suporte`(`-n` ou `--new-name`): altera o nome do grupo de suporte para devops
- `groupmod -g 2001 suporte`(`-g` ou `--gid`): altera o id do grupo para 2001

*Não é possível excluir um grupo caso se trate do grupo principal de uma conta de usuário. Portanto, é preciso remover o usuário antes de remover o grupo. Quanto aos usuários, se você excluir um grupo, os arquivos pertencentes a esse grupo permanecerão em seu sistema de arquivos e não serão excluídos ou atribuídos a outro grupo.

##### newgrp

Comando faz com que o usuário atual assuma determinado grupo durante a sessão de login.

- `newgrp suporte`: supõe que está logado com **usuario1**, e que esse usuário também faça parte do grupo **suporte**, além de seu próprio (grupo **usuario1**). Ao executar o comando no começo da frase, ele assume o grupo **suporte** como padrão, e arquivos criados serão do grupo **suporte**.

##### senhas nos grupos

Seria uma situação que o usuário não faz parte de um grupo, se tentar, por exemplo, com o comando: `newgrp devops`, e o usuário não fizer parte do grupo, vai pedir uma senha, e somente será admitido ao grupo se souber a senha.

Primeiramente é necessário criar uma senha para o grupo, com o comando:<br>

    gpasswd nome_grupo

Lembrando que se pode observar os grupos que têm senha olhando o arquivo `/etc/gshadow`

Para acessar o grupo, basta usar o comando `newgrp nome_grupo`

> [!CAUTION]
> 
>Utilizar senha em grupo não é recomendado, e é pouquíssimo ou quase não utilizado.

#### 107.1 Gerenciamento de Usuários e Grupos - id, groups, getent e chage

- `id`: imprime o id do usuário e o id dos grupos pertencentes a esse usuário (usuário atual). Ou pode usar colocando o usuário como parâmetro: `id usuario1`

Sequencialmente seria: 
- **id do usuário**; 
- **id do grupo padrão do usuário**;
- **grupos secundários que esse usuário pertence**.

- `groups`: mesmo conceito que no comando `id`, que irá listar os grupos do usuário logado. Podendo também especificar um usuário. Ex. `groups usuario1`<br>
Ex.<br>

```
    $ groups rodrigo
    rodrigo adm cdrom sudo dip plugdev users lpadmin sambashare
```
`getent`: pega informações de grupos/usuários (esse comando exibe entradas de bancos de dados suportados pelas bibliotecas _Name Service Switch_ (NSS) e requer o nome do banco de dados e uma chave de pesquisa)

- `getent passwd rodrigo`: pega informação do usuário rodrigo em `/etc/passwd` (como se fosse um `cat /etc/passwd | grep rodrigo`)
- `getent group suporte`: pega informações do usuário suporte no `/etc/group`

>[!NOTE]
>
>Lembre-se de que o `getent` só pode acessar os bancos de dados configurados no arquivo `/etc/nsswitch.conf`.

##### chage (change age - alterar idade)

`chage`: mostra as propriedades do usuário: quando a senha vai expirar ou ficar ativa/inativo, número máximo entre dias para alterar senha, última vez que usuário mudou a senha, etc
- `chage -l rodrigo`: mostra propriedades do usuário rodrigo (apenas **root** pode ver as propriedades de todos os usuários, os demais somente suas próprias informações)
- `chage -M 60 rodrigo`: força que o usuário troque de senha a cada 60 dias. Execute `chage -l rodrigo` para saber se aplicou mesmo.
- `chage -d "2024-11-13" rodrigo`: (ou `--lastday`): muda a data que da última vez que o usuário mudou a senha. (isso implica se, por exemplo, foi configurado para trocar a senha a cada x dias. Se for 10 dias, e voltar mais de 10 dias da última troca, vai ter que cadastrar uma nova senha, pois a senha é considerada expirada).
- - `chage -E "2024-12-12" rodrigo`: (ou `--expiredate`): define uma data para a conta expirar. Se expirar, ao logar, vai informar que a conta foi expirada, que é preciso falar com o administrador do sistema
- `chage -E -1 rodrigo`: volta a conta ao normal, em referências ao comando anterior.
- `chage -d0 rodrigo`: força o usuário a trocar senha no próximo login (**root enforced**)
- `-I`: define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-W`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>A sequencias mostrada no comando `chage`, é a mesma dentro do arquivo `/etc/shadow`. Inclusive a última coluna, é o número de dias, desde 1970. (Nos sistemas mais novos não foi percebido essa informação).

##### Exercícios interessantes no site lpi.org

Comandos aleatórios:<br>
|   |   |
|---|---|
| `usermod -L` | Bloquear a conta de usuário |
| `passwd -u` | Desbloquear a conta de usuário |
| `chage -E` | Definir a data de expiração da conta de usuário |
| `groupdel` | Excluir o grupo  |
| `useradd -s` |Criar uma nova conta de usuário com um shell de login específico |
| `groupadd -g` | Criar um novo grupo com um GID específico |
| `userdel -r` | Remover a conta de usuário e todos os arquivos em seu diretório inicial, o próprio diretório inicial e o spool de email do usuário |
| `usermod -l` | Alterar o nome de login da conta de usuário |
| `groupmod -n` | Alterar o nome do grupo |
| `useradd -m` | Criar uma nova conta de usuário e seu diretório inicial  |

Comandos correspondentes:<br>

|   |   |
|---|---|
| `passwd -n` | `chage -m` |
| `passwd -x` | `chage -M` |
| `passwd -w` | `chage -W` |
| `passwd -i` | `chage -I` |
| `passwd -S` | `chage -l` |

No Linux, podemos usar o comando `passwd -n` (ou `chage -m`) para definir o número mínimo de dias entre as mudanças de senha, o comando `passwd -x` (ou `chage -M`) para definir o número máximo de dias durante os quais uma senha é válida, o comando `passwd -w` (ou `chage -W`) para definir o número de dias de aviso antes que a senha expire, o comando `passwd -i` (ou `chage -I`) para definir o número de dias de inatividade durante os quais o usuário deve alterar a senha e o comando `passwd -S` (ou `chage -l`) para exibir informações breves sobre a senha da conta de usuário.

Comando para bloquear e desbloquear usuários<br>
`usermod --lock` e `passwd -l`. 
Já para desbloqueá-la, os comandos seriam `usermod -U`, `usermod --unlock` e `passwd -u`.

***O comando `usermod` não inclui a opção de remover apenas um grupo; portanto, você precisa especificar todos os grupos secundários aos quais o usuário pertence.

    # usermod -G administrators,web-designers kevin

Questão 6:<br>
Usando o comando  `chage`, primeiro verifique a data de expiração da conta de usuário  `kevin`  e depois altere-a para 31 de dezembro de 2022. Que outro comando pode ser usado para alterar a data de expiração de uma conta de usuário?

    # chage -l kevin | grep "Account expires"
    Account expires		: never
    # chage -E 2022-12-31 kevin
    # chage -l kevin | grep "Account expires"
    Account expires		: dec 31, 2022

O comando  `usermod`  com a opção  `-e`  equivale a  `chage -E`.

Questão 7:<br>
Adicione uma nova conta de usuário chamada  `emma`  com UID 1050 e defina  `administrators`  como seu grupo principal e  `developers`  e  `web-designers`  como seus grupos secundários.

    # useradd -u 1050 -g administrators -G developers,web-designers emma
    # id emma
    uid=1050(emma) gid=1028(administrators) groups=1028(administrators),1029(developers),1031(web-designers)

## 107.2 Automatizar e agendar tarefas administrativas de sistema

#### Cron

É um daemon, um processo que fica rodando, de agendamento do sistema (normalmente do sistema). Verificar se está rodando com `systemctl status cron`

O arquivo `/etc/crontab` é onde ficam as tarefas de agendamento, que é executado pelo usuário **root** (a tabela de tarefas `cron` é comumente chamado de `contrabs`, que contêm os chamdos `cron jobs` - trabalho cron)

>[!NOTE]
>
>No Linux, também existe o recurso `anacron`, adequado para sistemas que podem ser desligados (como computadores de mesa ou laptops). Ele só pode ser usado pelo root. Se a máquina estiver desligada quando os trabalhos de `anacron` tiverem de ser executados, isso ocorrerá na próxima vez em que se ligar a máquina. O `anacron` está fora do escopo da certificação LPIC-1.

Os 5 primeiros campos são delimitados questões do tempo, sendo, sequencialmente: <br>
**minuto da hora (0-59)** | **hora do dia (0-23)** | **dia do mês - dom (1-31)** | **mês do ano -mon (1-12)** | **dia da semana - dow (0-7 com Domingo=0 ou Domingo=7)**

*Para o mês do ano e o dia da semana, podemos usar as três primeiras letras do nome em vez do número correspondente.

- supõe que esteja com o valor 17 no campo **m** (**minute**), significa que vai executar todo minuto 17.
- `*` = qualquer valor. qualquer minuto, qualquer hora, qualquer dia do mês, etc. Outra forma que facilitar a leitura do asterisco é interpretá-lo como "**seja o dia/hora/mes que for** ou **qualquer valor**"
- **dow (day of week):**
	-  `7` e `0` = domingo, logo: 
	- `1`= segunda-feira, 
	- `2`= terça-feira, etc

- `,`: especifica uma lista de valores possíveis
- `-`(hífen): especifica um intervalor de valores possiveis
- `/`: especifica valores escalonados

A primeira entrada no arquivo `/etc/crontab`:

    17 *	* * *	root	cd / && run-parts --report /etc/cron.hourly

Nesse caso, executa em todo minuto 17, em todas as horas, em todos os dias do mês, todo mês, todos os dias da semana, o que estiver dentro de `/etc/cron.hourly`. A execução de todos os arquivos se deve ao programa `run-parts`.

A sintaxe dos crontabs de sistema é semelhante à dos crontabs de usuário, porém ela requer um campo adicional obrigatório que especifica **qual usuário executará o cron job**. Portanto, cada linha em um crontab de sistema contém sete campos separados por um espaço:

-   O minuto da hora (0-59).
-   A hora do dia (0-23).
-   O dia do mês (1-31).
-   O mês do ano (1-12).
-   O dia da semana (0-7 com Domingo=0 ou Domingo=7).
-   O nome da conta de usuário a ser usada ao executar o comando.
-   O comando a executar.
    
Quanto aos crontabs do usuário, podemos especificar mais de um valor nos campos de tempo usando os operadores  `*`,  `,`  ,  `-`  e  `/`. Também é possível indicar o mês do ano e o dia da semana com as três primeiras letras do nome em vez do número correspondente.

- **crontab de sistema**: `/etc/crontab` e `/etc/cron.d`
	- `/etc/cron.hourly` (de hora em hora)
	- `/etc/cron.daily` (diariamente)
	- `/etc/cron.weekly` (semanalmente)
	- `/etc/cron.monthly` (mensalmente)
- **crontab de usuário**: `/var/spool/cron`

>[!WARNING]
>
>Algumas distribuições usam `/etc/cron.d/hourly`, `/etc/cron.d/daily`, `/etc/cron.d/weekly` e `/etc/cron.d/monthly`. Lembre-se de sempre conferir os diretórios corretos nos quais colocar os scripts que o cron deve executar.

### Especificações de tempo particulares

Ao editar os arquivos crontab, podemos usar atalhos especiais nas primeiras cinco colunas em vez das especificações de tempo:

- `@reboot`: roda a tarefa especificada uma vez após a reinicialização.
- `@hourly`: roda a tarefa especificada uma vez por hora no início da hora.
- `@daily`  (ou  `@midnight`): roda a tarefa especificada uma vez por dia à meia-noite.
- `@weekly`: roda a tarefa especificada uma vez por semana, à meia-noite de domingo.
- `@monthly`: roda a tarefa especificada uma vez por mês, à meia-noite do primeiro dia do mês.
- `@yearly`  (ou  `@annually`): roda a tarefa especificada uma vez por ano, à meia-noite de 1º de janeiro.

**Exemplos**

-   **`@reboot`**
    -   Executa a tarefa apenas uma vez, sempre que o sistema é inicializado.
    -   Exemplo:
        ```
        bash
        
        Copiar código
        
        `@reboot /path/to/script.sh` 
        ```
        
        Uso comum: Iniciar serviços personalizados ou scripts após reiniciar o servidor.
        
-   **`@hourly`**
    -   Executa a tarefa uma vez por hora, no minuto 0.
    -   Equivalente a:
        ```
        `0 * * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@hourly /path/to/script.sh` 
        ```
        
-   **`@daily` (ou `@midnight`)**
    
    -   Executa a tarefa uma vez por dia, à meia-noite.
    -   Equivalente a:
        ```
        `0 0 * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@daily /path/to/script.sh` 
        ```
        
-   **`@weekly`**
    
    -   Executa a tarefa uma vez por semana, no primeiro minuto do domingo.
    -   Equivalente a:
        ```
        `0 0 * * 0` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@weekly /path/to/script.sh` 
        ```
        
-   **`@monthly`**
    
    -   Executa a tarefa uma vez por mês, no primeiro minuto do primeiro dia.
    -   Equivalente a:
        ```
        `0 0 1 * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@monthly /path/to/script.sh` 
        ```
        
-   **`@yearly` (ou `@annually`)**
    
    -   Executa a tarefa uma vez por ano, no primeiro minuto do primeiro dia do ano.
    -   Equivalente a:
        ```
        `0 0 1 1 *` 
        ```
    -   Exemplo:
	   ```
        bash
        
        `@yearly /path/to/script.sh`
	```

#### Variáveis no crontab

Dentro de um arquivo crontab, pode haver atribuições de variáveis definidas antes que as tarefas agendadas sejam declaradas. As variáveis de ambiente comumente definidas são:

- `HOME`: o diretório no qual o  `cron`  invoca os comandos (por padrão, o diretório inicial do usuário).
- `MAILTO`: o nome do usuário ou o endereço para o qual a saída e o erro padrão são enviados (por padrão, o proprietário do crontab). Diversos valores separados por vírgulas também são permitidos, e um valor vazio indica que nenhum email deve ser enviado.
- `PATH`: o caminho no qual os comandos podem ser encontrados.
- `SHELL`: o shell a ser usado (por padrão  `/bin/sh`).

No `crontab`, variáveis como `HOME`, `MAILTO`, `PATH`, e `SHELL` são usadas para definir o ambiente no qual os comandos serão executados. Aqui está uma explicação detalhada e exemplos para cada uma:

---

### 1. **`HOME`**
   - Define o diretório de trabalho padrão para os comandos executados pelo `crontab`.
   - Se não for especificado, o valor padrão geralmente é o diretório home do usuário que criou o crontab.
   - Exemplo:
     ```bash
     HOME=/home/usuario
     @daily /path/to/script.sh
     ```
     Aqui, o script será executado com `/home/usuario` como diretório de trabalho.

---

### 2. **`MAILTO`**
   - Define o endereço de email para o qual serão enviados os logs de saída e erros dos comandos executados.
   - Se definido como vazio (`MAILTO=""`), o email não será enviado.
   - Exemplo:
     ```bash
     MAILTO=admin@exemplo.com
     @hourly /path/to/script.sh
     ```
     Aqui, os logs da execução do script serão enviados para `admin@exemplo.com`.

---

### 3. **`PATH`**
   - Define os diretórios onde o `crontab` buscará os comandos executados.
   - Por padrão, o `PATH` do cron é mais restrito que o de um shell interativo, frequentemente algo como `/usr/bin:/bin`.
   - Exemplo:
     ```bash
     PATH=/usr/local/bin:/usr/bin:/bin
     @daily script.sh
     ```
     Aqui, o cron poderá localizar `script.sh` se ele estiver em qualquer um dos diretórios especificados.

---

### 4. **`SHELL`**
   - Define qual shell será usado para executar os comandos.
   - O valor padrão geralmente é `/bin/sh`.
   - Exemplo:
     ```bash
     SHELL=/bin/bash
     @reboot /path/to/script.sh
     ```
     Aqui, o script será executado usando o Bash em vez do shell padrão.

---

### Exemplo Completo
```bash
SHELL=/bin/bash
HOME=/home/usuario
MAILTO=admin@exemplo.com
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

@hourly /home/usuario/scripts/backup.sh
@daily /home/usuario/scripts/limpeza.sh
```

### O que acontece aqui:
1. O `backup.sh` será executado a cada hora.
2. O `limpeza.sh` será executado diariamente.
3. Os logs dessas tarefas serão enviados para o email `admin@exemplo.com`.
4. Os comandos serão executados no diretório `/home/usuario` usando o Bash.

---

### Dicas Adicionais
- Se seus scripts dependem de variáveis de ambiente específicas (como `JAVA_HOME`), você pode defini-las no início do arquivo `crontab`.
- Teste seus comandos ou scripts manualmente para evitar problemas de execução devido a configurações de ambiente no cron. 

### uso interessante para o dia a dia

    @daily /path/to/script.sh >> /var/log/script.log 2>&1
    
Executa diariamente o script script.sh e joga a saída de sucesso ou de erro no arquivo script.log (2>&1 indica para jogar as duas saídas no arquivo script.log)

Outro exemplo interessante, executar o script  `barfoo.sh`  localizado no diretório  `/root`  todos os dias à 01:30, abra  `/etc/crontab`  com seu editor preferido e adicione a seguinte linha:

    30 01 * * * root /root/barfoo.sh >>/root/output.log 2>>/root/error.log

No exemplo acima, a saída do job é anexada a  `/root/output.log`, enquanto os erros são anexados a  `/root/error.log` (`2>` é a saída padrão para erro, usando `2>>` vai concatenar os valores).

>[!WARNING]
>
>Exceto nos casos em que a saída é redirecionada para um arquivo, como no exemplo acima (ou se a variável `MAILTO` estiver definida como um valor em branco), toda a saída de um trabalho cron será enviada ao usuário via email. Uma prática comum é redirecionar a saída padrão para `/dev/null` (ou para um arquivo, para revisão posterior, se necessário) e não redirecionar o erro padrão. Desta forma, o usuário é notificado imediatamente por email sobre eventuais erros.

### Cron para usuários

Para listar os agendamentos do seu usuário: `contrab -l -u rodrigo`. Se tentar listar agendamentos de outro usuário, se deparará com a mensagem que a opção `-u` deve ser com usuário privilegiado (root ou usuário com privilégio de root).

    must be privileged to use -u

- `crontab -e`: entra no modo de edição do crontab. (primeiro acesso lhe pergunta qual editor que usa). O formato é parecedo com o crontab que foi visto anteriormente, apenas com a exceção que não tem o campo de usuário.

Vejamos um exemplo:<br>

    #m	h	dia	mes	diasemana	comando/script
    15	13	1,10,20,30	* 1-5	/home/rodrigo/Scripts/script.sh >> /tmp/teste-cron.txt

Acima temos:<br>
nos dias 1,10,20,30 às 13h15m, em todo/qualquer mês (`*`), de segunda à sexta-feira (1=segunda, 5=sexta-feira), execute o script em `/home/rodrigo/Scripts/script.sh` e grava a saída do `script.sh` no arquivo `/tmp/teste-cron.txt`<br>
**Observação**: se os dias 1, 10, 20, ou 30 caírem em um sábado ou domingo, o script.sh não vai rodar.

Outro exemplo:

    #m		h	dia		mes	diasemana	comando/script
    */10	*	*		* 	*			/ cd /tmp ; rm -f teste

Nesse caso, a cada 10 minutos o comando será executado. (A `/` significa **a cada**). Se usar `*/5` no dia, seria a cada 5 dias, etc

Mais um exemplo para ilustrar:

    #m		h	dia		mes	diasemana	comando/script
	0		0	1		1	* /usr/bin/fogo-artificio.sh

No dia 1 de Janeiro, de todo ano, às meia noite (hora = 0 e minuto = 0), executa o script `fogos-artificio.sh`

Exemplo com range:<br>

    #m		h		dia		mes	diasemana	comando/script
    20		9-18	*		*	1-5 		/home/usuario/relatorio.sh

Em todo minuto 20, das horas entre 9h e 18h (horário comercial), qualquer dia, qualquer mês, de segunda à sexta-feira, executa o script `relatorio.sh`<br>
Observação: Lembrando que isso é referente ao usuário atual, e os scripts precisam ter permissão de execução.

- `crontab -r`: remove toda configuração do crontab.
- `# crontab -r -u lpi2`: (só root pode) remover crontab de outro usuário
- `crontab -u`: especifica o nome do usuário cujo crontab precisa ser modificado. Esta opção requer privilégios de root e permite que o usuário root edite os arquivos crontab do usuário.

Há possibilidade de criar um arquivo separado contendo as regras da crontab, e importar com o comando: `crontab arquivo_com_contrab`. Confirme com `contrab -l`

Essas modificações, tanto em sistema (`/etc/cron`) como a de usuário, são permanentes, e o(s) arquivo(s) do(s) usuário(s) fica(m) em `/var/spool/cron/crontabs` (precisa ser acesso como **root**). Em algumas distros pode ser que o diretório `crontabs` seja apenas `cron`.

Usuário root pode determinar quem pode e quem não pode utilizar crontab. Isso se baseia nos arquivos:
- /etc/cron.allow ou
- /etc/cron.deny

*Pode ser que esses arquivos não existam, sendo necessário criá-los. A lista de usuários é comum, linha a linha. O `cron.allow` tem prioridade em cima do `cron.deny` (caso tenha os mesmos usuários nas duas listas.

>[!NOTE]
>
>Há uma diferença no comportamento dos arquivos  **/etc/cron.allow**  e  **/etc/cron.deny**  entre sistemas baseados em Debian e RedHat.<br>
No Debian, e distribuições baseadas como o Ubuntu que usamos nesse curso, se ambos arquivos não existem, o uso dos recursos da cron é liberado para todos os usuários.<br>
No entanto, em sistemas baseados em RedHat, como o CentOS, na inexistência dos arquivos, o uso é bloqueado a todos os usuários, exceto para o usuário root.

#### Exercício interessante no lpi.org

Crie um job agendado simples que execute o comando  `date`  todas as sextas-feiras às 13h. Onde você poderia ver o resultado deste trabalho?

    00 13 * * 5 date

A saída é enviada ao usuário; para visualizá-la, use o comando  `mail`(no caso, é possível ver a saída com esse comando, mas precisa ter o pacote **mailutils** instalado (`apt install mailutisl`)

#### Exercício com MAILTO

Como é possível enviar a saída e os erros do seu trabalho agendado para a conta de usuário  `emma`  via email? E como evitar o envio da saída padrão e erros por email?

Para enviar a saída padrão e o erro para  `emma`, definimos a variável de ambiente  `MAILTO`  em nosso arquivo  `crontab`  desta forma:

    MAILTO="emma"

Para dizer ao  `cron`  que nenhum email deve ser enviado, atribuímos um valor vazio à variável de ambiente  `MAILTO`.

    MAILTO=""

### at (agendamento de uma execução)

Tipo de agendamento em determinada hora/momento (executa apenas uma vez)

    at now +2hour
    at> echo "Hora cafe"

Executa o echo `"Hora do café"` daqui duas horas, e poderia ir adicionando comandos. No final use `Ctrl+D` para adicionar essa tarefa (job).<br>
**(Como no caso do `cron`, a saída padrão e o erro são enviados por email)<br>
***Observe que o daemon `atd` precisará estar rodando no sistema para ser possível usar o agendamento de tarefas `at`

>[!NOTE]
>
>No Linux, o comando `batch` é semelhante a `at`, porém os jobs `batch` são executados apenas quando a carga do sistema está baixa o suficiente para permiti-lo.

- `atq` ou `at -l`: mostra os jobs que estão aguardando (vem de `queue`).

>[!NOTE]
>
>Se você executar `atq` como root, ele exibirá os trabalhos na fila para todos os usuários.

```
at 13:20
at> echo "Hora do almoço
```

Executa o echo às `13:20`. Caso já tenha passado esse horário, o at agenda para o dia seguinte. (para especificar quando um job `at` determinado deve ser executado, use o formato `HH:MM`, seguido opcionalmente por **AM** ou **PM** no caso do formato de 12 horas)

Formatos aceitos para passar uma data após a hora:
- `MMDDYY`
- `MM/DD/YY`
- `DD.MM.YY` e
- `YYYY-MM-DD`

- `at midnight`: agenda para meia noite
- `at teatime`: agenda para às 16h ou 4PM (hora do chá)
- `at noon`: agenda para hora do almoço - meio-dia
- `now`: para agora

- `at 02:20pm 05202024`: agenda para dia 20/05/2024 às 14:20

Para **remover** algum job feito pelo at: `atrm 10` ou `at -d 10`: remove o job 10.

>[!NOTE]
>
>O usuário que rodar `atrm` como root pode excluir os jobs de todos os outros usuários.

- `/etc/at.allow`: permite quais usuário usar o `at`
- `/etc/at.deny`: nega quais usuário a usar o `at` (esse já vem criado, preenchido com usuários do sistema, permitindo somente usuários comuns utilizar)

**As opções mais importantes do comando**  `at`  são:

- `-c`: imprime os comandos de um ID de trabalho específico na saída padrão.
- `-d`: exclui trabalhos com base em seu ID de trabalho. É um alias para  `atrm`.
- `-f`: lê o job em um arquivo em vez da entrada padrão.
- `-l`: lista as tarefas pendentes do usuário. Se o usuário for root, todos os trabalhos de todos os usuários serão listados. É um alias para  `atq`.
- `-m`: envia um email para o usuário no final do trabalho, mesmo se não houver saída.
- `-q`: especifica uma fila na forma de uma única letra de  `a`  a  `z`  e de  `A`  a  `Z`  (por padrão,  `a`  para  `at`  e  `b`  para  `batch`). Os jobs nas filas com as letras mais altas são executados com um valor nice maior. Os jobs enviados a uma fila com uma letra maiúscula são tratados como trabalhos em lote (`batch`).
- `-v`: mostra a hora em que o trabalho será executado antes de ler o trabalho.

Leia o arquivo `timespec` na árvore `/usr/share` para saber mais sobre a definição exata das especificações de data e hora.

#### Agendamento de Tarefas - systemd timer

- `systemct list-timers`: lista os agendamentos que já estão no sistema, no caso `UNITs`, com sufixo  (terminam com)`.timer`, ligadas às `ACTIVATES`, com sufixo (terminam com) `.service` (Por padrão, um `timer` ativa um serviço com o mesmo nome, exceto pelo sufixo).
- `systemct list-timers --all`: mostra agendamentos que possam estar inativas
- `systemctl list-units --type=timer`: lista as unidades do tipo `timer`

Para observar uma unit, é possível pode meio do comando:<br>
- `systemct list-timers`

```
$ systemctl status apt-daily-upgrade.timer 
● apt-daily-upgrade.timer - Daily apt upgrade and clean activities
     Loaded: loaded (/usr/lib/systemd/system/apt-daily-upgrade.timer; enabled; preset: enabled)
     Active: active (waiting) since Fri 2024-11-08 16:41:52 -03; 5 days ago
    Trigger: Fri 2024-11-15 06:13:26 -03; 16h left
   Triggers: ● apt-daily-upgrade.service

Nov 08 16:41:52 OptiPlex-3080 systemd[1]: Started apt-daily-upgrade.timer - Daily apt upgrade and clean activities.
```

Na terceira linha, é mostrado onde está configurado o `.timer`, no caso: `/usr/lib/systemd/system/apt-daily-upgrade.timer`(esse arquivo que seria alterado para definir novo agendamento). Sendo em um formato normal de unit, com sua descrição, e demais itens.

O que é interessante é a parte de `[Timer]`, onde tem a opção `onCalendar`, com a seguinte sintaxe:
- `OnCalendar= *-*-* 6:00`: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) às 6 horas.
- `OnCalendar= *-*-* 6..18:00,30 `: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) das 6 até às 18h, no minuto 00 e minuto 30. Se preferir, pode adicionar dois pontos (`:`) e informar os segundos, ou `*` para qualquer segundo.
- `OnCalendar=Mon..Fri *-*-* 6:00`: caso queira colocar de segunda à sexta-feira (entre dois valores para indicar um intervalo contíguo)
- `OnCalendar=Sat,Sun *-*-* 6:00`: caso queira colocar sábado e domingo (padrão para **Debian** e derivados - **RedHat** seria `Mon-Fri`)

- `RandomizedDelaySec=60m`: nessa faixa de 60 minutos, a execução pode fica aleatória dentro desse tempo, para que não tenha várias coisas executando ao mesmo tempo, achando um gap melhor para essa execução.
- `Persistend=true`: grava caso o `.service` seja executado manualmente. E considera essa informação para a próxima execução.

Na Unit do `.service`, é basicamente um `.service` comum, que é descrito o que será executado no `ExecStart`.<br>
Mais detalhes em `man systemd.timer`. Mais detalhes de como especificar a data e hora no calendar, usar: `man systemd.time`

Vejamos o exemplo de `systemd-tmpfiles-clean.timer`:<br:
- executa `systemctl status systemd-tmpfiles-clean.timer` para saber onde está carregado esse arquivo, no caso é em `/usr/lib/systemd/system/systemd-tmpfiles-clean.timer`, tendo como conteúdo:
```
[Unit]
Description=Daily Cleanup of Temporary Directories
Documentation=man:tmpfiles.d(5) man:systemd-tmpfiles(8)
ConditionPathExists=!/etc/initrd-release

[Timer]
OnBootSec=15min
OnUnitActiveSec=1d
```
Em `OnUnitActiveSec`, é informado que se a unidade estiver ativa, para executar o serviço a cada 1 dia. Em `OnBootSec` é nítido que será executado após 15 minutos. Isso é para casos que o sistema não é desligado.

**Outro exemplo interessante listado nas lições da lpi.org**

Por exemplo, para rodar o serviço  `/etc/systemd/system/foobar.service`  às 05:30 da primeira segunda-feira do mês, adicionamos as seguintes linhas no arquivo de unidade  `/etc/systemd/system/foobar.timer`  correspondente:

    [Unit]
    Description=Run the foobar service
    
    [Timer]
    OnCalendar=Mon *-*-1..7 05:30:00
    Persistent=true
    
    [Install]
    WantedBy=timers.target

Depois de criar o novo temporizador, você pode ativá-lo e iniciá-lo executando os seguintes comandos como root:

    # **systemctl enable foobar.timer**
    # **systemctl start foobar.timer**

Podemos alterar a frequência do trabalho agendado modificando o valor  `OnCalendar`  e, em seguida, digitando o comando  `systemctl daemon-reload`.

Finalmente, se você quiser ver a lista de temporizadores ativos ordenados pelo momento em que terminam, use o comando  `systemctl list-timers`. A opção  `--all`  exibe também as unidades de temporizador inativas.

>[!NOTE]
>
>Lembre-se de que os temporizadores são registrados no diário (journal) do systemd e você pode rever os registros das diferentes unidades usando o comando  `journalctl`. Além disso, se estiver trabalhando como um usuário comum, será preciso usar a opção  `--user`  dos comandos  `systemctl`  e  `journalctl`.

##### Criando um agendamento

1. criar um **serviço**, dentro de `/etc/systemd/system`:
	1.1 usar `vim exemplo.servce`
```
[Unit]
Description=Exemplo systemd-timer

[Service]
Type=oneshot
ExecStart=/bin/sh -c '/bin/date >> /tmp/exemplo-system.txt'
```

2. criar um **timer**, dentro de `/etc/systemd/system`:
	2.1 usar `vim exemplo.timer` (usar o mesmo nome, mudando só o final)
```
[Unit]
Description=Teste de systemd

[Timer]
OnCalendar=*-*-* *:*:10 # toda hora, todo min, no segundo 10

AccuracySec=1us # 1 micro segundo ou 1ms, que é a margem para executar com precisão. Se for muito alto, lembrar que tem prioridade.

Unit=teste.service
```

No `OnCalendar`, pode informar só a hora: `OnCalendar=*:*:10`<br>
No `AccuracySec` lembrar da prioridade, se colocar tempo muito alto e se estiver tendo muita execução, vai utilizar um tempo random dentro do intervalo colocado

Se rodar `systemctl list-timer`, o timer feito não aparece. Portanto é preciso iniciar o timer criado: `systemctl start exemplo.timer`. Executando novamente `systemctl list-timer`, já vai aparecer na lista. É interessante também recarregar as informações do daemon do systemctl, com o comando `systemctl daemon-reload`

Em vez da forma normalizada mais longa mencionada acima, é possível usar algumas expressões especiais que descrevem frequências específicas para a execução de um job:

- `hourly`: roda a tarefa especificada uma vez por hora, no início da hora.
- `daily`: roda a tarefa especificada uma vez por dia à meia-noite.
- `weekly`: roda a tarefa especificada uma vez por semana, na meia-noite de segunda-feira.
- `monthly`: roda a tarefa especificada uma vez por mês, na meia-noite do primeiro dia do mês.
- `yearly`: roda a tarefa especificada uma vez por ano, na meia-noite de 1º de janeiro.

Consulte as páginas de manual para ver a lista completa de especificações de hora e data em  `systemd.timer(5)`.

No **`systemd`**, os **timers** substituem ou complementam o uso do `cron` para agendamento de tarefas, proporcionando maior flexibilidade e integração com o sistema. Aqui estão os equivalentes aos atalhos do `crontab` usando **`systemd.timer`**:

---

### Estrutura de um Timer no `systemd`
Um timer no `systemd` geralmente é composto por dois arquivos:

1. **Arquivo de Serviço (`.service`)**
   - Define o que será executado.
2. **Arquivo de Timer (`.timer`)**
   - Define quando será executado.

---

### Equivalentes no `systemd.timer`
Os timers no `systemd` usam o campo `[Timer]` para configurar os intervalos de execução. Aqui estão os exemplos:

1. **`@reboot` (ao iniciar o sistema)**
   - Use o parâmetro **`OnBootSec`** no arquivo `.timer`.
   - Exemplo:
     ```ini
     [Timer]
     OnBootSec=1min
     ```
     Este timer executará a tarefa 1 minuto após o sistema inicializar.

2. **`@hourly` (uma vez por hora)**
   - Use **`OnCalendar`** com o valor `hourly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=hourly
     ```
     Este timer será acionado no início de cada hora.

3. **`@daily` (uma vez por dia, à meia-noite)**
   - Use **`OnCalendar`** com o valor `daily`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=daily
     ```
     O timer será acionado diariamente à meia-noite.

4. **`@weekly` (uma vez por semana, no domingo)**
   - Use **`OnCalendar`** com o valor `weekly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=weekly
     ```
     O timer será acionado no primeiro minuto de cada domingo.

5. **`@monthly` (uma vez por mês, no primeiro dia)**
   - Use **`OnCalendar`** com o valor `monthly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=monthly
     ```
     O timer será acionado no primeiro minuto do dia 1 de cada mês.

6. **`@yearly` (ou `@annually`)**
   - Use **`OnCalendar`** com o valor `yearly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=yearly
     ```
     O timer será acionado no primeiro minuto do primeiro dia de cada ano.

---

### Exemplo Completo
Aqui está um exemplo completo para criar um serviço e um timer que executam um script diariamente.

### Arquivo de Serviço (`exemplo.service`)
```ini
[Unit]
Description=Executa o script de exemplo

[Service]
ExecStart=/path/to/script.sh
```

### Arquivo de Timer (`exemplo.timer`)
```ini
[Unit]
Description=Executa o script de exemplo diariamente

[Timer]
OnCalendar=daily

[Install]
WantedBy=timers.target
```

#### Comandos para Ativar
1. Coloque os arquivos em `/etc/systemd/system/`.
2. Habilite o timer:
   ```bash
   sudo systemctl enable exemplo.timer
   ```
3. Inicie o timer:
   ```bash
   sudo systemctl start exemplo.timer
   ```

---

### Vantagens do `systemd.timer`
- Integração nativa com o `systemd` (logs em `journalctl`).
- Opções adicionais, como **`AccuracySec`** (ajustar precisão) e **`Persistent`** (executar tarefas perdidas durante períodos de inatividade).

Isso torna o `systemd` uma alternativa poderosa ao `cron` para tarefas agendadas! 

##### systemd-run (equivalente ao at)

Normalmente ele é usado para criar uma unidade transiente de temporizador para que um comando seja executado em um momento específico sem a necessidade de se criar um arquivo de serviço

Por exemplo, atuando como root, você pode executar o comando  `date`  às 11h30 em 06/10/2019 usando o seguinte:

    # **systemd-run --on-calendar='2019-10-06 11:30' date**

Se quiser executar o script  `foo.sh`, localizado em seu diretório atual, depois de dois minutos, use:

    # **systemd-run --on-active="2m" ./foo.sh**

- `system-run --on-active=60s /bin/touch /tmp/exemplo-run.txt`: roda após **60 segundos** o comando `touch` que criar o arquivo `exemplo-run.txt` em `/tmp`
- `system-run --on-active=60s --time-property=AccuracySec=1ms /bin/touch /tmp/exemplo-run.txt`: faz o mesmo do comando anterior, mas em system-run também tem a questão de prioridade, e se quiser com precisão, precisar incluir o argumento `--time-property`

É possível observar que após rodar o `system-run` acima, será retornado um run, que no caso é algo parecido com isso: `run-sequecia-caracteres.timer`

Se pegar esse `.timer` e olhar no `journalctl`, com a opção `-u` `--unit`, mais o `run` (`journalctl -u run-sequecia-caracteres.timer`), é possível notar que já está rodando (mas o comando ainda não foi executado - lembre-se, foi configurado para 60 segundos).

Se olhar no `systemctl list-timers` o `run-sequecia-caracteres.timer` que foi criado, vai estar listado, mostrando quanto tempo falta para sua hora de executar.

Depois que passar os 60 segundos, ele irá executar, e **não** irá mais aparecer no `systemctl list-timers`. Mostrando que fez 1 execução apenas. É possível ter certeza verificando o .service dele, com o comando `journalctl -u run-sequecia-caracteres.service`

Consulte as páginas de manual para aprender todos os usos possíveis de  `systemd-run`  com  `systemd-run(1)`.

>[!NOTE]
>
>Os temporizadores são registrados no diário do systemd e você pode rever os registros das diferentes unidades usando o comando `journalctl`. Além disso, se estiver trabalhando como um usuário comum, precisará usar a opção `--user` dos comandos `systemctl` e `journalctl`.

## 107.3 Localização e internacionalização

Para o Linux, o horário padrão é o UTC (Tempo Universal Coordenado). O UTC substituiu o GMT (Greenwich Meridian Time) ou Z (Zulu), que se baseava na hora local de Greenwich. Depois disso ele pega e converte para o que foi configurado de acordo com a localização.

- `timedatectl`: (disponível em distribuições que usam o `systemd`) é um date melhorado, mais completo, que descreve a **data/hora** em diferentes formatos (embora o `date` também mostre o deslocamento em relação a UTC.)

Tudo isso fica configurado em `/etc/localtime` (é um arquivo que não tem como ler, nele fica configurado a questão do **timezone**, horário de verão - **daylight saving time**). Lembrando que `/etc/localtime` aponta para `/usr/share/zoneinfo/America/Sao_Paulo` (a depender da sua localização).

    ls -l /etc/localtime 
    lrwxrwxrwx 1 root root 37 Nov  8 16:21 /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo

Vendo em `/usr/share/zoneinfo/Brazil` é possível notar onde `/etc/localtime` está apontando:

    ls -l /usr/share/zoneinfo/Brazil/
    total 0
    lrwxrwxrwx 1 root root 21 Nov  8 16:20 Acre -> ../America/Rio_Branco
    lrwxrwxrwx 1 root root 18 Nov  8 16:20 DeNoronha -> ../America/Noronha
    lrwxrwxrwx 1 root root 20 Nov  8 16:20 East -> ../America/Sao_Paulo
    lrwxrwxrwx 1 root root 17 Nov  8 16:20 West -> ../America/Manaus

Em `/etc/timezone` está contido o fuso horário padrão padrão do sistema: (se der um `cat` nesse arquivo, retorna `America/Sao_Paulo`)

Os nomes genéricos de fusos horários indicados pela diferença em relação a UTC devem incluir  `Etc`  na primeira parte do nome. Assim, para definir o fuso horário padrão como GMT+3, o nome do fuso horário deve ser  `Etc/GMT+3`:

    $ **cat /etc/timezone**
    Etc/GMT+3

- `tzselect`: usado para ajudar a selecionar o **timezone** correto/desejado. (Também é possível especificar o fuso horário com coordenadas geográficas ou com a notação de deslocamento, também conhecida como _formato Posix TZ_)

Para alterar o timezone apenas da sessão atual, pode-se alterar a variável `$TZ`:<br>

    - export TZ=America/Chicago<br>

*Faça um date antes e depois de alterar o timezone para perceber as mudanças:<br>

    $ date
    Mon Nov 18 20:22:49 AM -03 2024
    $ export TZ=America/Los_Angeles
    $ date
    Mon Nov 18 15:23:05 AM PST 2024

*Lembrando que isso apenas está traduzindo o que está internamente no UTC. Para voltar a data no timezone que estava antes, basta executar: `unset TZ`.

Ainda alterando o `TZ`, se criar um arquivo, a data de criação atualiza caso o `TZ` seja alterado. Isso se torna interessante quando há usuário de diferentes timezones, para que possa ajustar de acordo com a localização (ajustar no `.bashrc`, por exemplo - ou até mesmo para todos os usuário, em `/etc/profile`).

>[!NOTE]
>
>Só o território brasileiro abrange quatro fusos horários.

A mudança por meio da variável prevalece a configuração em `/etc/localtime`. Podemos preencher da forma por extenso também:

    TZ=:/usr/share/zoneinfo/America/Sao_Paulo

Para alterar por meio do `/etc/localtime`, basta remover o link atual, e apontar para um novo (esse novo é possível consultar por meio das opções que há em `/usr/share/zoneinfo`)

    $ ls -l /etc/localtime
    /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo
    
    rm -f /etc/localtime
    
    ln -s /usr/share/zoneinfo/Asia/Bangkok /etc/localtime

Confirme as mudanças com os comandos `date` e `timedatectl`. As mudanças são refletidas de imediato.

Uma máquina conectada pode ser acessada de diferentes partes do mundo, de forma que é aconselhável definir o relógio do hardware para UTC (o fuso horário GMT+0) e deixar a escolha do fuso horário para cada caso particular. Os serviços em nuvem, por exemplo, costumam ser configurados para usar UTC, o que pode ajudar a mitigar eventuais inconsistências entre o horário local e o horário dos clientes ou de outros servidores. Por outro lado, os usuários que abrem uma sessão remota no servidor podem querer usar seu fuso horário local. Assim, caberá ao sistema operacional configurar o fuso horário correto de acordo com cada caso.

### Localização e Internacionalização - Idioma, Linguagem e Codificação

- `locale`: lista informações específicas de acordo com locais, países no mundo, tais como: sistema monetário, se usa vírgula ou ponto, formato de datas, etc, assim como o tipo de codificação de caracteres. (tudo isso são variáveis de ambiente - vide `env | grep "^LC"`, perceba que há uma chamada `LC_ALL`, que sobrescreve todas as demais).

É possível configurar pelo `.bashrc` ou `/etc/profile`, definindo diretamente as variáveis por sessão ou para todos os usuários, respectivamente.

Por exemplo, caso esteja utilizando o modelo brasileiro de representação dos números, em uma moeda, e queira mudar para o modelo dos Estados Unidos, use: `export  LC_AL=en_US.UTF-8`. Para remover, `unset LC_ALL`.

Ex. **en_US.UTF-8** ou **pt_BR.UTF-8** (codificação usada na instalação)

- `locale -a` (`--all-locales`): lista os modelos disponíveis para o uso.

### Conversão de codificação

O primeiro mais antigo é o ASCII (_American Standard Code for Information Interchange_), depois foi melhorado para ISO/IEC 8859-1, e UTF-8 é o mais recente/utilizado. Se escrever um arquivo com caracteres especiais no Windows, e abrir no Linux, vai haver divergência (lembrando que para verificar a codificação do arquivo, pode-se utilizar o comando `file nome_arquivo`)

- `iconv -f ISO-8859-1 -t UTF-8 nome_do_arquivo`: (`-f` ou `--from-code` e `-t` ou `--to-encode`) converte o arquivo, que antes estava na decodificação do Windows, para a codificação que o Linux entende. (para casos que um texto no Windows não leia no Linux)
Para listar todas as codificações suportadas pelo comando `iconv`, usamos o comando `iconv -l` ou `iconv --list`. Ao invés de usar o redirecionamento de saída, como no exemplo, a opção `-o converted.txt` ou `--output converted.txt` também faz o serviço.

#### Exercicio sobre iconv

Os caracteres dos arquivos de texto podem não ser exibidos corretamente em um sistema com uma codificação de caracteres diferente da usada na criação do documento de texto. Como o  `iconv`  pode ser usado para converter o arquivo  `old.txt`, codificado em WINDOWS-1252, no arquivo  `new.txt`, que usa a codificação UTF-8?

O comando  `iconv -f WINDOWS-1252 -t UTF-8 -o new.txt old.txt`  realizará a conversão desejada.


>[!TIP]
>
>O comando `localectl`, disponível em sistemas que empregam o _systemd_ como gerenciador de sistema, também pode ser usado para consultar e alterar a localidade do sistema. Por exemplo: `localectl set-locale LANG=en_US.UTF-8`.

Além da variável  `LANG`, outras variáveis de ambiente afetam aspectos específicos da localidade, como o símbolo monetário ou o separador de milhar correto para números:
- `LC_COLLATE`: define a ordem alfabética. Uma de suas finalidades é definir a ordem em que os arquivos e diretórios são listados.
- `LC_CTYPE`: define como o sistema tratará certos conjuntos de caracteres. Ele define, por exemplo, quais caracteres considerar como  _maiúsculas_  ou  _minúsculas_.
- `LC_MESSAGES`: define o idioma para exibir as mensagens de programas (principalmente programas do GNU).
- `LC_MONETARY`: define a unidade monetária e o formato da moeda.
- `LC_NUMERIC`: define o formato numérico para valores não-monetários. Sua finalidade principal é definir os separadores de milhar e decimais.
- `LC_TIME`: define o formato de hora e data.
- `LC_PAPER`: define o tamanho padrão do papel.
- `LC_ALL`: sobrepõe todas as outras variáveis, incluindo  `LANG`.

O comando  `locale`  mostra todas as variáveis definidas na configuração de localidade atual:

    $ **locale**
    LANG=pt_BR.UTF-8
    LC_CTYPE="pt_BR.UTF-8"
    LC_NUMERIC=pt_BR.UTF-8
    LC_TIME=pt_BR.UTF-8
    LC_COLLATE="pt_BR.UTF-8"
    LC_MONETARY=pt_BR.UTF-8
    LC_MESSAGES="pt_BR.UTF-8"
    LC_PAPER=pt_BR.UTF-8
    LC_NAME=pt_BR.UTF-8
    LC_ADDRESS=pt_BR.UTF-8
    LC_TELEPHONE=pt_BR.UTF-8
    LC_MEASUREMENT=pt_BR.UTF-8
    LC_IDENTIFICATION=pt_BR.UTF-8
    LC_ALL=

A única variável indefinida é  `LC_ALL`, que pode ser usada para substituir temporariamente todas as outras configurações locais. O exemplo a seguir mostra como o comando  `date` — sendo executado em um sistema configurado para a localidade  `pt_BR.UTF-8` — modifica sua saída de forma a cumprir a nova variável  `LC_ALL`:

    $ **date**
    seg out 21 10:45:21 -03 2019
    $ **env LC_ALL=en_US.UTF-8 date**
    Mon Oct 21 10:45:21 -03 2019

A modificação da variável `LC_ALL` fez com que ambas as abreviações de dia da semana e nome do mês fossem mostradas em inglês americano (`en_US`). Não é obrigatório, entretanto, definir a mesma localidade para todas as variáveis. É possível, por exemplo, ter a linguagem definida como `pt_BR` e o formato numérico (`LC_NUMERIC`) no padrão americano.

Algumas configurações de localização alteram a forma como os programas lidam com a ordem alfabética e formatos de numeração. Embora os programas convencionais geralmente sejam capazes de escolher corretamente uma localidade comum para essas situações, os scripts podem se comportar de forma inesperada ao tentar ordenar corretamente uma lista de itens em ordem alfabética, por exemplo. Por este motivo, recomenda-se definir a variável de ambiente `LANG` para a localidade comum `C`, como em `LANG=C`, para que o script produza resultados inequívocos, independentemente das definições de localização usadas no sistema onde é executado. A localidade C realiza apenas uma comparação simples de bytes e, portanto, também terá um desempenho melhor do que as outras.

## 108.1 Manutenção da data e hora do sistema

### Manutenção do Horário do Sistema - Relógios e os comandos date e hwclock

**hardware clock**: relógio da BIOS (aquela que usa bateria para armazenar data/hora)

**software clock**: relógio do Linux propriamente dito, depois que o SO sobe

Em linhas gerais, o hardware e software clock não são sincronizados pois são independentes. Isso fica nítido quando o computador está ligado por muito tempo.

- `date`: retorna a hora no sistema
- `date -u`: retorna data/hora UTC (GMT0)
- `date 12251200`: ajusta o relógio para 12 de dezembro às 12:00 (o ano é opcional). Opção com ano seria: `date 122512002024` (precisa ser como root).
- `date --set="11 Nov 2011 11:11:11"`: também redefine o horário. Neste caso, é necessário ter privilégios de root para definir a data. Também podemos optar por alterar a hora ou data independentemente:
```
    # date +%Y%m%d -s "20111125"
```
Aqui, devemos especificar as sequências para que nossa string seja analisada corretamente. Por exemplo,  `%Y`  refere-se ao ano e, portanto, os primeiros quatro dígitos  `2011`  serão interpretados como o ano de 2011. Da mesma forma,  `%T`  é a sequência de hora, como demonstrado aqui ao definirmos a hora (`-s` ou `--set`):
```
# date +%T -s "13:11:00"
```
Depois de alterar a hora do sistema, é recomendável também definir o relógio do hardware para que os relógios do sistema e do hardware estejam sincronizados:
```
# hwclock --systohc
```
Outras opções comumente usadas retornam a hora local em um formato RFC aceito:
- `-I`:  data/hora no formato ISO 8601. Anexar  `date`  (`-Idate`) limita a saída apenas à data. Outros formatos são  `hours`,  `minutes`,  `seconds`  e  `ns`  (para nanossegundos).
- `-R`:  retorna data e hora no formato RFC 5322.
- `--rfc-3339`:  retorna data e hora no formato RFC 3339.

O formato de  `date`  pode ser personalizado pelo usuário com as sequências especificadas na página de manual. Por exemplo, a hora atual pode ser formatada como tempo do Unix da seguinte maneira:

    $ date +%s
    1574014515

Na página de manual de  `date`, podemos ver que  `%s`  se refere ao tempo do Unix.

O tempo do Unix é usado internamente na maioria dos sistemas baseados em Unix. Ele armazena a hora UTC como o número de segundos desde a  _Época_, que foi definida como 1º de janeiro de 1970.

>[!NOTE]
>
>O número de bits necessários para armazenar a hora Unix no momento atual é de 32 bits. No futuro, 32 bits se tornarão insuficientes para conter a hora atual no formato Unix. Isso causará problemas sérios para qualquer sistema Linux de 32 bits. Felizmente, isso não ocorrerá até 19 de janeiro de 2038.

A opção  `--debug`  é muito útil para garantir que uma data possa ser analisada com sucesso. Observe o que acontece ao passarmos uma data válida para o comando:

    $ date --debug --date="Fri, 03 Jan 2020 14:00:17 -0500"
    date: parsed day part: Fri (day ordinal=0 number=5)
    date: parsed date part: (Y-M-D) 2020-01-03
    date: parsed time part: 14:00:17 UTC-05
    date: input timezone: parsed date/time string (-05)
    date: using specified time as starting value: '14:00:17'
    date: warning: day (Fri) ignored when explicit dates are given
    date: starting date/time: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05'
    date: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05' = 1578078017 epoch-seconds
    date: timezone: system default
    date: final: 1578078017.000000000 (epoch-seconds)
    date: final: (Y-M-D) 2020-01-03 19:00:17 (UTC)
    date: final: (Y-M-D) 2020-01-03 14:00:17 (UTC-05)

Essa é uma ferramenta útil para a resolução de problemas em um aplicativo que gera uma data.

- `hwclock` (`apt install util-linux-extra`): mostra o relógio do BIOS

O `hwclock` serve ainda para sincronizar o horário do sistema igual ao do horário do hardware, ou vice-versa.

- `hwclock -w` ou `--systohc` (**hc**=**hardware clock**): pega o horário do sistema e sincroniza com o relógio no BIOS: Sys->Bios
- `hwclock -s` ou `--hctosys`: faz o contrário, pega o horário do BIOS e sincroniza com o relógio do Linux: Bios->Sys

- `hwclock --set --date "12/25/2024 14:00"`: define o horário na BIOS<br>
**Na aula o comando acima retorna erro, formato inválido para a data. Procurando no man , o formato usado é: <br>
```
    sudo hwclock --set --date "YYYY-MM-DD HH:MM:SS"
```
- `hwclock  --verbose`: retorna mais resultados, que podem ser úteis para solucionar problemas. Observe o `Calculated Hardware Clock drift`. Esta saída informa se a hora do sistema e a hora do hardware estão divergindo uma da outra.

>[!NOTE]
>
>Para fins de logs, é utilizado o horário do sistema.

>[!NOTE]
>
>Alguns processos internos (principalmente em distros baseadas em Ubuntu), a hora é atualizada automaticamente.

- `timedatectl`  é um comando que pode ser usado para verificar o status geral de hora e data, incluindo se a hora da rede foi ou não sincronizada (na próxima lição, trataremos do Network Time Protocol).

Por padrão,  `timedatectl`  retorna informações semelhantes a  `date`, mas com a adição da hora RTC (hardware), bem como o status do serviço NTP:

    $ timedatectl
                   Local time: Thu 2019-12-05 11:08:05 EST
               Universal time: Thu 2019-12-05 16:08:05 UTC
                     RTC time: Thu 2019-12-05 16:08:05
                    Time zone: America/Toronto (EST, -0500)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Se o NTP não estiver disponível, recomenda-se usar  `timedatectl`  em vez de  `date`  ou  `hwclock`  para definir a hora:

    # **timedatectl set-time '2011-11-25 14:00:00'**

O processo é semelhante ao de  `date`. O usuário também pode definir a hora independentemente da data com o formato **HH:MM:SS**

### Definindo o fuso horário com timedatectl

`timedatectl`  é a melhor maneira de configurar o fuso horário local nos sistemas Linux baseados em  `systemd`  quando não existe GUI.  `timedatectl`  lista os fusos horários possíveis e, a partir daí, o fuso horário pode ser definido usando um deles como argumento.

Primeiro, listamos os fusos horários possíveis:

    $ **timedatectl list-timezones**
    Africa/Abidjan
    Africa/Accra
    Africa/Algiers
    Africa/Bissau
    Africa/Cairo
    ...

A lista de fusos horários possíveis é longa, por isso o uso do comando  `grep`  é recomendado neste caso.

Em seguida, podemos definir o fuso horário usando um dos elementos da lista retornada:

    $ timedatectl set-timezone Africa/Cairo
    $ timedatectl
                   Local time: Thu 2019-12-05 18:18:10 EET
               Universal time: Thu 2019-12-05 16:18:10 UTC
                     RTC time: Thu 2019-12-05 16:18:10
                    Time zone: Africa/Cairo (EET, +0200)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Lembre-se de que o nome do fuso horário deve ser exato.  `Africa/Cairo`, por exemplo, muda o fuso horário, mas  `cairo`  ou  `africa/cairo`  não.

### Desativando o NTP com timedatectl

Em alguns casos, pode ser necessário desativar o NTP. Podemos fazer isso com  `systemctl`, mas vamos demonstrar o procedimento com  `timedatectl`:

    # timedatectl set-ntp no
    $ timedatectl\
                 Local time: Thu 2019-12-05 18:19:04 EET Universal time: Thu 2019-12-05 16:19:04 UTC
                   RTC time: Thu 2019-12-05 16:19:04
                  Time zone: Africa/Cairo (EET, +0200)
                NTP enabled: no
           NTP synchronized: no
            RTC in local TZ: no
                 DST active: n/a

### Definindo o fuso horário sem timedatectl

A definição do fuso horário é uma etapa padrão ao se instalar o Linux em uma nova máquina. Se houver um processo de instalação gráfico, isso provavelmente será feito sem nenhuma ação adicional do usuário.

O diretório  `/usr/share/zoneinfo`  contém informações sobre os diferentes fusos horários possíveis. No diretório  `zoneinfo`, há subdiretórios com o nome dos continentes, bem como outros links simbólicos. Recomenda-se encontrar o  `zoneinfo`  da sua região começando por seu continente.

Os arquivos  `zoneinfo`  contêm as regras necessárias para calcular a diferença de horário local em relação a UTC e também são importantes se a sua região segue o horário de verão. O conteúdo de  `/etc/localtime`  será lido quando o Linux precisar determinar o fuso horário local. Para definir o fuso horário sem o uso de uma GUI, o usuário deve criar um link simbólico de  `/usr/share/zoneinfo`  para  `/etc/localtime`  informando sua localização. Por exemplo:

    $ **ln -s /usr/share/zoneinfo/Canada/Eastern /etc/localtime**

Depois de definir o fuso horário correto, recomenda-se executar:

    # **hwclock --systohc**

Isso configurará o  _relógio do hardware_  a partir do  _relógio do sistema_  (ou seja, o relógio em tempo real será configurado para a mesma hora que  `date`). Note que este comando é executado com privilégios de root; neste caso, você está logado como root.

`/etc/timezone`  é semelhante a  `/etc/localtime`. É uma representação de dados do fuso horário local e, como tal, pode ser lido usando  `cat`:

$ **cat /etc/timezone**
America/Toronto

Observe que este arquivo não é usado por todas as distribuições Linux.

### Configurando data e hora sem timedatectl

>[!NOTE]
>
>A maioria dos sistemas Linux modernos usa o  `systemd`  para sua configuração e serviços; assim, não é recomendado usar  `date`  ou  `hwclock`  para definir a hora. O  `systemd`  emprega para isso o  `timedatectl`. No entanto, é importante conhecer esses comandos legados no caso de você precisar administrar um sistema mais antigo.

**Exercício interessante Timezone**

Existe um local chamado  `eucla`. De que continente ele faz parte? Use o comando  `grep`  para descobrir.

`timedatectl list-timezones \| grep -i eucla`
ou
`grep -ri eucla /usr/share/zoneinfo`

Defina seu fuso horário atual para  `eucla`.

`timedatectl set-timezone 'Australia/Eucla'`
ou
`ln -s /usr/share/zoneinfo/Australia/Eucla /etc/localtime`

#### Protocolo NTP (Network Time Protocol)

Alguns desses termos aparecem nos comandos que usamos para rastrear o status do NTP em nossas máquinas:

- **Deslocamento (offset)**: Refere-se à diferença absoluta entre a hora do sistema e a hora NTP. Por exemplo, se o relógio do sistema marca 12:00:02 e o horário NTP é 11:59:58, o deslocamento entre os dois relógios é de quatro segundos.
- **Salto (step)**: Se o deslocamento de tempo entre o provedor NTP e um consumidor for maior que 128ms, o NTP executará uma única alteração significativa na hora do sistema, em vez de desacelerar ou acelerar o relógio do sistema. Isso é chamado de  _stepping_.
- **Ajuste gradativo (slew)**: Slew refere-se às alterações feitas na hora do sistema quando o deslocamento entre a hora do sistema e o NTP é menor que 128ms. Se esse for o caso, as alterações serão feitas gradualmente. Isso é conhecido como  _slewing_.
- **Relógio insano**: Se o deslocamento entre a hora do sistema e a hora NTP for maior que 17 minutos, o tempo do sistema é considerado  _insano_  e o daemon NTP não introduzirá nenhuma alteração no relógio do sistema. Será preciso tomar medidas especiais para trazer a hora do sistema até menos de 17 minutos da hora correta.
- **Escorregamento ou deslizamento (drift)**: O escorregamento se refere ao fenômeno em que dois relógios ficam fora de sincronia com o tempo. Essencialmente, se dois relógios são inicialmente sincronizados, mas vão ficando fora de sincronia com o passar do tempo, está ocorrendo um escorregamento do relógio.
- **Variação (jitter)**: A variação refere-se à quantidade de escorregamento desde a última vez em que um relógio foi consultado. Portanto, se a última sincronização com o NTP ocorreu há 17 minutos, e o deslocamento entre o provedor NTP e o consumidor é de 3 milissegundos, então 3 milissegundos é a variação.

Protocolo que usa a porta **123** via UDP (pode ser visto no arquivo `/etc/services`, que lista as portas)

Primeiro é preciso instalar os pacotes: `apt install ntp ntpdate`. Depois de instalador, pode verificar se o daemon do ntp está executando com o comando `ps axu | grep ntp`

O arquivo de configuração do NTP é `/etc/ntp.conf`. Dentro desse arquivo têm listado as pools com endereços NTP. Essas pools precedem da palavra reservada `pool` ou `server`.

- `ntpq -p`ou`--peers`: (é um utilitário para monitorar o status do NTP. Uma vez que o daemon NTP foi iniciado e configurado, usamos `ntpq` para verificar seu status) lista as pools (peers) com diversas estatísticas de cada pool ou server. Com `-n` não resolve os nomes, traz só os IPs. As colunas são:

- `remote`: nome do host do provedor NTP.
- `refid`:  ID de referência do provedor NTP.
- `st`: estrato do provedor.
- `when`: número de segundos desde a última consulta.
- `poll`: número de segundos entre as consultas.
- `reach`: ID de status para indicar se um servidor foi alcançado. As conexões bem-sucedidas aumentam este número em 1.
- `delay`: tempo em ms entre a consulta e a resposta do servidor.
- `offset`: tempo em ms entre a hora do sistema e a hora NTP.
- `jitter`: deslocamento em ms entre a hora do sistema e o NTP na última consulta.

`ntpq`  também inclui um modo interativo, que é acessado quando ele é executado sem opções ou argumentos. A opção  `?`  retorna uma lista de comandos reconhecidos pelo  `ntpq`.



- `ntpdate 3.pt.pool.ntp.org` (`apt install ntpsec-ntpdate -y`): vai até o NTP de Portugal e atualiza o horário (de acordo com NTP de Portugal)<br>
**O comando acima não altera para o horário de Portugal, na realidade vai pegar o horário de lá, e de acordo com as configurações de timezone do sistema, vai ajustar de acordo com o timezone.

- `ntpdate -q 3.pt.pool.ntp.org`: (`-q` ou `--query`): consulta se o servidor está funcionando.

Durante a configuração inicial, a hora do sistema e o NTP podem ser seriamente dessincronizados. Se o  _deslocamento_  entre o sistema e a hora NTP for maior que 17 minutos, o daemon NTP não fará alterações na hora do sistema. Neste caso, será necessária uma intervenção manual.

Primeiramente, se  `ntpd`  estiver rodando, será necessário  _interromper_  o serviço. Use  `systemctl stop ntpd`  para fazer isso.

Em seguida, use  `ntpdate pool.ntp.org`  para realizar uma sincronização inicial única, onde  `pool.ntp.org`  se refere ao endereço IP ou URL de um servidor NTP. Pode ser necessária mais de uma sincronização.

#### chrony e timedatect

- **chrony**: funciona melhor em ambientes instáveis. Precisa instalar: `apt install chrony`. Confirmar com `ps axu | grep chrony` e `systemctl status chrony`.

O arquivo de configuração ficam `/etc/chrony/chrony.conf`, podendo ainda usar igual ao ntp, com a palavra `pool` ou `server` para indicar o servidor a ser consultado

#### chronyc (é o cli do chrony)

- `chrony` é outra forma de implementar o NTP. Ele é instalado por padrão em alguns sistemas Linux, mas está disponível para download em todas as principais distribuições. 
- `chronyd` é o daemon chrony e `chronyc` é a interface de linha de comando
---
- `chronyc tracking`: fornece informações sobre o NTP e a hora do sistema que está configurado (vê um status geral)
Essa saída contém muitas informações, mais do que as que estão disponíveis em outras implementações.

- `Reference ID`: O ID de referência e o nome ao qual o computador está sincronizado no momento.
- `Stratum`: Número de passos até um computador com um relógio de referência anexado.
- `Ref time`: Esta é a hora UTC em que a última medição da fonte de referência foi feita.
- `System time`: Atraso do relógio do sistema do servidor sincronizado.
- `Last offset`: Deslocamento estimado da última atualização do relógio.
- `RMS offset`: Média de longo prazo do valor do deslocamento.
- `Frequency`: Esta é a taxa na qual o relógio do sistema estaria errado se o chronyd não o estivesse corrigindo. É fornecida em ppm (partes por milhão).
- `Residual freq`: Frequência residual indicando a diferença entre as medições da fonte de referência e a frequência atualmente sendo usada.
- `Skew`: Limite de erro estimado da frequência.
- `Root delay`: Total de atrasos do caminho de rede até o computador do estrato a partir do qual o computador está sendo sincronizado.
- `Leap status`: Este é o status de intercalação, que pode ter um dos seguintes valores: normal, inserir segundo, excluir segundo ou não sincronizado.
---

- `chronyc sources`: retorna informações sobre os servidores NTP usados para sincronizar a hora
- `chronyc sources -v`:  this command displays information about the current time sources that chronyd is accessing. Mostra se é um server (`^`), se é um peer (`=`) ou se se é o relógio local (`#`). Mostra também se está sincronizado (`*`), se está combinado (`+`) ou se está não está combinado (`-`)
- `chronyc activity`: mostra status das atividades, mostrando se está com status 200 OK, por exemplo<br>
*Se digitar só `chronyc`, entra no modo de cli, e os comandos anteriores podem ser digitados diretamente.
- `chrony ntpdate`: usado para ver informações detalhadas sobre a última atualização válida do NTP


A título de curiosidade, o **systemd** tem uma forma de sincronia por meio do serviço `systemd-timesyncd.service`, que pode conflitar com o ntp. Vide o comando `timedatectl`, que apresenta informações de `network time on` e `NTP synchronized`. Para evitar seria interessante usar o comando: `timedatectl set-ntp false`, assim, vai deixar como **no**, a opção `network time on`

O ntpd usa a porta **123** e o chrony usa a **323**.

NTP Pool recomendado: https://www.ntppool.org/en/

## 108.2 Sistema de Logs - Rsyslog

- **syslog**: derivado dos sistemas unix, bsd, e posteriormente nos sistemas linux.
- **rsyslog**: melhoramento do syslog (mais cobrado na LPI) e (mais veloz para processamento de log, e trouxe melhorias importantes como suporte a RELP - _Reliable Event Logging Protocol_: Protocolo confiável de registro de eventos em log, e estende a funcionalidade do protocolo syslog de maneira a assegurar a entrega de mensagens)
- **syslog-ng**: mesmo padrão do syslog, mas muda a implementação (ng = new generation)
- **systemd-journal**: recurso do systemd, para gerenciar logs (depois do rsyslog, é bem implementado)

>[!NOTE]
>
>Normalmente em `/var/log`. No entanto, alguns serviços cuidam de seus próprios logs (por exemplo, o servidor web Apache HTTPD ou o sistema de impressão CUPS). Da mesma forma, o kernel do Linux usa um buffer de anel na memória para armazenar suas mensagens de log.

O `rsyslog` usa um modelo cliente-servidor. O cliente e o servidor podem existir no mesmo host ou em máquinas diferentes. As mensagens são enviadas e recebidas em um formato específico e podem ser mantidas em servidores `rsyslog` centralizados em redes IP. O daemon do rsyslog —`rsyslogd`— trabalha junto com o `klogd` (que gerencia as mensagens do kernel). Nas próximas seções, discutiremos o `rsyslog` e sua infraestrutura de registro de eventos.

#### Tipos de log

Como os logs são dados  _variáveis_, costumam ser encontrados em  `/var/log`. Grosso modo, podem ser classificados em  _logs do sistema_  e  _logs de serviços ou programas_.

Vamos conhecer alguns logs do sistema e as informações que eles preservam:

- `/var/log/auth.log`: atividades relacionadas aos processos de autenticação: usuários registrados, informações de  `sudo`, cron jobs, tentativas de login malsucedidas etc.
- `/var/log/syslog`: um arquivo centralizado para praticamente todos os logs capturados pelo  `rsyslogd`. Por incluir muitas informações, os logs são distribuídos por outros arquivos de acordo com a configuração fornecida em  `/etc/rsyslog.conf`.
- `/var/log/debug`: informações de depuração dos programas.
- `/var/log/kern.log`: mensagens do kernel.
- `/var/log/messages`: mensagens informativas que não estão relacionadas ao kernel, mas a outros serviços. **É também o destino padrão do log do cliente remoto em uma implementação de servidor de log centralizado**.
- `/var/log/daemon.log`: informações relacionadas aos daemons ou serviços em execução em segundo plano.
- `/var/log/mail.log`: informações relacionadas ao servidor de email, por exemplo o postfix.
- `/var/log/Xorg.0.log`: informações relacionadas à placa de vídeo.
- `/var/run/utmp`  e  `/var/log/wtmp`:  Logins bem-sucedidos.
- `/var/log/btmp`: tentativas de login malsucedidas, por exemplo ataques de força bruta via ssh.
- `/var/log/faillog`: tentativas de autenticação malsucedidas.
- `/var/log/lastlog`: data e hora dos logins recentes do usuário.

Vejamos agora alguns exemplos de logs de serviço:

- `/var/log/cups/`: diretório para logs do  _Common Unix Printing System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `page_log`  e  `access_log`.
- `/var/log/apache2/`  or  `/var/log/httpd`: diretório para logs do  _Apache Web Server_. Geralmente inclui os seguintes arquivos de log padrão:  `access.log`,  `error_log`  e  `other_vhosts_access.log`.
- `/var/log/mysql`: diretório para logs do  _MySQL Relational Database Management System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `mysql.log`  e  `mysql-slow.log`.
- `/var/log/samba/`: diretório para logs do protocolo  _Session Message Block_  (SMB). Geralmente inclui os seguintes arquivos de log padrão:  `log.`,  `log.nmbd`  and  `log.smbd`.

>[!NOTE]
>
>O nome e o conteúdo exatos dos arquivos de log podem variar de acordo com as distribuições Linux. Existem também logs específicos para distribuições específicas como  `/var/log/dpkg.log`  (contendo informações relacionadas aos pacotes  `dpkg`) no Debian GNU/Linux e seus derivados.

- `/etc/rsyslog.conf`: arquivo principal de configuração do rsyslog. A primeira vista temos os módulos (`module(load="imuxsock")`), que nesse caso serve para comunicação do `rsyslog` com `systemd-journal`, eles se comunicam. (isso nos sistemas baseados em Debian, já em Redhat muito provável que o nome do módulo seja `imjournal` - ambos tem as mesmas funções)

As configurações serão obtidas em `/etc/rsyslog.d/*.conf`(informado na última linha de `/etc/rsyslog.conf`)

Conforme for instalando aplicações, muito provável que elas criarão uma entrada no arquivo `50-default.conf`:<br>
Nesse arquivo o padrão de entrada é: `facility.priority`(facility é quem está gerando o log, qual aplicação, e priority é o nível do log (em ordem ascendente/crescente):<br>
- `debug`: muitos registros, mas não tão importantes
- `info`
- `notice`
- `warn` ou `warning`
- `err` ou `error`
- `crit`: poucos registros, mas precisa ser olhado
- `alert`
- `emerg` ou `panic`
- `*`=todos, qualquer nível de debug<br>
Exemplo: `mail.err` (`mail` é a facility e `err` é a priority)<br>
Como é em ordem crescente, no caso do mail acima, tudo que vir acima de `err`, vai ser criado log (`crit`, `alert` e `emerg`)

Se quiser priorizar **apenas** `err`, use `mail.=err`

Depois da coluna de `facility.priority`, seria onde se destina o log, no caso pode ser um caminho (`/var/log/syslog`, por exemplo) ou pode ser para um determinado usuário (`lpi1,lpi2` - separado pode vírgula) ou ainda para todos os usuário, usando o asterisco (`*`). Há possibilidade de mandar remotamente para outro servidor, usando a notação `@10.0.0.1`, por exemplo (precisa ser um servidor de logs - útil quando tiver muitos servidores, e para descentralizar a geração de logs).

A segunda linha é bem interessante:<br>

    auth,authpriv.*				var/log/auth.log
    *.*;auth,authpriv.none		-/var/log/syslog

*O `-` em frente ao caminho, significa prioridade para performance, que nesse caso com o traço (evita gravações em disco excessivas), **não** precisa ser registrado imediatamente.

No caso, a 2ª linha indica que tudo (`*`), relacionado à facility e priority (`*.*` - qualquer facility e qualquer priority), exceto `;auth,authpriv.none`, irão gerar log em `/var/log/syslog` (em Redhat seria em `/var/log/messages`)

*Todas as configurações vistas serão as mesmas no **syslog**.

É possível criar sua própria configuração:<br>
Em `/etc/rsyslog.d` crie no final do arquivo `50-default.conf`<br>

    local0.warn			/var/log/teste-rsyslog.out

Reinicie o **rsyslog**: `systemctl restart rsyslogd`

Para gerar o log, pode-se utilizar a ferramenta `logger`, com o seguinte comando:<br>

    logger -p local0.err "Teste de Rsyslog"
    # -p = --priority

Depois de executar o comando, é para ter gerado o arquivo `teste-rsyslog.out` dentro de `/var/log`. Executando um `cat` no arquivo criado, é possível verificar a mensagem de log que acabou de ser realizada.

Lembrando que o `rsyslog` é a evolução do `syslog`, caso queira usar o `syslog`, instalar o pacote `inetutils-syslog`. O arquivo de configuração do syslog fica geralmente em `/etc/syslog.conf` (`syslog` não cai no exame, apenas `rsyslog`)

Para leitura do log, usar `less` ou `more`. Se tiver compactado, usar `zless` ou `zmore`. Pode usar também `tail` ou `head`. Para filtrar, usar o `grep`:<br>

       # grep "dhcpclient" /var/log/syslog
        Sep 13 11:58:48 debian dhclient[448]: DHCPREQUEST of 192.168.1.4 on enp0s3 to 192.168.1.1 port 67
    Sep 13 11:58:49 debian dhclient[448]: DHCPACK of 192.168.1.4 from 192.168.1.1
    Sep 13 11:58:49 debian dhclient[448]: bound to 192.168.1.4 -- renewal in 1368 seconds.

Como você deve ter notado, a saída é impressa no seguinte formato:

-   Carimbo de data/hora
-   Nome do host a partir do qual a mensagem se originou
-   Nome do programa/serviço que gerou a mensagem
-   O PID do programa que gerou a mensagem
-   Descrição da ação que ocorreu

Existem alguns exemplos em que os registros não são em forma de texto, mas arquivos binários e — conseqüentemente — você deverá usar comandos especiais para analisá-los:

`/var/log/wtmp`

Use  `who`  (ou  `w`):

    root@debian:~# **who**
    root    pts/0        2020-09-14 13:05 (192.168.1.75)
    root    pts/1        2020-09-14 13:43 (192.168.1.75)

`/var/log/btmp`

Use  `utmpdump`  ou  `last -f`:

    root@debian:~# **utmpdump /var/log/btmp**
    Utmp dump of /var/log/btmp
    [6] [01287] [    ] [dave     ] [ssh:notty   ] [192.168.1.75        ] [192.168.1.75   ] [2019-09-07T19:33:32,000000+0000]

`/var/log/faillog`

Use  `faillog`:

    root@debian:~# **faillog -a | less**
    Login       Failures Maximum Latest                   On
    
    root            0        0   01/01/70 01:00:00 +0100
    daemon          0        0   01/01/70 01:00:00 +0100
    bin             0        0   01/01/70 01:00:00 +0100
    sys             0        0   01/01/70 01:00:00 +0100
    sync            0        0   01/01/70 01:00:00 +0100
    games           0        0   01/01/70 01:00:00 +0100
    man             0        0   01/01/70 01:00:00 +0100
    lp              0        0   01/01/70 01:00:00 +0100
    mail            0        0   01/01/70 01:00:00 +0100
    (...)

`/var/log/lastlog`

Use  `lastlog`:

    root@debian:~# **lastlog | less**
    Username         Port     From             Latest
    root                                       **Never logged in**
    daemon                                     **Never logged in**
    bin                                        **Never logged in**
    sys                                        **Never logged in**
    (...)
    sync                                       **Never logged in**
    avahi                                      **Never logged in**
    colord                                     **Never logged in**
    saned                                      **Never logged in**
    hplip                                      **Never logged in**
    carol            pts/1    192.168.1.75     Sat Sep 14 13:43:06 +0200 2019
    dave             pts/3    192.168.1.75     Mon Sep  2 14:22:08 +0200 2019

>[!NOTE]
>
> Também existem ferramentas gráficas para ler arquivos de log, como  `gnome-logs`  e  `KSystemLog`.

#### Entradas manuais no log do sistema:  `logger`

O comando  `logger`  é prático para scripts do shell ou para testes. O  `logger`  anexa todas as as mensagens recebidas a  `/var/log/syslog`  (ou a  `/var/log/messages`  quando o registro for feito em um servidor de log remoto centralizado, como veremos mais adiante):

carol@debian:~$ **logger this comment goes into "/var/log/syslog"**

Para imprimir a última linha de  `/var/log/syslog`, use o comando  `tail`  com a opção  `-1`:

root@debian:~# **tail -1 /var/log/syslog**
Sep 17 17:55:33 debian carol: this comment goes into /var/log/syslog

#### Como as mensagens são transformadas em logs

O processo a seguir ilustra como uma mensagem é gravada em um arquivo de log:

1.  Aplicativos, serviços e o kernel gravam mensagens em arquivos especiais (sockets e buffers de memória), por exemplo,  `/dev/log`  ou  `/dev/kmsg`.
2.  O  `rsyslogd`  obtém as informações dos sockets ou buffers de memória.
3.  Dependendo das regras encontradas em  `/etc/rsyslog.conf`  e/ou dos arquivos em  `/etc/ryslog.d/`, o  `rsyslogd`  move as informações para o arquivo de log correspondente (normalmente encontrado em  `/var/log`).
    

>[!NOTE]
>
>Um socket é um arquivo especial usado para transferir informações entre diferentes processos. Para listar todos os sockets em seu sistema, você pode usar o comando  `systemctl list-sockets --all`.

### logrotate (rotacionamento de logs)

Imagine o cenário que os logs começam a crescer com o passar do tempo, ao ponto de encher o disco. Aí que entra o rotacionamento de logs.

Um exemplo é executar o comando: `# ls -ltr /var/log/syslog*`

    -rw-r----- 1 syslog adm  130685 Nov 10 00:00 /var/log/syslog.3.gz
    -rw-r----- 1 syslog adm   88855 Nov 17 00:00 /var/log/syslog.2.gz
    -rw-r----- 1 syslog adm 2870981 Nov 24 00:00 /var/log/syslog.1
    -rw-r----- 1 syslog adm 1246647 Nov 25 08:19 /var/log/syslog

É possível perceber que o log do `syslog` vai rotacionando, de `syslog` vira `syslog.1`, depois é compactado, e o último é excluído, tudo isso configurável no `logrotate`.

- `/etc/logrotate.conf`: arquivo de configuração do logrotate. Aqui é uma configuração mais geral e genérica, e que incluir o diretório `/etc/logrotate.d`, que possui as configurações separadamente.

O **logrotate** não é um **daemon** que fica rodando, na realidade é executado pelo crontab (geralmente em `/etc/cron.daily`).

Alguns valores do logrotate nos arquivos de configuração:
- `rotate 4`: Preserva 4 semanas de logs.
- `weekly`: Rotaciona arquivos de log semanalmente.
- `missingok`: Não emite uma mensagem de erro se o arquivo de log estiver ausente; simplesmente passa para o seguinte.
- `notifempty`: Não rotaciona o log se estiver vazio.
- `compress`: Compacta arquivos de log com o  `gzip`  (padrão).
- `delaycompress`: Adia a compactação do arquivo de log anterior para o próximo ciclo de rotação (válido apenas quando usado em combinação com compress). Útil quando um programa não pode ser instruído a fechar seu arquivo de log e, portanto, pode continuar gravando no arquivo de log anterior por algum tempo.
- `sharedscripts`: Relacionado aos scripts  _prerotate_  e  _postrotate_. Para evitar que um script seja executado várias vezes, esse comando executa os scripts apenas uma vez, independentemente de quantos arquivos de log correspondem a um determinado padrão (por exemplo,  `/var/log/mail/*`). Porém, os scripts não serão executados se nenhum dos logs no padrão requerir a rotação. Além disso, se os scripts forem encerrados com erros, as ações restantes não serão executadas em nenhum log.
- `postrotate`: Indica o início de um script  _postrotate_.
- `invoke-rc.d rsyslog rotate > /dev/null`: Usa  `/bin/sh`  para executar  `invoke-rc.d rsyslog rotate > /dev/null`  depois de rotacionar os logs.
- `endscript`: Indica o fim do script  _postrotate_.

>[!NOTE]
>
>Para uma lista completa de diretrizes e explicações, consulte a página de manual de `logrotate.conf`.

#### O buffer de anel do kernel

Uma vez que o kernel gera diversas mensagens antes de  `rsyslogd`  se tornar disponível na inicialização, torna-se necessário um mecanismo para registrar essas mensagens. É aqui que o  _buffer de anel do kernel_  entra em ação. Trata-se de uma estrutura de dados de tamanho fixo e — portanto — à medida que novas mensagens são gravadas, as mais antigas vão desaparecendo.

O comando  `dmesg`  imprime o buffer de anel do kernel. Devido ao tamanho do buffer, este comando é normalmente usado em combinação com o utilitário de filtragem de texto  `grep`. Por exemplo, para pesquisar mensagens relacionadas a dispositivos Universal Serial Bus:

    root@debian:~# dmesg | grep "usb"
    [    1.241182] usbcore: registered new interface driver usbfs
    [    1.241188] usbcore: registered new interface driver hub
    [    1.250968] usbcore: registered new device driver usb
    [    1.339754] usb usb1: New USB device found, idVendor=1d6b, idProduct=0001, bcdDevice= 4.19
    [    1.339756] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
    (...)

#### systemd-journal

Monitora as entradas do sistema, gerando registro de logs, em uma base de dados interna (trabalha diferente do **rsyslog**). Logo são 2 tipos de registros, uma pelo **rsyslog** e outra pelo **systemd-journal**.

- `/etc/systemd/journald.conf`: arquivo de configuração do systemd-journal

É muito recomendado olhar o `man journald.conf` para aprofundar nas opções que ele oferece.

Os logs ficam em `/var/log/journal`, no entanto é criado um arquivo de base de dados interna, que não é possível ler com `cat` ou `less`.

Para realizar a leitura, é preciso usar o comando `journalctl`. Ele sozinho sendo executado, mostra todos os dados que já foram para o log do **journal** (muitos dados, que precisam ser filtrados) imprimirá todo o diário em ordem cronológica (com as entradas mais antigas listadas primeiro - se usar `-r` imprime na ordem reversa). Olhar `journalctl --help` para ver os filtros

- `journalctl -n10`: mostra as 10 últimas linhas
- `journalctl -f`: igual ao `tail -f`
- `journalctl -b` ou `--boot`: mensagens de log relacionadas ao boot do sistema
- `journalctl _TRANSPORT=kernel`: mostra tudo que tiver origem do kernel
- `journalctl _UID=0`: tudo que for referente ao usuário root (id=0)
- `journalctl --since "today"` ( `-S` ou `--since` ): todos os logs que aconteceram hoje
- `journalctl --since "1 hour ago"`: todos os logs que aconteceram há 1 dia
- `journalctl --since "2024-11-20" --until "2024-11-21"` (`-U` ou `--until`): todos os logs que aconteceram entre os dias 20 e 21 de novembro e 2024.
- `journalctl --verify`: verifica os logs, se não há nada corrompido.
- `journalctl --sync`: grava em disco tudo que ainda está em memória.

Mais algumas opções de palavras-chave:
- `yesterday`: A partir de meia-noite do dia anterior ao dia atual.
- `today`: A partir de meia-noite do dia atual.
- `tomorrow`: A partir de meia-noite do dia seguinte ao dia atual.
- `now`: A hora atual.

Exemplo: Vamos ver todas as mensagens desde a meia-noite passada até hoje às 21:00:

    root@debian:~# journalctl --since "today" --until "21:00:00"

Para ver as mensagens do diário relacionadas a um **executável** específico, a seguinte sintaxe é usada:  `journalctl  _/path/to/executable_`:

    root@debian:~# **journalctl /usr/sbin/sshd**
    -- Logs begin at Sat 2019-10-12 20:45:29 CEST, end at Sat 2019-10-12 21:54:49 CEST. --
    Oct 12 21:16:28 debian sshd[1569]: Accepted password for carol from 192.168.1.65 port 34050 ssh2

Para ver da mesma forma, mas com **unidades** (units), usa o `-u`:

    root@debian:~# **journalctl -u ssh.service**
    -- Logs begin at Sun 2019-10-13 10:50:59 CEST, end at Sun 2019-10-13 12:22:59 CEST. --
    Oct 13 10:51:00 debian systemd[1]: Starting OpenBSD Secure Shell server...

>[!NOTE]
>
>Para imprimir todas as unidades carregadas e ativas, use `systemctl list-units`; para ver todos os arquivos de unidade instalados, use `systemctl list-unit-files`.


#### Para navegar pela saída do diário, usamos:

-   Teclas `PageUp`, `PageDown` e as setinhas para nos mover para cima, para baixo, a direita e a esquerda.
-   `>`  para ir ao final da saída.
-   `<`  para ir ao início da saída.
    
Você pode pesquisar strings para a frente e para trás a partir de sua posição atual:
-   **Busca para a frente**: Pressione  `/`  e insira a string a pesquisar, depois dê Enter.
-   **Busca para trás**: Pressione  `?`  e insira a string a pesquisar, depois dê Enter.
    
Para navegar pelas correspondências nas pesquisas, use  `N`  para ir para a próxima ocorrência e  `Shift+N`  para ir para a anterior.

#### ver o tamanho dos logs

Supõe que esteja em `/var/log/`, execute `du -sh .`

#### túnel de dados (socket)

Como já vimos em `/etc/rsyslog.conf`, tem o uso de módulos, no caso o `imuxsock`, que vai servir como um túnel de dados entre o **journalctl** e o **rsyslog**.

Em `systemctl status rsyslog`, podemos obter o arquivo que carrega o **rsyslog**, no caso `rsyslog.service`. E se executar um `cat` nele (`cat /lib/systemd/system/rsyslog.service`) é possível ver ele requer (no campo **Requires**) o socket `syslog.socket` (que é uma unit do systemd - podendo ser verificada com o comando `systemctl status syslog.socket` - aqui é possível ver onde ele foi carregado).

Dando um cat onde está o socket visto anteriormente, `cat /lib/systemd/system/syslog.socket`, no campo **ListenDatagram**, mostra o que o syslog está ouvindo, que no caso é `/run/systemd/journal/syslog`. Nesse caso o rsyslog usa esse socket, por conta do módulo `imuxsock` que ouve  o **systemd journal**.

Para confirmar o socket, liste os arquivos em `/run/systemd/journal` (os arquivos **socket** e **stdout**, que começam com s nas permissões)

    cd /run/systemd/journal/
    root@PC:/run/systemd/journal# ls -l
    total 8
    srw-rw-rw- 1 root root    0 Nov  8 16:41 dev-log
    -rw-r--r-- 1 root root    0 Nov  8 16:41 flushed
    srw------- 1 root root    0 Nov  8 16:41 io.systemd.journal
    -rw-r--r-- 1 root root    8 Nov  8 16:41 kernel-seqnum
    -rw-r--r-- 1 root root   24 Nov  8 16:41 seqnum
    srw-rw-rw- 1 root root    0 Nov  8 16:41 socket
    srw-rw-rw- 1 root root    0 Nov  8 16:41 stdout
    drwxr-xr-x 2 root root 1160 Nov 25 10:32 streams
    srw-rw-rw- 1 root root    0 Nov  8 16:41 syslog


#### systemd-cat (parecido com logger)

Execute o `journalctl -f` para ficar logando as entradas (igual ao `tail -f`) em um terminal, e em outro use o `systemd-cat`, que vai mandar o output do comando diretamente para o **journal**.

Ex. `systemd-cat ls -ls rsyslog.conf`: manda a saída do comando `ls` diretamente no journal (onde deixou rodando o comando `journalctl -f`)

Pode usar também dessa forma: `echo "Mensagem de teste" | systemd-cat`

#### ver o tamanho dos logs journal

Supõe que esteja em `/var/log/journal`, execute `journalctl --disk-usage`

#### limpar logs

- `journalctl --vacuum-size=200M`: limpa 200 MB os arquivos de logs (archived apenas, não os ativos). Pode usar `--vacuum-time` e `--vacuum-files`

Voltar depois nesse tópico e no de mail e impressoras


## 109.1 Fundamentos dos protocolos de internet

- **TCP/IP**: Conjunto de Protocolos de comunicação entre computadores
- Engloba os protocolos IP, TCP, UDP, ICMP, entre outras

- **IP**: é o protocolo responsável pelo endereçamento lógico. Cada dispositivo em uma rede deve possuir um endereço IP único

- O endereço IP (IPv4) é formado por 32 bits, separados em 4 grupos de 8 bits, representados de maneira decimal.
	- 192.168.10.20 = 10000000.10101000.00001010.00010100
	- 0.0.0.0 = 00000000.00000000.00000000.0000000
	- 255.255.255.255 = 11111111.11111111.11111111.11111111

#### Classes

| Classe | 1º Octeto | Range |
| -------- | ----- | ----------- |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 |

Exemplos:
- Classe A - 10.25.13.10 - 110.14.20.12
- Classe B - 141.150.200.1 / 172.168.1.1
- Classe C - 192.168.20.30 / 200.178.12.242

#### Endereços: Privado vs Público

| Classe | 1º Octeto | Range | IPs Privados |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 10.0.0.0 - 10.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 172.16.0.0 - 172.31.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 192.168.0.0 - 192.168.255.255 |

#### Máscara

- utilizada em conjunto com o endereço IP para determinar a segmentação de rede
- também composta de 32 bits em 4 grupos de 8:
	- 255.0.0.0 = 11111111.00000000.00000000.00000000 = /8
	- 255.255.0.0 = 11111111.11111111.00000000.00000000 = /16
	- 255.255.255.0 = 11111111.11111111.11111111.00000000 = /24
	- 255.255.255.255 = 11111111.11111111.11111111.11111111 = /32
- 1s identificam a rede
- 0s identificam os hosts

| Classe | 1º Octeto | Range | Máscara Padrão |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 255.0.0.0 /8 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 255.255.0.0 /16 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 255.255.255.0 /24 |

Exemplos:
- Classe A - `110`.14.20.12
- Classe B - `172.168`.1.1
- Classe C - `200.178.12`.242

#### sub-redes

| Máscara | CIDR | Hosts | Sub-rede |
| -------- | ----- | ---------- | ------------ |
| 255.255.255.0 | 24 | 254 | 1 |
| 255.255.255.128 | 25 | 126 | 2 |
| 255.255.255.192 | 26 | 62 | 4 |
| 255.255.255.224 | 27 | 30 | 8 |
| 255.255.255.240 | 28 | 14 | 16 |
| 255.255.255.248 | 29 | 6 | 32 |
| 255.255.255.252 | 30 | 2 | 64 |

#### Rota padrão (gateway)

Duas sub-redes distintas, caso precisem se comunicar, terá que ter um gateway para realizar o intermédio entre essas redes (precisa de uma rota padrão).

#### IPv6

- IPv6 é um novo padrão de endereçamento IP
- cada endereço possui 128 bits, divididos em 8 grupos de 16 bits, representados por 4 números hexadecimais
- Exemplo: `2001:0db8:85a3:08d3:1319:8a2e:0370:7344`

#### abreviações

- 2001:0db8:85a3`:0000:0000:0000:0000:`7344
- 2001:0db8:85a3`:0:0:0:0:`7344
- 2001:0db8:85a3`::`7344
<br>
- 2001:0db8:85a3`:0000:0000:`1319`:0000:`7344
- 2001:0db8:85a3`:0:0:`1319`:0:`7344
- 2001:0db8:85a3`::`1319`:0:`7344

<br>

- **Unicast**: identifica uma única interface
- **Multicast**: identifica um conjunto de interfaces. Um pacote é enviado para cada interface
- **Anycast**: identifica um conjunto de interfaces. Um pacote e enviado para'uma única interface, normalmente a mais próxima

#### Diferenças entre IPv4 e IPv6

Além do endereço, diversas outras diferenças podem ser apontadas entre as versões 4 e 6 do IP. Eis algumas delas:
-   As portas de serviço seguem os mesmos padrões e protocolos (TCP, UDP); a diferença está apenas na representação do IP e no conjunto de portas. No IPv6, o endereço IP deve ser protegido com  `[]`  (colchetes):
    
   - IPv4:  `200.216.10.15:443`
   - IPv6:  `[2001:0db8:85a3:08d3:1319:8a2e:0370:7344]:443`
    
-   O IPv6 não implementa o recurso de broadcast (transmissão) da mesma maneira que o IPv4. Porém, o mesmo resultado pode ser obtido enviando-se o pacote para o endereço  `ff02::1`, que alcança todos os hosts da rede local — semelhante a usar  `224.0.0.1`  no IPv4 para uma transmissão multicast.
-   Por meio do recurso SLAAC (_Stateless Address Autoconfiguration_), os hosts IPv6 podem se autoconfigurar.
-   O campo TTL (_Time to Live_) do IPv4 foi substituído pelo “Hop Limit” (limite de saltos) no cabeçalho do IPv6.
-   Todas as interfaces IPv6 têm um endereço local, denominado endereço de link local, prefixado com  `fe80::/10`.
-   O IPv6 implementa o  _Neighbor Discovery Protocol_  (NDP), semelhante ao ARP usado pelo IPv4, mas com muito mais funcionalidades.

Que tipo de informação o Neighbour Discovery Protocol (NDP) pode descobrir?

O NDP é capaz de obter diversas informações da rede, incluindo outros nós, endereços duplicados, rotas, servidores DNS, gateways, etc.

#### TCP

- **TCP**: Transmission Control Protocol: protocolo de transporte orientado a conexões. Garante a entrega dos pacotes na ordem correta. O pacote é retransmitido em caso de erros na rede. Usado por serviços como FTP, SMTP, HTTP, POP3, IMAP, SSH, etc

#### UDP

- **UDP**: User Datagram Protocol: protocolo de transporte não  orientado a conexões. Não oferece garantia de entrega dos pacotes, assim tem melhor performance na transmissão de dados. Usado por serviços como DHCP, DNS, NFS e NTP.

#### ICMP

- **ICMP**: Internet Control Message Protocol: utilizado para transmitir informações de controle entre os elementos de rede, por exemplo:
	- controle de volume de tráfego
	- detecção de destinos nao atingíveis
	- redirecionamento de rotas
	- verificação de status de hosts remotos
- utilizado em comandos como o `ping` e `traceroute`

#### Portas e Serviços

- cada serviço é provido por meio de uma porta
- portas possuem 16 bits, ou seja, um máximo de 65535
- as primeiras 1024 portas são reservadas a serviços conhecidos (_portas privilegiadas_, por ter acesso de root ao sistema)
- as demais são utilizadas para serviços específicos ou para a porta de socket (_portas não privilegiadas_ ou portas de socket) de uma conexão (quando um cliente se conecta a um servidor http, o servidor normalmente usa a porta 80, já no cliente é configurado um socket/porta aleatório, como 42222, por exemplo. Essa porta é chamada de socket)
- toda conexão é composta de IP de **destino** e **origem**, assim como a porta de **destino** e **origem** (socket)
- As portas usadas por cada tipo de serviço são padronizadas e controladas pela IANA (_Internet Assigned Numbers Authority_). Assim, em qualquer sistema, a porta 22 é usada pelo serviço SSH, a porta 80 pelo serviço HTTP e assim por diante.
- Em um sistema Linux, as portas de serviço padrão são listadas no arquivo `/etc/services`.

<br>

Exemplo:
- `200.20.125.60`:25 (serviço SMTP)
- `172.168.8.10`:80 (serviço HTTP)
- `[2001:0db8:85a3:0000:0000:1319:0000:7344]`:80

| Porta(s) | Serviço |
| -------- | ----- |
| 20 e 21 | FTP |
| 22 | SSH |
| 23 | Telnet |
| 25 e 465 | SMTP e SMTPs |
| 53 | DNS |
| 67 e 68 | DHCP |
| 80 e 443 | HTTP e HTTPS |
| 110 e 995 | POP3 e POP3S |
| 123 | NTP |
| 139 | Netbios |
| 143 e 993 | IMAP e IMAPS |
| 161 e 162 | SNMP |
| 389 e 636 | LDAP e LDAPS |


## 109.2 Configuração de rede persistente

- `/etc/hostname`: define o nome da máquina (assim como digitar `hostname` vai mostrar o nome da máquina)
- `hostnamectl`: mostra mais informações do host
- `hostnamectl set-hostname novo_nome`: altera o hostname da máquina (altera também lá no `/etc/hostname`)

Uma configuração funcional de TCP/IP é apenas o primeiro passo para a usabilidade total da rede. Além de ser capaz de distinguir os nós da rede por seus números IP, o sistema deve poder identificá-los com nomes mais facilmente compreensíveis por seres humanos.

O nome pelo qual o sistema se identifica é personalizável e é aconselhável fazê-lo, mesmo se a máquina não for destinada a se conectar a uma rede. O nome local geralmente corresponde ao nome da rede da máquina, mas nem sempre. Se o arquivo  `/etc/hostname`  existir, o sistema operacional usará o conteúdo da primeira linha como nome local, que a partir daí é chamado simplesmente de  _nome do host_  (hostname, em inglês). As linhas que começam com  `#`  dentro de  `/etc/hostname`  são ignoradas.

O arquivo  `/etc/hostname`  pode ser editado diretamente, mas o nome de host da máquina também pode ser definido com o comando  `hostnamectl`. Quando fornecido com o subcomando  `set-hostname`, o comando  `hostnamectl`  pega o nome dado como argumento e o escreve em  `/etc/hostname`:

    # hostnamectl set-hostname storage
    # cat /etc/hostname
    storage

O nome de host (ou “hospedeiro”) definido em  `/etc/hostname`  é o nome  _estático_, ou seja, o nome usado para inicializar o nome de host do sistema na inicialização. O nome de host estático pode ser uma string com até 64 caracteres de comprimento. No entanto, é recomendado que ele consista apenas em caracteres ASCII minúsculos e sem espaços ou pontos. Também é aconselhável limitá-lo ao formato permitido para rótulos de nomes de domínio DNS, embora esse não seja um requisito estrito.

O comando  `hostnamectl`  pode definir dois outros tipos de nomes de host além do nome de host estático:

- **Hostname pretty**: Ao contrário do nome de host estático, o nome de host pretty pode incluir todos os tipos de caracteres especiais. Ele pode ser usado para definir um nome mais descritivo para a máquina, por exemplo “Armazenamento compartilhado da LAN”:
```
    # hostnamectl --pretty set-hostname "LAN Shared Storage"
```
- **Hostname transiente**: Usado quando o nome de host estático não está definido ou quando ele é o nome  `localhost`  padrão. O nome de host transiente é normalmente definido junto com outras configurações automáticas, mas também pode ser modificado com o comando  `hostnamectl`, por exemplo:
```
# hostnamectl --transient set-hostname generic-host
```
Se nem a opção  `--pretty`  nem  `--transient`  forem usadas, os três tipos de nomes de host serão configurados com o nome fornecido. Para definir o nome de host estático, mas não os nomes pretty e transiente, usa-se a opção  `--static`. Em todos os casos, somente o nome de host estático é armazenado no arquivo  `/etc/hostname`.

- `/etc/hosts`: arquivo que cria uma relação do IP e nome da máquina (igual o que há no windows)
Ex. de entrada no `/etc/hosts`:
```
192.168.0.100		minhamaquina		minhamaquina.dominio.com.br
```
*O terceiro campo é opcional. Quando for no terminal e der um ping em `minhamaquina`, vai pingar no IP associado:

    $ ping minhamaquina
    PING minhamaquina (192.168.0.100) 56(84) bytes of data.
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=1 ttl=64 time=0.257 ms
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=2 ttl=64 time=0.381 ms

- `/etc/nsswitch.conf` (Name Service Switch): disponibiliza diversas informações, de onde buscar as informações de `passwd`, `group`, `shadow`, etc. Geralmente é indicado como `compat` (compatibilidade), mas poderia, por exemplo, indicar para buscar no `ldap`.

No entanto para LPI1, é importante saber a parte de `hosts` e `networks`:
- `hosts`: vai estar como `files`, o que indica para buscar primeiramente aos arquivos do sistema, como o `/etc/hosts` (o que faz relação IP e nome), e caso não encontre, vai buscar em algum DNS configurado (no arquivo vai estar o `mdns4_minimal`, que é um serviço de DNS interno - `multicast dns`).

Exercício interessante:<br>
Qual entrada de  `/etc/hosts`  associa os nomes  `firewall`  e  `router`  com o IP  `10.8.0.1`?<br>
Resposta: A linha  `10.8.0.1 firewall router`.

- `/etc/networks`: mesma relação com o /etc/hosts, mas esse seria para redes.
```
rede-local		192.168.1.0 #nomeia essa rede como rede-local
```

- `/etc/resolv.conf`: determinar qual servidor DNS será utilizado pelo sistema. Indica o `nameserver` (apenas um servidor de nomes é necessário, mas é possível informar até **três** deles - os suplementares serão usados como reserva - se nenhuma entrada de servidor de nomes estiver presente, o comportamento padrão é usar o servidor de nomes da máquina local), que é basicamente o servidor DNS que irá usar. (mais detalhes no tópico **109.3**)
Importante dizer que esse arquivo é dinamicamente gerenciado/escrito/gerado pelo `systemd-resolved(8)`, que basicamente é um link que vem do `/etc/resolv.conf`. Isso significa que poderia ter seu próprio arquivo parecido com `resolv.conf` apontando para o `resolv` do `systemd` (para ambiente de produção, por exemplo).
```
ls -l /etc/resolv.conf 
lrwxrwxrwx 1 root root 39 Nov  8 16:20 /etc/resolv.conf -> ../run/systemd/resolve/stub-resolv.conf
```

#### NetworkManager

De modo geral, a configuração costuma ser feita por arquivos, sendo eles:
- No padrão Debian, geralmente fica em `/etc/network/interfaces`.
- Já no Red Hat, fica em `/etc/sysconfig/network-scripts`

No entanto as distros mais novas tem tendenciado utilizar o **NetworkManager**(o que é exigido na LPI - em tese não é cobrado os scripts listados acima, apenas na LPI2)

Existem aplicativos cliente do NetworkManager para a linha de comando e para o ambiente gráfico. No caso deste último, o aplicativo cliente é incluído como um acessório do ambiente de desktop (com nomes como _nm-tray_, _network-manager-gnome_, _nm-applet_ ou _plasma-nm_) e geralmente fica acessível por meio de um ícone indicador no canto da barra da área de trabalho ou no utilitário de configuração do sistema

Os arquivos de configuração ficam em `/etc/NetworkManager`. Dentro há algumas pastas, sendo:
- `system-connections`: onde é salvo as redes conhecidas pelo NetworkManager, configuração de perfis, redes wifi, etc.

Para verificar se o serviço do NetworkManager está executando: `systemctl status NetworkManager`. O NetworkManager foi desenvolvido originalmente pela Red Hat, sendo atualmente um projeto GNOME.

É possível gerir o NetworkManager por CLI, utilizando o `nmcli`.

As categorias chamadas  _objetos_ são:
- `general`: Status e operações gerais do NetworkManager
- `networking`: Controle geral de rede.
- `radio`: Controles de rádio do NetworkManager.
- `connection`: Conexões do NetworkManager.
- `device`: Dispositivos gerenciados pelo NetworkManager.
- `agent`: Agente secreto ou agente polkit do NetworkManager.
- `monitor`: Monitora as mudanças do NetworkManager.


- `nmcli`: lista as interfaces detectadas pelo NetworkManager e os servidores DNS configurados no computador
- `nmcli device` (ou `nmcli d` ou `nmcli dev`): resumo das interfaces
- `nmcli device show`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS)
- `nmcli device show enp2s0`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS) da interface selecionada
- `nmcli --help`: mostra as diversas outras opções do `nmcli`
- `nmcli general status`: mostra as informações/status na conexão no momento
- `nmcli networking`: se a rede cabeada está habilitada/funcionando
- `nmcli radio`: se o wifi está habilitado/funcionando
- `nmcli connection`: enquanto device mostra informações referentes ao dispositivo em si, connections mostra informações da(s) conexão(ões), como o tipo (ethernet e wifi)

Supondo que a saída do comando `nmcli connection` seja (O comando `status` é usado por padrão se nenhum argumento de comando estiver presente, de modo que o comando `nmcli general` é interpretado, na verdade, como `nmcli general status`): 

    DEVICE		UUID		TYPE			STATE			CONNECTION
    enp0s2		779a5...	ethernet		connected		Wired connection 1	
    enp0s4		45f23...	ethernet		connected		Wired connection 2

Para baixar a `Wired connection 2`, use: `nmcli con down "Wired connection 2"`

- `nmcli connection add type ethernet con-name nome_conexao ifname enp2s0 ip4 192.168.0.20/24 gw4 192.168.0.1`: cria uma nova conexao chamada `nome_conexao`, na placa `enp2s0`, com IP `192.168.0.20` máscara `255.255.255.0` e gateway `192.168.0.1`.
- `nmcli connection up nome_conexao`: ativa a rede criada no comando acima.
- `nmcli connection del nome_conexao`: remove a rede `nome_conexao`

Se voltarmos em `/etc/NetworkManager`, em `system-connections`, foi criado um arquivo `nome_conexao`. Mais opções em `nmcli connection --help`

#### NetworkManager - redes sem fio

- `nmcli device wifi list`: mostra as redes disponíveis (SSIDs). A com asterisco (`*`) é a que está em uso.
- `nmcli device wifi rescan`: reescaeia e coloca uma flag se um novo Wi-Fi scan deve ser engatilhado. Depois rode o `list` novamente.
- `nmcli radio wifi on/off`: habilita/desabilita o rádio wifi. (se trocar `radio` por `networking`, habilita/desabilita rede cabeada)
- `nmcli device wifi connect NOME_SSID password 123456`: conecta na rede `NOME_SSID` com a senha `123456` (obviamente não usar essa senha em produção). Confirme se conector com o asterisco mostrado no `nmcli device wifi list`
- Se a rede wi-fi esconde seu nome SSID, o  `nmcli`  ainda assim pode se conectar a ela com os argumentos extras  `hidden yes`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword hidden yes
```
- Se o sistema tiver mais de um adaptador wi-fi, indicamos o que deve ser usado com  `ifname`. Por exemplo, para se conectar usando o adaptador de nome  `wlo1`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword ifname wlo1
```

>[!NOTE]
>
>`nmcli device wifi connect`, apenas o SSID é obrigatório, a senha pode ser omitida caso a conexão já tenha sido criada anteriormente. Se o comando for executado dentro de um emulador de terminal no ambiente gráfico, aparecerá uma caixa de diálogo solicitando a senha da rede. Quando executado em um console de texto, a senha pode ser fornecida junto com os outros argumentos, como no comando acima

- `nmcli device disconnect wlo1`: desconectar da rede conectada anteriormente (não chega a desligar a interface - tanto que `nmcli device list` funciona).

Se houver um adaptador sem fio disponível, mas ele não estiver sendo usado, ele pode ser desligado para economizar energia. Desta vez, o objeto  _radio_  deve ser passado para  `nmcli`:

    $ nmcli radio wifi off

Obviamente, o dispositivo sem fio pode ser ativado novamente com o comando  `nmcli radio wifi on`.

>[!NOTE]
>
>Uma vez que as conexões forem estabelecidas, nenhuma interação manual será necessária no futuro, pois o NetworkManager identifica as redes conhecidas disponíveis e se conecta a elas automaticamente. Se necessário, o NetworkManager possui plugins que podem estender suas funcionalidades, por exemplo para suportar conexões VPN.

>[!NOTE]
>
>o UUID da conexão muda a cada vez que a conexão é ativada e, portanto, é preferível usar o nome para manter a consistência

Redes que o PC já conectou (e conhece):  **/etc/NetworkManager/system-connections**  e se dar um  **ls -la**, vai listar todas as redes que já foram conectadas (tanto wireless como rede cabeada). Inclusive se der um cat (como root) **mostra até a senha da rede** em um dos arquivos de conexão sem fio.

>[!WARNING]
>
>Atenção para os **estados possíveis** na execução de “**nmcli networking connectivity**” (pelo man):
-   **none**: O host não está conectado em nenhuma rede.
-   **portal**: O host está atrás de um “captive portal” e ainda não possui total acesso à Internet. “Captive portal” é a tela de login à qual você é redirecionado ao se conectar em uma rede de hotel ou aeroporto por exemplo.
-   **limited**: O host está conectado à rede, mas não tem acesso à Internet.
-   **full**: O host está conectado à rede e tem total acesso à Internet.
-   **unknown**: O status da conectividade não pode ser encontrado.

##### uma breve apresentação de ifupdown

Primeiramente precisa verificar se o pacote `ifupdown` está instalado: `dpkg -l | grep ifupdown`, caso não tenha, instalar: `apt install ifupdown -y` (nas distros mais recentes esse pacote foi retirado devido a entenderem que o que deve ser utilizado é o `NetworkManager`).

No man `ifup`, fala claramente que tanto `ifup` (para subir interfaces) como `ifdown` (para baixar interfaces) são usados baseados no arquivo `/etc/network/interfaces` (para caso deseje não utilizar o NetworkManager, e usar por arquivo de configuração)

Se tentarmos dar um `ifdown` na interface `enp2s0`, vai retornar que a interface em questão é desconhecida, pois `enp2s0` não está listado no arquivo `/etc/network/interfaces`.

#### systemd-networkd

O `systemd` também tem um gerenciador de rede (`systemctl status systemd-networkd` - provavelmente vai estar desabilitado) muito parecido com o modo de administração do NetworkManager.

No entanto é possível mudar o gerenciamento para o **systemd-networkd**. Basta parar o NetworkManager (`systemctl stop NetworkManager`) e iniciar o systemd-networkd (`systemctl start systemd-networkd`)

Se tentar rodar `nmcli device`, vai dar erro, pois o NetworkManager foi parado anteriormente.

Os arquivos de configuração podem estar em:
- `/lib/systemd/network` (com arquivos `.link` e `.network`) é onde. Aqui seria o diretório de rede do sistema.
- `/etc/systemd/network` : diretório local de administração da rede.
- `/run/systemd/netif` ou `/run/systemd/network`: diretório volátil de tempo de execução da rede.

Os arquivos são processados em ordem lexicográfica, por isso é recomendável iniciar seus nomes com números para facilitar o ordenamento e a leitura.

Os arquivos em  `/etc`  têm a prioridade mais alta, ao passo que os arquivos em  `/run`  têm precedência sobre os arquivos com o mesmo nome em  `/lib`. Ou seja, se dois ou mais arquivos de configuração em diretórios diferentes tiverem o mesmo nome, o systemd-networkd ignora os que tiverem menor prioridade. Essa maneira de separar os arquivos permite mudar as configurações da interface sem que seja necessário modificar os arquivos originais: as modificações podem ser postas em  `/etc/systemd/network`  para sobrescrever as existentes em  `/lib/systemd/network`.

A finalidade de cada arquivo de configuração depende de seu sufixo. Os nomes de arquivos que terminam em  `.netdev`  são usados pelo systemd-networkd para criar dispositivos de rede virtuais, como dispositivos  _bridge_  ou  _tun_. Os arquivos que terminam em  `.link`  definem configurações de baixo nível para a interface de rede correspondente. O systemd-networkd detecta e configura os dispositivos de rede automaticamente conforme eles aparecem — além de ignorar dispositivos já configurados por outros meios — e, portanto, há pouca necessidade de adicionar esses arquivos na maioria das situações.

O sufixo mais importante é  `.network`. Os arquivos que empregam esse sufixo podem ser usados para configurar endereços de rede e rotas. Tal como acontece com os outros tipos de arquivos de configuração, o nome do arquivo define a ordem em que ele será processado. A interface de rede à qual o arquivo de configuração se refere é definida na seção  ``[Match]` ``  dentro do arquivo.

Por exemplo, a interface de rede ethernet  `enp3s5`  pode ser selecionada dentro do arquivo  `/etc/systemd/network/30-lan.network`  graças à entrada  `Name=enp3s5`  na seção  `[Match]`:
```
[Match]
Name=enp3s5
```
Também é possível usar uma lista de nomes separados por espaços em branco para selecionar diversas interfaces de rede de uma vez neste mesmo arquivo. Os nomes podem conter globs no estilo do shell, como  `en*`. Outras entradas permitem usar regras diferentes, como por exemplo selecionar um dispositivo de rede por seu endereço MAC:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b
```
As configurações do dispositivo estão na seção  `[Network]`  do arquivo. Uma configuração de rede estática simples requer apenas as entradas  `Address`  e  `Gateway`:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
Address=192.168.0.100/24
Gateway=192.168.0.1
```
Para usar o protocolo DHCP em vez de endereços IP estáticos, a entrada  `DHCP`  deve ser usada:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
DHCP=yes
```
O serviço systemd-networkd tenta buscar os endereços IPv4 e IPv6 para a interface de rede. Para usar apenas IPv4, empregamos  `DHCP=ipv4`. Da mesma forma,  `DHCP=ipv6`  ignora as configurações IPv4 e usa apenas o endereço IPv6 fornecido.

As redes sem fio protegidas por senha também podem ser configuradas pelo systemd-networkd, mas o adaptador de rede já deve estar autenticado na rede antes que o systemd-networkd possa configurá-lo. A autenticação é realizada pelo  _WPA supplicant_, um programa dedicado a configurar adaptadores de rede para redes protegidas por senha.

O primeiro passo é criar o arquivo de credenciais com o comando  `wpa_passphrase`:
```
# wpa_passphrase MyWifi > /etc/wpa_supplicant/wpa_supplicant-wlo1.conf
```
Este comando pega a frase-senha para a rede sem fio  `MyWifi`  da entrada padrão e armazena seu hash em  `/etc/wpa_supplicant/wpa_supplicant-wlo1.conf`. Note que o nome do arquivo deve conter o nome apropriado da interface sem fio, por isso o  `wlo1`  no nome do arquivo.

O gerenciador do systemd lê os arquivos de frase-senha do WPA em  `/etc/wpa_supplicant/`  e cria o serviço correspondente para executar o WPA supplicant e abrir a interface. O arquivo de frase secreta criado no exemplo terá uma unidade de serviço correspondente chamada  `wpa_supplicant@wlo1.service`. O comando  `systemctl start wpa_supplicant@wlo1.service`  associará o adaptador sem fio ao ponto de acesso remoto. O comando  `systemctl enable wpa_supplicant@wlo1.service`  tornará essa associação automática durante a inicialização.

Finalmente, um arquivo  `.network`  correspondente à interface  `wlo1`  deve estar presente em  `/etc/systemd/network/`, já que o systemd-networkd vai usá-lo para configurar a interface assim que o WPA supplicant encerrar a associação com o ponto de acesso.

Lembrando que a LPI apenas cobra que saiba (awareness) que existe o `systemd-networkd`

#### nomenclaturas das placas de rede

As distribuições Linux mais antigas atribuíam às interfaces de rede ethernet nomes como  `eth0`,  `eth1`, etc., numeradas de acordo com a ordem em que o kernel identificava os dispositivos. As interfaces wireless eram nomeadas  `wlan0`,  `wlan1`, etc. Esta convenção de nomenclatura, no entanto, não esclarece qual porta Ethernet específica corresponde à interface  `eth0`, por exemplo. Dependendo de como o hardware fosse detectado, era possível inclusive que duas interfaces de rede trocassem de nome após uma reinicialização.

Para evitar essa ambiguidade, os sistemas Linux mais recentes empregam uma convenção de nomenclatura previsível para as interfaces de rede, criando uma aproximação maior entre o nome da interface e a conexão de hardware subjacente.

Nas distribuições Linux que usam o esquema de nomenclatura do systemd, todos os nomes de interfaces começam com um prefixo de dois caracteres que indica o tipo de interface:
- `en`: Ethernet
- `ib`: InfiniBand
- `sl`: Serial line IP (slip)
- `wl`: Rede de área local sem fio (WLAN)
- `ww`: Rede de longa distância sem fio (WWAN)

De prioridade mais alta para mais baixa, as seguintes regras são usadas pelo sistema operacional para nomear e numerar as interfaces de rede:

1.  Nomear a interface de acordo com o índice fornecido pela BIOS ou pelo firmware dos dispositivos incorporados, por exemplo,  `eno1`.
2.  Nomear a interface de acordo com o índice do slot PCI Express, conforme fornecido pela BIOS ou firmware, por exemplo,  `ens1`.
3.  Nomear a interface de acordo com seu endereço no barramento correspondente, por exemplo,  `enp3s5`.
4.  Nomear a interface de acordo com o endereço MAC da interface, por exemplo,  `enx78e7d1ea46da`.
5.  Nomear a interface usando a convenção legada, por exemplo,  `eth0`.

É correto pressupor, por exemplo, que a interface de rede  `enp3s5`  recebeu esse nome porque não se encaixava nos dois primeiros métodos de nomenclatura, de forma que seu endereço no barramento e no slot correspondentes foi usado. O endereço do dispositivo  `03:05.0`, encontrado na saída do comando  `lspci`, revela o dispositivo associado:

    $ lspci | fgrep Ethernet
    03:05.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8110SC/8169SC Gigabit Ethernet (rev 10)

As interfaces de rede são criadas pelo próprio kernel do Linux, mas existem muitos comandos que podem ser usados para interagir com elas. Normalmente, a configuração ocorre automaticamente e não há necessidade de se alterar as configurações manualmente. Ainda assim, com o nome da interface, é possível informar ao kernel como proceder para configurá-la se necessário.

## 109.3 Resolução de problemas básicos de rede

Na LPI-1 versão 5, foi adicionado o uso do pacote `iproute2` (`dpkg -l | grep iproute2`), sendo o principal pacote abordado, tendo os principais comandos o `ip` e `ss`.

Quem trabalha com linux a mais tempo, muito provável está mais acostumado a trabalhar com os comandos `ifconfig`, `route` e `netstat`, que são comandos do pacote `net-tools` (para administrar interfaces de rede e rotas no sistema).

O `iproute2` é uma implementação mais moderna, e a tendencia é utilizá-lo no lugar dos comandos do pacote `net-tools`. O pacote `net-tools`, no ponto de vista do exame, exige apenas conhecimento (awareness)

Com o comando IP é possível configurar interfaces e criar rotas. Na lição 109.2, quando foi visto NetworkManager, era ele quem fazia as alterações e configurações diretamente nas interfaces, já com `ip`, é o administrador que faz esse contato direto com as interfaces e todas do computador.

- `ip link show`: mostra as interfaces em uso e se estão funcionando. Não mostra IP. `link` é referente às interfaces (mostra também se está UP/DOWN).
- `ip address show` (pode usar `addr`): mostra com informações do IP
-  `ip route show` ou `ip route list`: mostra as rotas, como a default (pc que não está navegando, pode ser que está sem rota default)

Pressupondo que o sistema de arquivos  `sys`  esteja montado, também podemos listar o conteúdo de  `/sys/class/net`

    $ ls /sys/class/net
    enp0s3  enp0s8  lo

#### manipular endereços na interface

- `ip addr add 192.168.1.50/24 dev enp0s2`: configura o IP `192.168.1.50` na interface `enp0s2` (uma interface de rede pode receber mais de 1 IP)
- `ip addr del 192.168.1.50/24 dev enp0s2`: remove o IP 192.168.1.50 da interface enp0s2
- `ip addr flush dev enp0s2` remove todos os IPs configurados na interface `enp0s2`
- `ip addr add 2001:db8::10/64 dev enp0s8`: define u IPv6 para interface `enp0s8`

*Lembrando que essas alterações são em memória, ao reiniciar o PC, ele pegará as configurações do NetworkManager ou outro programa que esteja configurado para gerenciar a rede.

#### manipular a interface em si

O comando `ip link` é usado para configurar a interface de baixo nível ou para configurações de protocolos, como `VLANs`, `ARP` ou `MTUs`, ou ainda para desabilitar uma interface.

Às vezes é necessário ajustar o MTU de uma interface. Da mesma forma que é possível habilitar/desabilitar interfaces, esse ajuste também pode ser feito com  `ifconfig`  ou  `ip link`:

    # ip link set enp0s8 mtu 2000
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **2000** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff
    # ifconfig enp0s3 mtu 1500
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **1500** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff

- `ip link set enp0s2 down` (para subir usa `up`): baixa a interface `enp0s2` (retira o UP quando `ip link show`). Caso tenha mudado o IP antes de dar down e up, acaba perdendo essa configuração e busca novamente no gerenciador padrão de rede (normalmente NetworkManager).


#### rotas

Se adicionar um IP qualquer em alguma interface, será criado uma rota para a placa de rede escolhida. Se pode exemplo, `ip addr add 10.0.0.10/24 dev enp0s2` for executado, nas rotas (`ip route show`) será adicionado uma entrada dessa forma:
```
10.0.0.0/24 dev enp0s2 proto kernel scope link scr ...
```
Isso indica que tudo que estiver na rede `10.0.0.0/24` vá para interface `enp0s2`

- `ip route del default`: remove a rota default
- `ip route add default via 192.168.1.1`: adiciona uma rota default (nesse caso vai anexar à interface que a rede `192.168.1.0` pertence)
- `ip route add defaul via 192.168.1.1 dev enp0s2`: nesse caso adiciona a rota default à interface desejada, que no caso é `enp0s2`.
- `ip route add 172.16.30.0/24 via 10.0.0.1 dev enp0s2` : todo tráfego que for para a rede `172.16.30.0` vai para a rede `10.0.0.1` (`dev enp0s2` é opcional, pois aqui também detecta pela rede),
- - `ip route del 172.16.30.0/24 via 10.0.0.1 dev enp0s2`: remove a rota criada anteriormente
- 
No comando ip, a  opção `-s` ou `--stats` ou `-statistics` também pode ser usada para obtenção de estatísticas, como pacotes enviados, recebidos e etc, por exemplo:
-   `ip -s address` 
-   `ip -s address show wlp3s0`
-   `ip -s link`
-   `ip -s link show wlp3s0`

#### net-tools (ifconfig e route)

-`ifconfig enp0s8 down`: baixa a interface (se der `ifconfig`, não mostrartá mais, para mostrar precisar usar `ifconfig -a` - display all interfaces which are currently available, even if `down`)
- `ifconfig enp0s8 up`: sobe a interface (vai voltar o que estiver no padrão do NetworkManager)
- `ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0` (pode fazer por CIDR também: `10.0.0.100/24`): coloca o IP 10.0.0.100 na interface `enp0s8`.
- `ifconfig enp0s8 add 2001:db8::10/64`: configura IPv6 na interface.

*Note como, no IPv6, a palavra-chave  `add`  foi usada. Se um endereço IPv6 não for precedido por  `add`, será exibida uma mensagem de erro.

Se um interface já estiver down, e queira subir com IP, acrescente up no final do comando anterior, ficando:
```
ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0 up
```
Adicionar mais de um IP na mesma interface: 

    ifconfig enp0s8:0 10.0.0.100 netmask 255.255.255.0
    ifconfig enp0s8:1 10.0.0.102 netmask 255.255.255.0
    etc

- `route`: mostra a tabela de roteamento (similar ao `ip route`). Rota `default` = `0.0.0.0`
- `route del default`: remove a rota default
- route add default gw 192.168.1.1: adiciona a rota default para o gateway 192.168.1.1
- `route add -net 172.16.30.0/24 gw 192.168.1.50`: tudo que chegar para a rede `172.16.30.0/24` mande para `192.168.1.50`.


#### Comandos Debug

- `hostname -d` (ou `--domain`): mostra o domínio
- `hostname -f` (ou `--fqdn` ou `--long`): mostra o full qualified domain name (nome completo - hostname + domínio). Nome de domínio pega do `/etc/hosts`. Pega informações do NIS domain name (ou do DNS). **NIS (Network Information Service)**, também conhecido como **YP (Yellow Pages)**, é um serviço de diretório usado em sistemas Unix e Linux para compartilhar informações administrativas de forma centralizada em uma rede. Ele é projetado para distribuir dados como usuários, senhas, grupos, informações de hosts, entre outros, para facilitar a administração de sistemas em redes locais.

O **YP domain name** (nome do domínio NIS) é o identificador que agrupa os servidores e clientes NIS que compartilham o mesmo conjunto de informações. Ele é essencial para que os clientes saibam de qual servidor NIS obter dados.

- `ping -c5 192.168.0.1`: dispara 5 `ECHO_REQUEST` para o host/IP, que por sua vez, se acessível, faz 5 `ECHO_REPLY`.
- `ping -c5 -i2 192.168.0.1`: dispara a cada 2 segundos (-i = interval)
- `ping www.google.com`: primeiro vai resolver o domínio, buscando em `/etc/hosts/` e depois no `DNS`. Lembrando que se não está resolvendo o domain name, pode ser que a conexão esteja tudo certo, mas algum problema no `DNS`. Caso esteja resolvendo o domain name e obtendo o IP, mas mesmo não retorna o ping, pode ter algum problema da rota padrão. Uma última opção de falha, seria algum firewall no caminho ou no próprio domínio, que as vezes pode estar configurado para não receber ICMP (por exemplo o domínio `www.lpi.org` não responde a pacotes ICMP)

O `ping` em linhas gerais, trabalha tanto em IPv4 como em IPv6, mas caso queira especificar:
- `ping -4`: especifica que é um endereço IPv4
- `ping -6`: especifica que é um endereço IPv6

Para testar o IPv6, rode `host ipv6.google.com`, para obter o endereço IPv6
- `ping6 2800:3f0:4001:804::200e`: faz o ping no domínio IPv6 do google (O PC assim como o roteador e sua ISP precisam estar preparados para IPv6 para conclusão do comando acima)

- `traceroute www.google.com`: imprime a rota que o pacote faz até chegar ao host  de destino (**NÃO** faz por **ICMP**, e sim por **UDP**)
- `traceroute -I www.google.com` (ou `--icmp`): imprime a rota que o pacote faz até chegar ao host  de destino **USANDO ICMP** (com `-I`, precisa ser **root**).
- `traceroute6 ipv6.google.com`: imprime a rota usando IPv6 (específico para `IPv6`)

Semelhante ao `traceroute` é o `tracepath`. O `tracepath` não precisa ser root para excutar, como acontece com algumas opções do `traceroute`. O tracepath também trabalha com pacotes `UDP`.

Veja a descrição do man do `tracepath`:<br>

*It traces the network path to destination discovering MTU along this path. It uses UDP port port or some random port. It is similar to traceroute. However, it does not require superuser privileges and has no fancy options. tracepath -6 is a good replacement for traceroute6 and classic example of application of Linux error queues. The situation with IPv4 is worse, because commercial IP routers do not return enough information in ICMP error messages. Probably, it will change, when they are updated. For now it uses Van Jacobson's trick, sweeping a range of UDP ports to maintain trace history.*

Entretanto `tracepath` é mais simples do que o `tracepath`. Para IPv6, tem o `tracepath6`

Exercícios interessantes
1. Qual subcomando de  `ip`  pode ser usado para configurar a marcação de vlan?<br>
`ip link`  tem uma opção  `vlan`  que pode ser empregada. Veja abaixo um exemplo de marcação de uma sub-interface com vlan 20.

    # ip link add link enp0s9 name enp0s9.20 type vlan id 20

2. Como fazer backup da tabela de roteamento? Como restaurar esse backup?
    
    O exemplo abaixo demonstra o backup e a restauração de uma tabela de roteamento:
  ```  
    # ip route save > /root/routes/route_backup
    # ip route restore < /root/routes/route_backup
```

3. Qual subcomando de  `ip`  pode ser usado para configurar opções de spanning tree?

Como no caso do gerenciamento de configurações de vlan, o  `ip link`  pode configurar o spanning tree usando o tipo  `bridge`. O exemplo mostra a adição de uma interface virtual com uma prioridade STP de 50:

    # ip link add link enp0s9 name enp0s9.50 type bridge priority 50

#### comando ss e netstat

O `ss` é um comando do pacote `ip route` (mais moderno). O `netstat` pertence ao pacote `net-tools` (mais antigo). Ambos são utilizados para ver as conexões ativas no computador.

    $ whatis ss
    ss (8)               - another utility to investigate sockets
    $ whatis netstat
    netstat (8)          - Print network connections, routing tables, interface statistics, masquerade connections, and multicast...

Eis algumas opções disponíveis para ambos os programas (`ss` e `netstat`):
- `-a`: Mostra todos os sockets.
- `-l`: Mostra os sockets de escuta.
- `-p`: Mostra o processo associado à conexão.
- `-n`: Impede pesquisas de nome para portas e endereços.
- `-t`: Mostra as conexões TCP.
- `-u`: Mostra as conexões UDP.

- `ss`: mostra todas as conexões (e sockets) da máquina (inclusive para abertura de arquivos - que também usam socket)
- `ss -tu` (`-t` ou `--tcp` e `-u` ou `--udp`): lista conexões dos pacotes TCP e UDP estabelecidas no momento (mostra apenas conexões estabelecidas).
- `ss -a` (`--all`): mostra ambas `listening` e `non-listening` sockets
- `ss -l (--listening)`: mostra sockets que estão somente em `listening`(normalmente esses já são omitidos por padrão)

As formas vistas até agora, o comando ss resolve o nome das portas, em vez de colocar o número delas, assim como os hosts, para não resolver, use `-n`:
- `ss -tuln`: mostra sockets somente em `listening`, que sejam TCP e UDP e não resolve os nomes (mostrando o número da porta em si, e não a sua descrição - a descrição é obtida em `/etc/services`)

Com o `netstat`, vai funcionar normalmente, mudando apenas um pouco o formato: `netstat -tuln`

- `netstat ou ss -tanp`: mostra as conexões da porta TCP e UDP, com estado de `listening`, não resolvendo nomes e portas e relacionando o serviço com seu respectivo `PID` (`-p`).

Os exemplos abaixo mostram a saída de um conjunto de opções comumente usado em ambos os programas:

    # netstat -tulnp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      892/sshd
    tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1141/master
    tcp6       0      0 :::22                   :::*                    LISTEN      892/sshd
    tcp6       0      0 ::1:25                  :::*                    LISTEN      1141/master
    udp        0      0 0.0.0.0:68              0.0.0.0:*                           692/dhclient
    # ss -tulnp
    # ss -tulnp
    Netid  State      Recv-Q Send-Q      Local Address:Port                     Peer Address:Port
    udp    UNCONN     0      0                       **:68                                  *:**                   users:(("dhclient",pid=693,fd=6))
    tcp    LISTEN     0      128                     **:22                                  *:**                   users:(("sshd",pid=892,fd=3))
    tcp    LISTEN     0      100             127.0.0.1:25                                  **:**                   users:(("master",pid=1099,fd=13))
    tcp    LISTEN     0      128                  [::]:22                               [::]:*                   users:(("sshd",pid=892,fd=4))
    tcp    LISTEN     0      100                 [::1]:25                               [::]:*                   users:(("master",pid=1099,fd=14))

A coluna  `Recv-Q`  é o número de pacotes que um socket recebeu, mas não passou para seu programa. A coluna  `Send-Q`  é o número de pacotes que um socket enviou e que não foram confirmados pelo receptor. As colunas restantes são autoexplicativas.

Alguns exercícios interessantes

1. Qual comando poderia mostrar se há processos escutando na porta TCP 80?

Com  `ss`:

    $ ss -ln | grep ":80"

Com  `netstat`:

    $ netstat -ln | grep ":80"

Embora este não seja um requisito para o exame, você também poderia usar  `lsof`:

    # lsof -Pi:80

2. Como forçar o  `traceroute`  a usar uma interface diferente?

Usando a opção  `-i`:

    $ traceroute -i eth2 learning.lpi.org
    traceroute -i eth2 learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 60 byte packets

3. O  `traceroute`  é capaz de relatar MTUs?

Sim, com a opção  `--mtu`:

    # traceroute -I --mtu  learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 65000 byte packets
     1  047-132-144-001.res.spectrum.com (47.132.144.1)  9.974 ms **F=1500**  10.476 ms  4.743 ms
     2  096-034-094-106.biz.spectrum.com (96.34.94.106)  8.697 ms  9.963 ms  10.321 ms
    ...

#### netcat

Usado para teste de conexão no computador ou para abrir conexões locais. (arbitrary TCP and UDP connections and listens)

- `netcat 127.0.0.1 22`: teste localmente se é possível conectar na porta 22 (funciona parecido com `telnet`).

>[!NOTE]
>
>`netcat` e `nc` são o mesmo comando.

- `nc -l -p 1234`: abre a porta `1234` para ficar em `listening`. (`-l` = Listen for an incoming connection rather than initiating a connection to a remote host) e (`-p` = source_port: specify the source port `nc` should use, subject to privilege restrictions and availability)
- `nc 192.168.0.20 1234`: conecta na conexão aberta anteriormente (se digitar algo, aparece na outra ponta que está abrindo a conexão)
- `nc -vz 192.168.0.20 1234`: mostra uma mensagem se a conexão foi com sucesso. (`-v` Produce more verbose output) e (`-z` Only scan for listening daemons, without sending any data to them.  Cannot be used together with `-l`.)
- `nc -k -l -p 1234`: mantém a conexão para testes (`-k` When a connection is completed, listen for another one.  Requires `-l`.  When used together with the `-u` option, the server socket is not  connected and it can receive UDP datagrams from multiple hosts.)
- `nc -vz 192.168.0.20 1230-1240`: teste o range de portas definido entre `1230` e `1240`

O netcat funciona com endereços IPv4 e IPv6. Ele funciona com TCP e UDP. Pode inclusive ser usado para configurar um **shell remoto rudimentar**.
```
    $ hostname
    net2
    $ nc -u -e /bin/bash -l 1234
```
A opção  `-u`  significa UDP.  `-e`  instrui o netcat a enviar tudo o que recebe para a entrada padrão do executável que vem em seguida. Neste exemplo,  `/bin/bash`.

    $ hostname
    net1
    $ **nc -u net2.example.net 1234
    hostname
    net2
    pwd
    /home/emma

Percebeu como a saída do comando  `hostname`  corresponde à do host ouvinte e a saída do comando  `pwd`  é um diretório?

>[!WARNING]
>
>Nem toda instalação de  `nc`  suporta a opção  `-e`. Consulte as páginas de manual de sua instalação para obter informações de segurança sobre esta opção, bem como métodos alternativos para executar comandos em um sistema remoto.


## 109.4 Configurar o DNS do lado do cliente

- `/etc/hosts`: referências fixas entre IP e Nomes
- `/etc/nsswitch.conf`: determinar se a primeira consulta vai ser nos arquivos internos (padrão, como `hosts`)
- `/etc/resolv.conf`: arquivo principal onde é adicionado os servidores DNS (indicado por `nameserver`). Aqui que pode ter configuração de domínio: `domain dominio.com.br`
- `/etc/resolv.conf` está sendo gerado por  `/run/systemd/resolve/stub-resolv.conf` (resolvedor interno, pelo serviço `systemd.resolvd`)
- comando `resolvectl status` para ver os DNS configurados propriamente dito
- comando `resolvectl statistics` mostra estatísticas do servidor DNS, com cache, total de transações, etc.

A opção  `search` (em `/etc/resolv.conf`)  é usada para permitir pesquisas curtas. No exemplo, configuramos um único domínio para pesquisa,  `lpi.org`. Isso significa que qualquer tentativa de resolver um nome de host sem uma parte de domínio terá  `.lpi.org`  incluído antes da pesquisa. Por exemplo, se pesquisarmos por um host chamado  `learning`, o resolvedor buscará por  `learning.lpi.org`. É possível configurar até seis domínios de pesquisa.

Outra opção comum é  `domain`. Ela é usada para definir o nome de domínio local. Se esta opção estiver ausente, o padrão é usar tudo após o primeiro  `.`  no nome de host da máquina. Se o nome do host não contiver um  `.`, presume-se que a máquina faça parte do domínio raiz. Como no caso de  `search`,  `domain`  pode ser usado para pesquisas curtas de nomes.

Lembre-se de que  `domain`  e  `search`  são mutuamente exclusivos. Se ambos estiverem presentes, será usada a última instância no arquivo.

Muitas opções podem ser definidas de forma a afetar o comportamento do resolvedor. Para configurá-las, use a palavra-chave  `option`, seguida pelo nome da opção a ser configurada e, se for o caso, um  `:`  seguido pelo valor. Veja abaixo um exemplo de configuração da opção de tempo limite (timeout), ou seja, o período de tempo em segundos que o resolvedor espera por um servidor de nome antes de desistir:

    option timeout:3

O systemd inclui um serviço chamado `systemd-resolved`. Ele fornece mDNS, DNS e LLMNR. Quando está em execução, ele escuta as solicitações de DNS em `127.0.0.53`. Ele _não_ fornece um servidor DNS completo. Quaisquer solicitações de DNS que recebe são pesquisadas nos servidores configurados em `/etc/systemd/resolv.conf` ou `/etc/resolv.conf`. Se você deseja empregar o serviço, use `resolve` para `hosts` em `/etc/nsswitch.conf`. Lembre-se de que o pacote do sistema operacional que possui a biblioteca `systemd-resolution` pode não estar instalado por padrão

- `getent`, é útil para ver como as solicitações do mundo real serão resolvidas.
- `host`, é ótimo para consultas de DNS simples. 
- `dig` é prático para operações de DNS complexas que podem ajudar na resolução de problemas do servidor DNS.

- `host www.debian.org`: usa o servidor DNS para resolver o endereço www.debian.org. Se retirar o `www`, mostra todos os IPs relacionados ao domínio.
- `host www.debian.org 1.1.1.1`: consulta usando o server `1.1.1.1`
- `host -t mx debian.org`: mostra quais são os servidores que recebem query relacionadas aos emails no domínio. (`-t type`: This option specifies the query type. The type argument can be any recognized query type: `CNAME`, `NS`, `SOA`, `TXT`, `DNSKEY`, `AXFR`, etc)

- `dig` (antigamente usava `nslookup`): parecido com `host`, mas tem mais opções (internamente consulta o `systemd-resolve`).
- `dig www.debian.org @1.1.1.1`: consulta usando o server `1.1.1.1`
- `dig www.debian.org +short`: mostra só o IP (retira outros cabeçalhos)
- `dig -x 200.45.31.18`: resolve reverse lookups (mostra o nome associado ao IP)

- `getent`: pela entradas do Name Service Switch libraries (`/etc/nsswitch.conf`)
- `getent passwd`: mostra informações do `/etc/passwd`
- `getent passwd rodrigo`: mostra informações do usuário rodrigo
- `getent hosts www.debian.org`: resolve o domínio (tende resolver IPv6 - diferentemente de `host www.debian.org`, que traz IPv4 e IPv6)
- `getent ahostsv4 www.debian.org`: resolve em IPv4

Databases suportadas:
`ahosts` `ahostsv4` `ahostsv6` `aliases` `ethers` `group` `gshadow` `hosts` `initgroups` `netgroup` `networks` `passwd` `protocols` `rpc` `services` `shadow` (lembrar que `/etc/nsswitch.conf` que aponta por meio de `db files`)

Exercicios interessantes

1. Qual das opções a seguir é uma entrada correta de  `/etc/hosts`  entry?

| | |
|---|---|
|  ::1 localhost | certo |
| **localhost 127.0.0.1** | errado  |

`::1 localhost`  é a linha correta. A coluna da esquerda é sempre um endereço IPv4 ou IPv6.

2. O que significa a seguinte linha em  `/etc/nsswitch.conf`?
```
    hosts: files [SUCCESS=continue] dns
```
As pesquisas por nomes de host verificarão primeiro os arquivos de  `/etc/hosts`  e em seguida o DNS. Se uma entrada for encontrada nos arquivos e no DNS, a entrada no DNS será preferida.

3. O que faz o comando  `dig +noall +answer +question lpi.org`?

Ele pesquisa o registro A de  `lpi.org`  e exibe apenas a consulta e a resposta.

4. Como passar por cima dos padrões de  `dig`  sem especificá-los na linha de comando?

Criando um arquivo  `.digrc`  em seu diretório inicial

## 110.1 Executar tarefas administrativas de segurança

#### su e sudo
- `su`: muda de usuário para outro (loga como `root`: precisa digitar a senha do `root`)
- `sudo su`: loga como root usando a senha do usuário normal.

- `su lpi2`: loga com usuário `lpi2` (apenas muda o usuário - não executa o `.profile`, não cai no `home` do usuário propriamente dito)
- `su - lpi2`: loga com usuário `lpi2` (faz um novo login, como usuário `lpi2`, executando o `.profile` e caindo no home do usuário `lpi2`)
- `su -`: o mesmo que o explicado anteriormente. (aqui é feito um login propriamente dito, carrega as informações de `.profile`). Só `su` não faz efetivamente login.

Há alguns comandos que exigem que seja executado somente pro user root, como o `fdisk`, por exemplo.

Para executar uma vez, estando com usuário lpi1: `su -c "fdisk -l` (vai pedir senha do usuário root - `-c` = `--command`). Depois de executar volta ao usuário comum.

O `sudo` serve para situações que você não tenha a senha do usuário root (comum em ambientes de produção), e que precisa executar algo com privilégios de root.
- `sudo su -`: se estiver logado como `lpi1`, vai pedir a senha de `lpi1`, e loga como `root`. (isso porque `lpi1` tem permissões de logar como `root`)

Agora caso seja um usuário que não tenha permissão, e tente se logar, teremos a seguinte mensagem de erro:
```
$ sudo su -
[sudo] password for lpi2:    
Sorry, user lpi2 is not allowed to execute '/usr/bin/su -' as root on computer-name.

ou

lpi2 is not in the sudoers file. This incident will be reported.
```

Caso possua as permissões, pode simplesmente executar comandos como root usando: `sudo fdisk -l`

- `/etc/sudoers`: arquivo de configuração que vai dizer o que quais usuário podem fazer as alterações no sistema. A `%` no sufixo dos nomes `admin` e `sudo` indica que tanto `%admin` como `%sudo` são grupos.
- `%admin = ALL=(ALL) ALL`: membros do grupo `admin`, podem a partir de qualquer terminal (primeiro `ALL`), utilizando qualquer usuário (segundo `ALL`), podem executar qualquer comando (terceiro `ALL`)
- `%sudo ALL=(ALL:ALL) ALL`: mesmo raciocínio, agora para o grupo `sudo`. O usuário criado na instalação, muito provavelmente estará nesse grupo. Confirme com o comando `grep sudo /etc/group`. Para adicionar um usuário ao grupo `sudo`, digite: `sudo usermod -aG sudo usuario`. Para remover use: `sudo usermod -rG sudo usuario`

Se quiser personalizar uma regra, por exemplo para determinar que usuário `lpi2` possa desligar o computador, inclua o seguinte no arquivo `/etc/sudoers`

    lpi2 ALL=/sbin/poweroff

Caso queira listar os comandos que deseja liberar (lembrando vai pedir a senha do usuário, o que vai acontecer é como se estivesse no grupo `sudo`):

    Cmnd_Alias TESTE = /sbin/fdisk, /sbin/parted
    lpi2  ALL=TESTE

- `visudo`: vai direto para edição do `/etc/sudoers` (usando o editor padrão - para alterar o editor padrão: `update-alternatives --config editor`)

**Observações**: O  `sudo`  permite executar comandos simples com privilégios elevados em vez de lançar um novo subshell para root, como faria  `su`.
    
O uso básico de  `sudo`  é  `sudo -u  _target-username_  _command_`. Porém, para executar um comando como usuário root, a opção  `-u  _target-username_`  não é necessária:

    carol@debian:~$ sudo -u mimi whoami
    mimi
    carol@debian:~$ sudo whoami
    root

>[!NOTE]
>
>O  `sudoers`  usa uma marca temporal por usuário (e por terminal) para ocultar as credenciais, sendo assim possível usar o  `sudo`  sem uma senha por um período padrão de quinze minutos. Esse valor padrão pode ser modificado adicionando-se a opção  `timestamp_timeout`  como configuração de  `Defaults`  em  `/etc/sudoers`  (p. ex.:  `Defaults timestamp_timeout=1`  define o tempo limite do cache de credenciais como um minuto).

#### O arquivo  `/etc/sudoers`

O arquivo de configuração principal do  `sudo`  é  `/etc/sudoers`  (também existe o diretório  `/etc/sudoers.d`). É ali que os privilégios de  `sudo`  dos usuários são determinados. Em outras palavras, aqui você especifica quem pode executar quais comandos, sob quais nomes de usuário e em quais máquinas — bem como outras configurações. A sintaxe usada é a seguinte:

    carol@debian:~$ sudo less /etc/sudoers
    (...)
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    (...)

A especificação de privilégio para o usuário root é  `ALL=(ALL:ALL) ALL`. Isso se traduz assim: o usuário root (`root`) pode se logar com todos os hosts (`ALL`), em nome de todos os usuários e todos os grupos (`(ALL:ALL)`), além de executar todos os comandos (`ALL`). O mesmo vale para os membros do grupo  `sudo` — note como os nomes de grupos são identificados com um símbolo de porcentagem (`%`).

Assim, para que a usuária  `carol`  seja capaz de verificar o status de  `apache2`  de qualquer host em nome de qualquer usuário ou grupo, adicionaríamos a seguinte linha ao arquivo  `sudoers`:

    carol   ALL=(ALL:ALL) /usr/bin/systemctl status apache2

Para evitar a  `carol`  o incômodo de precisar fornecer sua senha para executar o comando  `systemctl status apache2`, modificamos a linha desta maneira:

    carol   ALL=(ALL:ALL) NOPASSWD: /usr/bin/systemctl status apache2

Digamos que agora você queira restringir seus hosts a 192.168.1.7 e permitir que  `carol`  execute  `systemctl status apache2`  no nome da usuária  `mimi`. A linha teria de ser modificada desta forma:

    carol   192.168.1.7=(mimi) /usr/bin/systemctl status apache2

Vamos então verificar o status do servidor web Apache como a usuária  `mimi`:

    carol@debian:~$ sudo -u mimi systemctl status apache2
    ● apache2.service - The Apache HTTP Server
       Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
       Active: active (running) since Tue 2020-06-09 13:12:19 CEST; 29min ago
    (...)

Se  `carol`  fosse promovida a sysadmin e você quisesse conceder a ela todos os privilégios, a maneira mais fácil seria incluí-la no grupo especial  `sudo`  com  `usermod`  e a opção  `-G`  (e talvez também a opção  `-a`, que garante que o usuário não seja removido de nenhum outro grupo ao qual possa pertencer):

    root@debian:~# sudo useradd -aG sudo carol

>[!NOTE]
>
>Na família de distribuições Red Hat , o grupo  `wheel`  é equivalente ao grupo especial de administradores  `sudo`  dos sistemas Debian.

Além dos usuários e grupos, também podemos utilizar aliases em  `/etc/sudoers`. É possível definir três categorias principais de aliases:  _aliases de host_  (`Host_Alias`),  _aliases de usuário_  (`User_Alias`) e  _aliases de comando_  (`Cmnd_Alias`). Eis um exemplo:

    # Host alias specification
    
    Host_Alias SERVERS = 192.168.1.7, server1, server2
    
    # User alias specification
    
    User_Alias REGULAR_USERS = john, mary, alex
    
    User_Alias PRIVILEGED_USERS = mimi
    
    User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
    
    # Cmnd alias specification
    
    Cmnd_Alias SERVICES = /usr/bin/systemctl *
    
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    ADMINS  SERVERS=SERVICES
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL

A partir deste arquivo  `sudoers`  de amostra, vamos explicar os três tipos de aliases com um pouco mais de detalhes:

- **Aliases de host**: Incluem uma lista separada por vírgulas de nomes de host, endereços IP, redes e grupos de rede (precedidos por  `+`). Máscaras de rede também podem estar especificadas. O alias de host  `SERVERS`  inclui um endereço IP e dois nomes de host:
```
Host_Alias SERVERS = 192.168.1.7, server1, server2
```
- **Aliases de usuário**: Incluem uma lista separada por vírgulas de usuários especificados como nomes de usuários, grupos (precedidos por  `%`) e grupos de rede (precedidos por  `+`). Para excluir usuários específicos, usamos  `!`. O alias de usuário  `ADMINS` — por exemplo — inclui a usuária  `carol`, os membros do grupo  `sudo`  e os membros do alias de usuário  `PRIVILEGE_USERS`  que não pertencem ao alias de usuário  `REGULAR_USERS`:
```
User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
```
- **Aliases de comando**: Incluem uma lista separada por vírgulas de comandos e diretórios. Se um diretório for especificado, qualquer arquivo que esteja nesse diretório será incluído — mas os subdiretórios serão ignorados. O alias do comando  `SERVICES`  inclui um único comando com todos os seus subcomandos — conforme especificado pelo asterisco (`*`):
```
Cmnd_Alias SERVICES = /usr/bin/systemctl *
```
Como resultado das especificações de alias, a linha  `ADMINS SERVERS=SERVICES`  na seção  `User privilege specification`  é traduzida como: todos os usuários pertencentes a  `ADMINS`  podem usar  `sudo`  para executar qualquer comando em  `SERVICES`  em qualquer servidor em  `SERVERS`.

>[!NOTE]
>
>Existe um quarto tipo de alias que pode ser incluído em  `/etc/sudoers`:  _aliases de execução_  (`Runas_Alias`). São muito semelhantes aos aliases de usuário, mas permitem especificar usuários por seu  _ID de usuário_  (UID). Esse recurso pode ser conveniente em certos casos.

#### who, w, last, lastb, lastlog

- `who`: mostra quem está logado no sistema, mostrando usuário, o terminal (`tty7` = terminal gráfico) e horário que logou. Se apertar `Ctrl+Alt+F2` (vai para o `tty2`), e se logar por lá, voltar para o `tty` e digita novamente `who`, vai mostrar a sessão de `tty2`
- `who -aH` (`-a` = `--all` e `-H` = `--heading`, colocar um header): mostra mais detalhes, assim como os terminais que não estão em uso, mostra também o `pid`.

O `who` aceita uma série de opções, dentre as quais podemos destacar as seguintes:
- `-b`,`--boot`: Exibe a hora da última inicialização do sistema.
- `-r`,`--runlevel`: Mostra o nível de execução atual.
- `-H`,`--heading`: Imprime o cabeçalho das colunas.

- `w`: mostra quem está logado e o que está fazendo (Show who is logged on and what they are doing.). Se voltar lá no `tty2` e executar o `top`, voltar para `tty7` e digitar `w`, mostra todas as informações do que o usuário que logou no `tty2` está fazendo, quanto está consumindo, etc. **JCPU** = uso de CPU no geral, **PCPU** = quanto o processo que está sendo executado (`top`) está consumindo. Ideal para monitorar sessões que estão consumindo muito recurso do computador.

>[!NOTE]
>
>Comparado ao  `who`, o  `w`  fornece uma saída um pouco mais detalhada:

Como no caso do  `who`, podemos passar nomes de usuários ao  `w`: `root@debian:~# w lpi2`

- `last`: histórico de logins no computador. Mostra o usuário que logou, o terminal que usou, quando foi feito o login, e quanto tempo ficou logado.
- `last lpi2`: mostra os últimos logins do usuário `lpi2`
- `lastb`: histórico de usuários que tentaram se logar, mas erraram a senha, ou usuário não existia. Esses dados (do `last`) são consultados de `/var/log/wtmp` (arquivo binário). Para ler usar last -f `/var/log/wtmp` (`-f` ou `--file`). O `lastb` é lido em `/var/log/btmp`. Para ler faz igual ao last: `last -f /var/log/btmp`

- `lastlog`: mostra quando os usuários do sistema fizeram login (login mesmo, não conta `su -`). `Observação`: usuários de sistema normalmente não devem ter feito login (precisa mostrar como `Never logged in`.
- `lastlog -u rodrigo` (`-u` ou `--user`): mostra o último login do usuário `lpi2`

#### passwd, usermod e chage

- `chage`: muda as definições de tempo para a senha expirar, conta inativa. Olhar novamente no item 107.1 parte 4. Similar ao `passwd`

- `passwd -S lpi2` (`-S` ou `--status`): mostra o status do usuário `lpi2`
```
lpi1@debian:~$ passwd -S
lpi1 P 12/07/2019 0 99999 7 -1
```
Eis uma análise dos sete campos obtidos na saída:
- `lpi1`: Nome de login do usuário.
- `P`: Indica que o usuário possui uma senha válida (`P`); outros valores possíveis são  `L`  para uma senha bloqueada e  `NP`  para nenhuma senha.
- `12/07/2019`: Data da última alteração da senha.
- `0`: Idade mínima em dias (o número mínimo de dias entre mudanças de senha). Um valor de  `0`  significa que a senha pode ser alterada a qualquer momento.
- `99999`: Idade máxima em dias (o número máximo de dias em que a senha é válida). Um valor de  `99999`  desabilita a expiração da senha.
- `7`: Período de aviso em dias (o número de dias antes da expiração da senha em que um usuário será avisado).
- `-1`: Período de inatividade da senha em dias (o número de dias inativos após a expiração da senha até que a conta seja bloqueada). Um valor de  `-1`  remove a inatividade de uma conta.

- `passwd -x30 lpi2` (`-x` ou `--maxday`): define para a senha expirar daqui `30` dias. (consulte com `chage -l lpi2`) (similar ao `chage -M` ou `--maxdays`)
```
chage -l lpi2
Last password change					: Nov 13, 2024
Password expires					: Dec 13, 2024
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 30 #definiu aqui
Number of days of warning before password expires	: 7
```
- `passwd -n2 lpi2` (ou `--mindays`): define o mínimo de dias que o usuário pode trocar a senha. Similar ao `chage -m` ou `--mindays`.

- `passwd -w4 lpi2` ( ou`--warndays`): número de dias que vai alertar que a senha vai expirar (Number of days of warning before password expires). No `chage`, seria `chage -W` ou `--warndays`
- `passwd -i10 lpi2` (ou `--inactive`): depois de 10 dias que a conta expirar, a conta vai ficar inativa. O `chage` seria `chage -I` ou `--inactive`
- `passwd -l lpi2` (ou `--lock`): trava (lock) o usuário `lpi2` (colocar `!` no primeiro caractere do campo de senha do `/etc/shadow`) - usando quando precisa investigar o usuário. Para destravar `passwd -u lpi1` (ou `--unlock`): retira a exclamação `/etc/shadow`. Quando estiver lock, no `passwd -S lpi2` vai mostrar um `L` de `Locked`. Se estiver `unlocked`, vai mostrar um `P` de `Password`. No `chage` seria `chage -E` ou `--expiredate` para fazer lock do usuário e `chage -1` para deixar `unlocked`

- `usermod -L lpi2` (ou `--lock`): trava (lock) o usuário
- `usernod -U lpi2` (ou `--unlock`): remove lock da conta.
- `usermod -e lpi2` (ou `--expiredate`): colocar uma data de expiração.
- `usermod -f lpi2` (ou `--inactive`): quantidade de dias que vai ficar inativo quando expirar a senha

#### find, ulimit, limits.conf

Partindo do cenário que `/usr/bin/passwd` tem o bit **SUID** ligado (`rwsr-xr-x`) e que qualquer usuário pode executá-lo como `root` e, diferentemente de `/bin/rm`, que por segurança não possui bit **SUID** ligado (pois qualquer usuário poderia excluir pastas críticas), é interessante monitorar por arquivos com **SUID** ligado, com o comando find.

- `find / -perm -4000 -ls` (ou `-2000`): `4000` procura por **SUID** e `2000` pelo **SGID** (o `-ls` no final é apenas para listar).
- `find / \( -perm -2000 -o -perm -4000 \) -ls
`: procura tanto por **SUID** como por **GUID** (precisa proteger com parênteses e escapá-los - o `-o` = or/ou).
- `find / -perm /6000`: busca tanto **SUID** como **GUID**

>[!NOTE]
>
>Pode usar com a notação simbólica: `find / -perm -u+s` para 4000 ou `find / -perm -g+s` para 2000.

Situação ideal seria criar um script que guarde essa informação diariamente, e compare, e caso haja mudança emita um alerta ao Administrador.

Outra medida de segurança é buscar por arquivos que não tenham usuários associados, novamente com o `find`:
- `find / -path /proc -prune -nouser -ls`: mostra todos

Alguns exercícios interessantes dessa seção:

1. O `chage` permite alterar as informações de expiração de senha de um usuário. Como root, complete a seguinte tabela, fornecendo os comandos corretos para o usuário `mary`:
2. 
| Significado           | Comandos `chage`                  |
|---------------------------|--------------------------------------|
| Faça a senha ser válida por 365 dias.                                       | `chage -M 365 mary`, `chage --maxdays 365 mary`                             |
| Faça o usuário alterar a senha no próximo login.                           | `chage -d 0 mary`, `chage --lastday 0 mary`                                 |
| Defina o número mínimo de dias entre as alterações de senha para 1.         | `chage -m 1 mary`, `chage --mindays 1 mary`                                 |
| Desative a expiração da senha.                                              | `chage -M 99999 mary`, `chage --maxdays 99999 mary`                         |
| Permita que o usuário altere sua senha a qualquer momento.                  | `chage -m 0 mary`, `chage --mindays 0 mary`                                 |
| Defina o período de aviso para 7 dias e a data de expiração da conta para 20 de agosto de 2050. | `chage -W 7 -E 2050-08-20 mary`, `chage --warndays 7 --expiredate 2050-08-20 mary` |
| Imprima as informações de validade da senha atual do usuário.               | `chage -l mary`, `chage --list mary`                                        |

2. Considere a seguinte linha de saída de comando  `last`  e responda às perguntas:
```
carol    pts/0        192.168.1.4      Sun May 31 14:16 - 14:22  (00:06)
```
-   `carol`  estava conectada a partir de um host remoto? Por quê?
    Sim, o endereço IP do host remoto está na terceira coluna.
    
-   Quanto tempo durou a sessão de  `carol`?
    Seis minutos (como mostrado na última coluna).
    
-   `carol`  estava conectada através de um terminal de texto clássico? Por quê?
    Não,  `pts/0`  na segunda coluna indica que a conexão foi feita por meio de um emulador de terminal gráfico (ou  _Pseudo Terminal Slave_).

3. Além de  `SUID`  e  `SGID`, existe uma terceira permissão especial: o  _sticky bit_. No momento, ele é usado principalmente em diretórios como  `/tmp`  para evitar que usuários regulares excluam ou movam arquivos que não sejam seus. Realize as seguintes tarefas:

-   Defina o  _sticky bit_  em  `~/temporal`:
    ```
    `chmod +t temporal`,  `chmod 1755 temporal`
    ```
-   Encontre diretórios com o  _sticky bit_  (e quaisquer outras permissões) definidas em seu diretório inicial:
    ```
    `find ~ -perm -1000`,  `find ~ -perm /1000`
    ```
-   Remova o  _sticky bit_  de  `~/temporal`:
    ```
    `chmod -t temporal`,  `chmod 0755 temporal`
    ```
## 110.2 Configurar a segurança do host



## 110.3 Proteção de dados com criptografia

#### O que é criptografia

Uma maneira de garantir que dados sejam enviados de um ponto a outro de maneira segura, tendo os objetivos principais:
	- Autenticidade (do remetente)
	- Confidencialidade (da mensagem)
	- Integridade (da mensagem)
	- Irretratabilidade (do remetente)

#### SSH - Secure Shell

- protocolo de criptográfica de rede
- cria um canal seguro de comunicação entre 2 hosts, um cliente e um servidor
- utiliza chaves assimétricas, ou seja, um conjunto de chaves públicas e privadas
- OpenSSH é a implementação mais comum

#### Chaves Assimétricas

- cada máquina possui sua chave pública e sua chave privada, que são associadas
- a **chave pública** será compartilhada com o remetente, que a utilizará para **criptografar** a mensagem antes de enviá-la
- a **chave privada** é utilizada pelo destinatário para **descriptografar** os dados recebidos

- `apt install openssh-server`: instala o OpenSSH Server (`/etc/ssh/sshd_config` - que recebe conexões). Instala também as chaves públicas e privadas (os conjuntos). Observar se o servidor `sshd` está rodando (`ps axu | grep sshd`)

Um detalhe interessante em relação às chaves, no caso as privadas, apenas root (chmod 600) que conseguirá ler ou escrever. Os demais usuário não terão permissão, com exceção das chaves públicas (chmod 644). Chave privada é secreta, já a pública não é.

#### conexão por senha

- `ssh lpi1@meu-servidor`: onde `lpi1` é o usuário do host remoto e meu-servidor pode ser o nome ou IP do servidor. A primeira conexão o host remoto envia a chave pública para o host que está conectando, para negociarem a conexão (geralmente será armazedo em `~/.ssh/known_hosts`). Se a chave mudar, vai dar erro ao conectar, e será necessário substituir a chave pública dentro de `~/.ssh/known_hosts`
- `ssh -l lpi1 meu-servidor`: outra forma de login, especificando o usuário com o comando `-l` (login_name). Se usar sem usuário, vai mandar o usuário do PC de origem para o servidor remoto (caso coincidam, vai funcionar)
- `ssh -v lpi1@meu-servidor`: modo verbose, para acompanhar os passos da conexão. Interessante notar que há um passo, chamado `Authentications that can continue`, que informa que deve tentar conexão primeiramente com publickey e depois password (`Authentications that can continue: publickey,password`)

>[!NOTE]
>
>Sobre o comando ssh, vale apontar também a opção `-i`, que pode ser utilizada para selecionar um arquivo de chave privada específico.

#### conexão por chaves (sem senha)

Primeiramente é preciso criar as chaves privada e pública no Host de origem.

- `ssh-keygen -t rsa -b 1024`: cria uma chave privada e pública usando o `-t` para especificiar o tipo da chave (se não especificar cria `Ed25519 Key` por padrão - é bom sempre verificar o man, pois as vezes muda esse padrão). O `-b` é de quantidade de bits que será usado para criar a chave.

>[!NOTE]
>
>Valores possíveis: `dsa` | `ecdsa` | `ecdsa-sk` | `ed25519` | `ed25519-sk` | `rsa` (Specifies the type of key to create.  The possible values are “dsa”, “ecdsa”,  “ecdsa-sk”, “ed25519”, “ed25519-sk”, or “rsa”)

>[!WARNING]
>
>Lembrando que o comando `ssh-keygen` gera as chaves para o usuário que está logado, armazendo em sua pasta home padrão (`~/.ssh/`)

Agora é necessário adicionar a chave pública no servidor que deseja acessar remotamente, mais especificamente no home do usuário do servidor, e criar o arquivo `authorized_keys` e colar a chave pública gerada no host de origem. Caso não exista o diretório `~/.ssh`, crie com o `mkdir` e mude as permissões para `600`. Caso tenha criado como root, mude para o usuário que prentende usar para o login, com `chown lpi1:lpi1 authorized_keys`.

Use o comando `ssh-copy-id -i id_rsa.pub lpi1@meu-servidor` para enviar a chave pública para o host servidor. Caso não exista o arquivo `authorized_key`, o comando no `ssh-copy-id` cria remotamente (e já adiciona a chave pública informada com o comando `-i`). É muito mais prático fazer o envio com esse comando.

A conexão por chave é muito interessante quando é necessário conectar com muita frequência em determinado computador, ou quando algum script precisar acessar algum outro computador, evitando o uso de senhas.

#### autenticação usando passphrase

Lembrando que passphrase é uma senha das chaves. Crie uma passphrase usando o oomando de gerar chaves, no caso o `ssh-keygen -t rsa -b 1024`.

Como é uma nova chave, compartilhe a chave pública ao servidor remoto (via `authorized_keys`)

Agora por meio do **ssh-agent** (`ps axu | grep ssh-agent`), as senhas das chaves (passphrase) serão memorizadas. Digite `ssh-add` para solicitar a senhas das chaves e criar identities que manterão a senha, por meio do 110.

Após delegar ao **ssh-agent**, efetue o login normalmente. O normal é logar diretamente, sem pedido de senha.

Para limpar as senhas digitadas, use `ssh-add -D` (Deletes all identities from the agent)

#### Ciphers

Basicamente há 4 tipos de chaves para criar com o comando `-t` de `ssh-keygen`, sendo eles: **dsa**, **ecdsa**, **ed25519** e **rsa** (opções na aula - no linux ubuntu 24.04 LTS, já aparece com as opções  **dsa** | **ecdsa** | **ecdsa-sk** | **ed25519** | **ed25519-sk** | **rsa**).

Lembrando que em uma conexão remota, os dois pontos precisam entender a criptografia usada das chaves.

#### Tunel SSH e SCP

Usado para serviços que **não** são criptografados (como VNC, telnet, FTP).

Supõe que queira conectar via telnet em um servidor, usando a porta 23 no servidor (porta padrão do telnet), usando um túnel, que no computador cliente (de origem), irá usar a porta 2323, use o comando:
- `ssh -N -f -L 2323:10.0.0.112:23 lpi1@10.0.0.112`: o `-N` indica para **NÃO** executar comando remoto. O `-f` é para rodar o `ssh` em background. O `-L` é para especificar a conexão (o túnel no caso), que pode ser nos seguintes formatos:
  - `-L [bind_address:]port:host:hostport`
  - `-L [bind_address:]port:remote_socket`
  - `-L local_socket:host:hostport`
  - `-L local_socket:remote_socket`
No final faz a conexão, com formato já estudado (`lpi1@10.0.0.112`)

Confirme se o processo está em execução, com `ps axu | grep ssh`:
```
lpi1    4173    0.0 0.0     44920   684  ?  Ss  11:16   0:00 -N -f -L 2323:10.0.0.112:23 lpi1@10.0.0.112
```

Confirme também se o processo ssh está escutando na porta `2323`: `netstat -nalpt | grep 2323`
```
tcp     0   0   127.0.0.1:2323     0.0.0.0:*    LISTEN 4173/ssh
tcp     0   0   ::1:2323            :::*        LISTEN 4173/ssh
```

Confirme também com `nmap`: `nmap localhost` (pode ser que mostre como `3d-nfsd`, pois é o serviço que está mapeado com a porta `2323` em `/etc/services`, mas vai funcionar normalmente, pois a porta estava livre)

A partir do computador cliente, faça conexão via túnel: `telnet localhost 2323`

Para desfaze o túnel ssh use: `killall ssh`

Outra funcionalidade do túnel é fazer conexão no servidor X do servidor.

- `ssh -X lpi1@10.0.0.112 "gnome-calculator"` executa na interface gráfica do PC Servidor, a partir do PC cliente (abre o programa no PC Cliente, mas o processo fica no PC Servidor, tudo via ssh)

`-X` Enables X11 forwarding. This can also be specified on a per-host basis in a configuration file.             X11 forwarding should be enabled with caution.  Users with the ability to bypass file permissions on the remote host (for the user's X authorization database) can access the local X11 display through the forwarded connection.  An attacker may then be able to perform activities such as keystroke monitoring

PC Servidor (está rodando, mas aparece apenas no Cliente)
```
$ ps axu | grep calculator
lpi1   188775 24.2  0.5 587108 88412 ?        Ssl  19:15   0:00 gnome-calculator
```

PC Cliente (programa aparece, mas está rodando no Servidor)
```
$ ps axu | grep calculator
lpi1   21476 0.3  0.1 17252 88960 pts/0        S+  19:15   ssh -X lpi1@192.168.0.10 gnome-calculator
```

**Observação**: pode omitir o comando, e assim que logar, ir digitando os programas que deseja rodar no Servidor.

- `ssh lpi1@10.0.0.1 "ls -l; free"`: executa o comando remotamente e volta no terminal que origiou o comando (fechando a conexão)

- `scp`: usado para enviar e receber arquivos via ssh.
- `scp arquivo.txt lpi1@linux-server:/tmp`: joga o arquivo `arquivo.txt` para a pasta `/tmp` no servidor.
- `scp lpi1@linux-server:~/arquivotexte.tgz .`: pega o arquivo `arquivotexte.tgz` que está no servidor e baixa/salva no diretório corrente (devido ao ponto `.`)

#### GPG - GNU Privacy Guard

Programa usado para assinar documentos, emails, etc para realizar a transmissão segura. Mesmo conceito de chaves assimétricas que o SSH usa para conexão, mas nesse caso, para arquivos.

Verificar se está instalado: `dpkg -l | grep gnupg`

- `gpg --gen-key`: gerar a chave pública e privada. (No exemplo do vídeo da aula, provavelmente houve atualização, considerar usar `--full-generate-key`)
- `gpg --list-keys`: lista as chaves criadas, que ficam em `~/.gnupg`

Agora é realizar o mesmo conceito de enviar a chave pública para a pessoa que vai receber os arquivos, logo precisa exportar essa chave pública

- `gpg --export "rodrigo" > chave-rodrigo.pub`: o nome é o mesmo escolhido na hora da criação (ou veja o nome com o comando de listar as chaves), e redireciona para um arquivo, nesse caso, `chave-rodrigo.pub`
- `gpg --output nova-chave.pub --export "rodrigo"`: apenas outra forma de exportar a chave pública (veja com `cat` que não é possível visualizar)
- `gpg --output nova-chave.pub --armor --export "rodrigo"`: exporta a chave pública em formato ASCII (em texto, mais simples para envio)

Depois precisa fazer o envio da chave, que pode ser copiando o conteúdo dela, enviando os arquivos, ou pode ser exportando para um servidor de chaves.

- `gpg --keyserver keys.gnupg.net --send-keys id_chave`: envia a chave `id_chave` (obtido do comando de listar chaves), e faz o envio para o servidor `key.gnupg.net` (se tiver um server, indique o IP dele)
- `gpg --keyserver keys.gnupg.net --gen-revoke id_chave`: cancela a chave no servidor

Agora a pessoa que vai receber o documento cifrado, precisa importar essa chave para ela, para poder decifrar o documento

- `gpg --import chave.pub`: importa a chave para o sistema, considerando que tenha copiado a chave para o computador.
- `gpg --keyserver keys.gnupg.net --recv-keys id_chave`: importa buscando de um servidor de chaves. (confirme com o comando de listar as chaves se realmente importou)

#### Criptografar, Descriptografar, Assinar

- `gpg --recipient "rodrigo" --output nome-criptografado.gpg --encrypt nome.txt`: criptografa o arquivo nome.txt para envio. `--recipient` indica a identificação da chave pública que será usada. `--output é o nome do arquivo após criptografar` e `--encrypt é o nome do arquivo a ser criptografado`. Pode usar `--armor` para criptografar em modo ASCII

O envio pode ser da forma que preferir, pode ser por `scp`, por exemplo.

- `scp nome-criptografado.gpg lpi1@10.0.0.113:~/`: envia para o diretório home (da máquina que criou o arquivo para a outra que irá lê-lo)
- `scp lpi1@10.0.0.113:~/nome-criptografado.gpg .`: puxa o arquivo criptografado (considerando que esteja no PC que irá receber o arquivo, puxando do PC que criptografou o arquivo)

Agora basta descriptografar o arquivo, usando a chave privada.
- `gpg --output nome-descriptografado.txt --decrypt nome-criptografado.gpg`: vai descriptografar, e vai pedir a a senha da chave privada, caso tenha. Depois já é possível ler o arquivo.

#### Assinar um arquivo

Não criptografa, apenas certifica que foi a pessoa que gerou o arquivo (confirma que foi realmente a pessoa que criou).

Agora o fluxo é o dono do arquivo assinar com a sua respectiva chave privada, e quem recebe a mensagem usa a chave pública do usuário que criou para conferir.

Importante dizer que o arquivo é legível normalmente, apenas a assinatura que é verificada.

- `gpg --sign arquivo.pdf`: assina o arquivo `arquivo.pdf`. Pode usar `--armor` para assinar em texto ascii. Vai criar um arquivo chamado `arquivo.pdf.gpg` ou `arquivo.pdf.asc` se usou a opção `--armor`

Após copiar o arquivo de assinatura para o outro computador, use a chave pública para verificar a assinatura:
- `gpg --verify arquivo.pdf.gpg` ou `.asc`: verifica a assinatura. Atentar se retorna `Good signture`:
```
gpg: Signature made Thu 09 Dec 2024 19:50:16 AM -03
gpg:                using RSA key 8E54602D4010AE770A9C9ADE39EC219E01086829
gpg: Good signature from "rodrigo (rodrigo's key) <email@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 8E84 602D 4310 AE77 0A9C  9ADE 39EC 219E 0108 9829
```

- `gpg --decrypt arquivo.pdf.asc` ou `.gpg`: mostra o conteúdo do arquivo e no rodapé mostra a assinatura.

Caso envie esse arquivo para algum usuário que não tenha a chave pública, e tente verificar a assinatura (`--verify`), não será possível fazer a verificação.

Caso use o comando `--decrypt`, será possível ler o arquivo (lembre-se, não está criptografado, apenas assinado), no entanto no rodapé teremos uma mensagem que não é possível verificar a assinatura (`gpg: Can't check signature: public key not found`)

#### gpg-agent

É um agent parecido com o do SSH (`ps axu | grep gpg-agent`), que fica monitorando para guardar a passphrase temporariamente em memória, para não ter que ficar digitando repetidas vezes. Ele sobe em memória ao usar algum comando `gpg`.

Ao assinar um documento, por exemplo (`gpg --sign syslog`), vai pedir a passphrase (para acessar a chave privada), e caso assine outro documento, não vai mais pedir para digitar.

Se matarmos o `gpg-agent` (`gpgconf --kill gpg-agent`), e tentar assinar novamente um arquivo, vai, novamente, pedir para digitar a passphrase, e, consequentemente, subir o `gpg-agent` novamente.

Esse acesso é feito por meio de um socket, que fica na variável de ambiente `GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1`, visto com o comando `env | grep GPG`

